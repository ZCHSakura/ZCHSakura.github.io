<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL最左前缀</title>
    <url>/MySQL%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<p>记录下MySQL中索引的最左前缀原则和联合索引有什么好处</p>
<a id="more"></a>
<h3 id="最左前缀原则">最左前缀原则</h3>
<p>最左匹配原则就是指在联合索引中，如果你的 SQL
语句中用到了联合索引中的最左边的索引，那么这条 SQL
语句就可以利用这个联合索引去进行匹配。例如某表现有索引(a,b,c)，现在你有如下语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where a&#x3D;1 and b&#x3D;1 and c &#x3D;1;     #这样可以利用到定义的索引（a,b,c）,用上a,b,c</span><br><span class="line"></span><br><span class="line">select * from t where a&#x3D;1 and b&#x3D;1;     #这样可以利用到定义的索引（a,b,c）,用上a,b</span><br><span class="line"></span><br><span class="line">select * from t where b&#x3D;1 and a&#x3D;1;     #这样可以利用到定义的索引（a,b,c）,用上a,b（mysql有查询优化器）</span><br><span class="line"></span><br><span class="line">select * from t where a&#x3D;1;     #这样也可以利用到定义的索引（a,b,c）,用上a</span><br><span class="line"></span><br><span class="line">select * from t where b&#x3D;1 and c&#x3D;1;     #这样不可以利用到定义的索引（a,b,c）</span><br><span class="line"></span><br><span class="line">select * from t where a&#x3D;1 and c&#x3D;1;     #这样可以利用到定义的索引（a,b,c），但只用上a索引，b,c索引用不到</span><br></pre></td></tr></table></figure>
<p><strong>当遇到范围查询(&gt;、&lt;、between、like)就会停止匹配</strong>。也就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where a&#x3D;1 and b&gt;1 and c &#x3D;1; #这样a,b可以用到（a,b,c），c索引用不到</span><br></pre></td></tr></table></figure>
<p>这条语句只有 a,b 会用到索引，c
都不能用到索引。这个原因可以从联合索引的结构来解释。</p>
<p>但是如果是建立(a,c,b)联合索引，则a,b,c都可以使用索引，因为优化器会自动改写为最优查询语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where a&#x3D;1 and b &gt;1 and c&#x3D;1;  #如果是建立(a,c,b)联合索引，则a,b,c都可以使用索引</span><br><span class="line">#优化器改写为</span><br><span class="line">select * from t where a&#x3D;1 and c&#x3D;1 and b &gt;1;</span><br></pre></td></tr></table></figure>
<p>以index
（a,b,c）为例建立这样的索引相当于建立了索引a、ab、abc三个索引。</p>
<h3 id="联合索引优点">联合索引优点</h3>
<ul>
<li><strong>减少开销。</strong>建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！</li>
<li><strong>覆盖索引。</strong>对联合索引(col1,col2,col3)，如果有如下的sql:
select col1,col2,col3 from test where col1=1 and
col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。</li>
<li><strong>效率高。</strong>索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select
from table where col1=1 and col2=2 and
col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W
* 10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3=
3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w *10%
*10% *10%=1w，效率提升可想而知！</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>CICFlowMeter部署</title>
    <url>/CICFlowMeter%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>记录下在X86和arm架构上部署CICFlowMeter的整体流程和各种问题，笔者在部署的时候真的是遇到过很多问题，部署到ARM上更是难搞，这里记录下顺便看能不能帮助其他人。</p>
<a id="more"></a>
<h2 id="部署整体流程">部署整体流程</h2>
<p>下面我把CICFlowMeter简写为CIC。这里先说一下联网部署的整体流程，在联网情况下部署一般只有一个问题，就是jnetpcap依赖的安装。</p>
<blockquote>
<p>在这里特别提醒一下，尽量不要使用open
jdk，笔者使用openjdk就会有问题，建议最好使用Oracle的JDK！！！！！！</p>
<p>还有就是笔者尝试过在相同操作系统，相同架构的电脑上完成打包的CIC是可以直接复制到别的电脑上的，这就意味着在另一台电脑上不用配置mvn和gradle这些内容，只需要配置JDK然后把打出来的压缩包复制过去，然后配置好libpcap-dev和jnetpcap依赖就可以使用了，不同系统和架构的笔者没有尝试过。</p>
</blockquote>
<h3 id="环境配置">环境配置</h3>
<p>笔者使用是自己下载的软件包，所以要自己配置下环境</p>
<ul>
<li><p>/etc/profile</p></li>
<li><p>/home/user(用户名)/.bashrc</p></li>
</ul>
<p>在上述两个文件末尾中添加下列环境变量，添加完成后使用source
etc/profile和source /home/user/.bashrc</p>
<ul>
<li>配置jdk 1.8.0_311</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;***&#x2F;Traffic_arm&#x2F;jdk1.8.0_333</span><br><span class="line">export JRE_HOME&#x3D;$JAVA_HOME&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;$JAVA_HOME&#x2F;lib:$JRE_HOME&#x2F;lib</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>
<ul>
<li>配置maven 3.8.4</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export MAVEN_HOME&#x3D;&#x2F;***&#x2F;Traffic_arm&#x2F;apache-maven-3.8.4</span><br><span class="line">export PATH&#x3D;$PATH:$MAVEN_HOME&#x2F;bin</span><br></pre></td></tr></table></figure>
<ul>
<li>配置gradle 3.3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GRADLE_HOME&#x3D;&#x2F;***&#x2F;Traffic_arm&#x2F;gradle-3.3</span><br><span class="line">export PATH&#x3D;$GRADLE_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>
<h3 id="验证环境是否配置成功">验证环境是否配置成功</h3>
<ul>
<li><p>使用java -version查看java版本是否与环境变量中一致</p></li>
<li><p>使用which java查看路径是否与环境变量一致</p></li>
<li><p>如果which
java显示与环境变量不一致，而是/usr/bin/java之类的路径则使用以下命令（这种情况主要是机子上本身存在jdk，理论上将如果在配置环境变量时如果把新的路径放在$PATH前的话是不会出现这个问题的）</p></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm &#x2F;usr&#x2F;bin&#x2F;java（which java 结果）</span><br><span class="line">sudo ln -s &#x2F;***&#x2F;Traffic_x86&#x2F;jdk1.8.0_311&#x2F;bin&#x2F;java &#x2F;usr&#x2F;bin&#x2F;java（which java 结果）</span><br></pre></td></tr></table></figure>
<ul>
<li><p>再使用java -version和which java验证环境配置结果</p></li>
<li><p>如果还没有生效尝试关闭shell重开一个shell或切换用户看有无生效</p></li>
<li><p>如果出现权限不够的情况，使用sudo chmod 777 path 修改权限</p></li>
</ul>
<h3 id="导入jnetpcap">导入jnetpcap</h3>
<ul>
<li>Dfile路径改为/Traffic_arm/CICFlowMeter-master/jnetcap/linux/jnetpcap-1.4.r1425下的jnetpcap.jar</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -Dfile&#x3D;&#x2F;***&#x2F;jnetpcap.jar -DgroupId&#x3D;org.jnetpcap -DartifactId&#x3D;jnetpcap -Dversion&#x3D;1.4.1 -Dpackaging&#x3D;jar</span><br></pre></td></tr></table></figure>
<ul>
<li>在/Traffic_arm/CICFlowMeter-master下构建项目</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;gradlew distZip</span><br></pre></td></tr></table></figure>
<ul>
<li>在/Traffic_arm/CICFlowMeter-master/build/distributions里解压缩CICFlowMeter-4.0.zip</li>
<li>安装libpcap-dev依赖（centos里面好像是libpcap-devel）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libpcap-dev</span><br><span class="line">yum install libpcap-devel</span><br></pre></td></tr></table></figure>
<ul>
<li>将/CICFlowMeter-master/jnetcap/linux/jnetpcap-1.4.r1425里的libjnetpcap.so和libjnetpcap-pcap100.so复制到/Traffic_arm/jdk1.8.0_333/jre/lib/aarch64（或amd64，和平台架构相关）目录下</li>
<li>在/***/Traffic_arm/CICFlowMeter-master/build/distributions/CICFlowMeter-4.0/bin运行cfm文件即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;cfm [pcap_file] [target_path]</span><br><span class="line">&#x2F;***&#x2F;Traffic&#x2F;CICFlowMeter-master&#x2F;build&#x2F;distributions&#x2F;CICFlowMeter-4.0&#x2F;bin&#x2F;cfm ***.pcap &#x2F;***&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="相关描述">相关描述</h3>
<ul>
<li>按照上述操作在有网的x86的Ubuntu中应该是不会出现问题的，笔者已经在多台X86的Ubuntu中成功部署。</li>
<li>在一个全新的机子上部署是要走完以上全部流程的，但是笔者本身不会JAVA所以不是很清楚mvn和gradle这样使用的原理，<a
href="https://github.com/ahlashkari/CICFlowMeter">CICgithub</a>上作者就是这么用的，github上的流程是在为了在IDE上能使用，但是我们希望把他变成一个工具在任何地方都可以通过命令行使用，所以要把两个so动态库放到jre里面去，这个大概就是要我们在命令行全局使用的时候能找到jnetpcap的动态链接库，这就涉及到了JAVA本身的依赖管理，<del>笔者确实不懂JAVA，都是师兄教的😀。</del></li>
<li>在X86的Ubuntu上使用上述步骤理论上讲不存在问题了，但是在别的操作系统或者非X86架构上还是存在问题，一般主要是遇到下面这个问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cic.cs.unb.ca.ifm.Cmd You select: &#x2F;Integ&#x2F;pcapsource&#x2F;d1&#x2F;1_00001_20210104112753.pcap</span><br><span class="line">cic.cs.unb.ca.ifm.Cmd Out folder: .&#x2F;</span><br><span class="line">cic.cs.unb.ca.ifm.Cmd CICFlowMeter received 1 pcap file</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.UnsatisfiedLinkError: com.slytechs.library.NativeLibrary.dlopen(Ljava&#x2F;lang&#x2F;String;)J</span><br><span class="line">        at com.slytechs.library.NativeLibrary.dlopen(Native Method)</span><br><span class="line">        at com.slytechs.library.NativeLibrary.&lt;init&gt;(Unknown Source)</span><br><span class="line">        at com.slytechs.library.JNILibrary.&lt;init&gt;(Unknown Source)</span><br><span class="line">        at com.slytechs.library.JNILibrary.loadLibrary(Unknown Source)</span><br><span class="line">        at com.slytechs.library.JNILibrary.register(Unknown Source)</span><br><span class="line">        at com.slytechs.library.JNILibrary.register(Unknown Source)</span><br><span class="line">        at com.slytechs.library.JNILibrary.register(Unknown Source)</span><br><span class="line">        at org.jnetpcap.Pcap.&lt;clinit&gt;(Unknown Source)</span><br><span class="line">        at cic.cs.unb.ca.jnetpcap.PacketReader.config(PacketReader.java:58)</span><br><span class="line">        at cic.cs.unb.ca.jnetpcap.PacketReader.&lt;init&gt;(PacketReader.java:52)</span><br><span class="line">        at cic.cs.unb.ca.ifm.Cmd.readPcapFile(Cmd.java:128)</span><br><span class="line">        at cic.cs.unb.ca.ifm.Cmd.main(Cmd.java:80)</span><br></pre></td></tr></table></figure>
<ul>
<li>这个问题根据笔者自己的尝试和网上的 <a
href="https://blog.csdn.net/lizheng2017/article/details/121455590">参考</a>
基本可以确定是由于jnetpcap这个东西引起的，应该是jnetpcap这个东西在不同架构下不兼容的问题，在arm架构上使用CICgithub中提供的so是不行的，必须要自己重新编译，甚至我之后在部署一台X86的centos的时候这个os也不能用最后还是笔者自己重新编译之后才能使用，这个东西的兼容性确实很差，实在不行了需要编译安装的时候可以看下面的内容。</li>
</ul>
<h2 id="x86架构">X86架构</h2>
<blockquote>
<p>对X86架构下的Ubuntu系统来讲，按照上述流程应该不会存在问题，github上提供的jnetpcap的so本身是适配ubuntu的。</p>
<p>对X86架构下的Centos和其他系统来讲，可能会遇到上面jnetpcap报错的问题，那应该就是github上提供的so依赖和系统不兼容，需要重新编译，或者看网上有没有好心人提供编译好的，或者看下面的jnetpcap编译安装部分。</p>
</blockquote>
<h2 id="arm架构">ARM架构</h2>
<blockquote>
<p>ARM架构下的部署，最主要的问题还是在jnetpcap上，github上提供的so肯定是用不了的，笔者也亲身体验过，确实不行。但是笔者这里在CSDN上搜到了一个好心老哥自己在银河麒麟V10，
aarch64架构上编译出来的结果，这里贴出来供大家参考。</p>
</blockquote>
<p><a
href="https://blog.csdn.net/lizheng2017/article/details/121455590">ARM架构依赖</a></p>
<h2 id="jnetpcap编译安装">jnetpcap编译安装</h2>
<p>以下内容全部来源于上面ARM架构中提到的好心老哥，而且他还提供了他编译好的so，真的是大善人，我怕他的博客哪天没了所以我这里复制一遍<a
href="https://blog.csdn.net/lizheng2017/article/details/121455590">ARM架构依赖</a></p>
<hr />
<p><strong>编译环境</strong>：银河麒麟V10， aarch64架构
网上很容易下载到jnetpcap的包，但是却没有arm64架构的编译好的so，于是下载源码包自己编译。下面是遇到的问题解决，整个流程耗时6个多小时：</p>
<ol type="1">
<li>下载jnetpcap-src-1.4.r1425-1.zip并解压：</li>
</ol>
<figure>
<img
src="https://zchsakura-blog.oss-cn-beijing.aliyuncs.com/202207061639724.png"
alt="解压的文件" />
<figcaption aria-hidden="true">解压的文件</figcaption>
</figure>
<ol start="2" type="1">
<li>安装ant， 命令大概是：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install ant</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>编译，问题1，xml:119: taskdef class org . vafer.jdeb . ant
DebAntTask cannot be found using the classloader AntclassL oader[ ]</li>
</ol>
<figure>
<img
src="https://zchsakura-blog.oss-cn-beijing.aliyuncs.com/202207061639887.png"
alt="问题1" />
<figcaption aria-hidden="true">问题1</figcaption>
</figure>
<p>​ 方法：直接将build.xml第119行删除，不是debian系统。</p>
<ol start="4" type="1">
<li>编译，问题2，use aresiurce collection to copy directories.</li>
</ol>
<figure>
<img
src="https://zchsakura-blog.oss-cn-beijing.aliyuncs.com/202207061640674.png"
alt="问题2" />
<figcaption aria-hidden="true">问题2</figcaption>
</figure>
<p>​
根据提示，xml的611行有问题，直接找到你系统的libpcap.so的路径，填入xml：</p>
<figure>
<img
src="https://zchsakura-blog.oss-cn-beijing.aliyuncs.com/202207061640724.png"
alt="问题行" />
<figcaption aria-hidden="true">问题行</figcaption>
</figure>
<figure>
<img
src="https://zchsakura-blog.oss-cn-beijing.aliyuncs.com/202207061640701.png"
alt="解决方法" />
<figcaption aria-hidden="true">解决方法</figcaption>
</figure>
<ol start="5" type="1">
<li>编译，问题3，网上的答案都说是xml的问题，但在这里其实是少了cpptask.jar的原因。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Problem: failed to create task or type cc</span><br><span class="line">Cause: The name is undefined.</span><br><span class="line">Action: Check the spelling.</span><br><span class="line">Action: Check that any custom tasks&#x2F;types have been declared.</span><br><span class="line">Action: Check that any &lt;presetdef&gt;&#x2F;&lt;macrodef&gt; declarations have taken place.</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://zchsakura-blog.oss-cn-beijing.aliyuncs.com/202207061641290.png"
alt="问题3" />
<figcaption aria-hidden="true">问题3</figcaption>
</figure>
<p>​ 解决办法：下载cpptasks-1.0b4.jar，放到jnetpcap的lib文件夹下。</p>
<p>​
这里的具体cpptasks.jar的版本需要你查看xml文件，放的路径也是要看xml，直接在xml中搜索cpptask相信你能找到线索的。</p>
<p>​
ps：我这里是放的路径是[项目路径]/cpptasks-1.0b4/cpptasks.jar，然后在xml里面路径直接写死</p>
<ol start="6" type="1">
<li>编译，问题四：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;C ommand- line&gt;:0: 19: error: token “”is not valid in preprocessor expressions&#x2F;home&#x2F;ka&#x2F; jnetpcap-src-1.4.1425-1&#x2F;src&#x2F;c&#x2F;jnetpcap_pcap100.cpp:87:6: note: in expansion of macro &#39; L IBPCAP_ VERSION &#39;</span><br><span class="line">#if (L IBPCAP VERSION &lt; L IBPCAP PCAP CREATE )</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://zchsakura-blog.oss-cn-beijing.aliyuncs.com/202207061643419.png"
alt="问题四" />
<figcaption aria-hidden="true">问题四</figcaption>
</figure>
<p>​
解决，明显是找不到LIBPCAP_VERSION，即libpcap的版本号没有，我们编辑Linux.properties文件，添加如下行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">complier.LIBPCAP_VERSION &#x3D; 174</span><br><span class="line">(具体版本可用apt list|grep libpcap获取，填个很大的数就行)，这里一定是一个数字，不能像1.7.4这样。</span><br></pre></td></tr></table></figure>
<p><img
src="https://zchsakura-blog.oss-cn-beijing.aliyuncs.com/202207061644038.png" /></p>
<ol start="7" type="1">
<li>问题五</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	[javac] 注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。</span><br><span class="line">    [javac] 注: 某些输入文件使用了未经检查或不安全的操作。</span><br><span class="line">    [javac] 注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。</span><br><span class="line">    [javac] 78 个错误</span><br><span class="line"></span><br><span class="line">BUILD FAILED</span><br><span class="line">&#x2F;home&#x2F;ka&#x2F;jnetpcap-src-1.4.r1425-1&#x2F;build.xml:1090: Compile failed; see the compiler error output for details.</span><br><span class="line">        at org.apache.tools.ant.taskdefs.Javac.compile(Javac.java:1181)</span><br><span class="line">        at org.apache.tools.ant.taskdefs.Javac.execute(Javac.java:936)</span><br><span class="line">        at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:293)</span><br><span class="line">        at sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">        at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)</span><br><span class="line">        at org.apache.tools.ant.Task.perform(Task.java:348)</span><br><span class="line">        at org.apache.tools.ant.Target.execute(Target.java:435)</span><br><span class="line">        at org.apache.tools.ant.Target.performTasks(Target.java:456)</span><br><span class="line">        at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1405)</span><br><span class="line">        at org.apache.tools.ant.Project.executeTarget(Project.java:1376)</span><br><span class="line">        at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)</span><br><span class="line">        at org.apache.tools.ant.Project.executeTargets(Project.java:1260)</span><br><span class="line">        at org.apache.tools.ant.Main.runBuild(Main.java:853)</span><br><span class="line">        at org.apache.tools.ant.Main.startAnt(Main.java:235)</span><br><span class="line">        at org.apache.tools.ant.launch.Launcher.run(Launcher.java:285)</span><br><span class="line">        at org.apache.tools.ant.launch.Launcher.main(Launcher.java:112)</span><br></pre></td></tr></table></figure>
<p><img
src="https://zchsakura-blog.oss-cn-beijing.aliyuncs.com/202207061645003.png" /></p>
<p>​
这个问题可能是我没有下载正确版本的cpptask的原因，要根据build.xml里的要求来下载。
但是检查./build/obj/我已经得到了我们想要的so文件</p>
<figure>
<img
src="https://zchsakura-blog.oss-cn-beijing.aliyuncs.com/202207061645493.png"
alt="大功告成" />
<figcaption aria-hidden="true">大功告成</figcaption>
</figure>
<p>程序终于跑起来了！！！！！！！</p>
<p><img
src="https://zchsakura-blog.oss-cn-beijing.aliyuncs.com/202207061646710.png" /></p>
<h3 id="附编译好的文件链接">附编译好的文件链接</h3>
<p>https://download.csdn.net/download/lizheng2017/46217421</p>
<h2 id="离线部署">离线部署</h2>
<p>离线部署其实挺麻烦的，如果平时没有经常使用Linux服务器的话还是比较恼火的，最好的方法还是让机子联网，但是确实有很多情况下没法联网，笔者这里也只能提供我在尝试离线部署过程中的一些经验</p>
<ul>
<li>尽量找到一台相同系统相同架构的能联网的机器，这会让离线部署简单得多，apt和yum都提供了下载安装包的功能，我们可以在能联网的机子上先下载好适配的离线包然后复制到不能联网的机子上进行编译安装，这样的成功率就会很高，也比较方便，这里贴两个参考<a
href="https://blog.csdn.net/qq_17576885/article/details/122070612">apt离线包下载</a>，<a
href="https://www.codeleading.com/article/78986008408/">yum离线包下载</a></li>
<li>相同系统相同架构的机器不用每个都使用mvn和gradle，只要有一台成功打出了压缩包后面就可以直接复制，只要配置新机器的JDK和各种依赖就行了</li>
</ul>
<h2 id="其他问题">其他问题</h2>
<h3 id="问题1">问题1</h3>
<blockquote>
<p>问题描述：经过上面的一通操作，CIC已经成功跑了起来，我把CIC用python封装成了一个接口供后端调用，但是出现了一个非常奇怪的问题，那就我直接跑我的接口CIC稳定能用，但是后端调我的接口就时而能用时而不行，一旦不行之后就稳定不行。</p>
</blockquote>
<blockquote>
<p>这个问题的产生是因为后端使用Linux的/etc/crontab做了后端服务的定时重启，但是crontab里面有一个自己的$PATH，并且它不会去读取/etc/profile里面的路径，所以会导致读不到我们的JDK和各种依赖，解决方法也很简单，只要把我们在profile里面写的JDK路径加到crontab里面就行了</p>
</blockquote>
<h3 id="问题2">问题2</h3>
<blockquote>
<p>问题描述：在实际使用中我们发现提取出来的协议号基本只有0，6，17。6代表TCP，17代表UDP，剩下其他所有协议全部被识别为0，例如ARP，ICMP，SEP之类的全部识别为0，而且组流的情况看起来也不是很好，绝大部分列都是全为0，简单看了下代码发现CIC本事就只对有限的几种protocol做了处理，泛用性不是很广。</p>
</blockquote>
<figure>
<img
src="https://zchsakura-blog.oss-cn-beijing.aliyuncs.com/202207061724179.png"
alt="protocol" />
<figcaption aria-hidden="true">protocol</figcaption>
</figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>CICFlowMeter</category>
      </categories>
      <tags>
        <tag>CICFlowMeter</tag>
      </tags>
  </entry>
  <entry>
    <title>Python常用内置函数</title>
    <url>/Python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>记录Python常用的内置函数</p>
<a id="more"></a>
<p>Python给我们内置了大量功能函数，官方文档上列出了69个，有些是我们是平时开发中经常遇到的，也有一些函数很少被用到，这里列举被开发者使用最频繁的8个函数以及他们的详细用法</p>
<figure>
<img
src="https:////upload-images.jianshu.io/upload_images/15801507-d86739dc54bc18fa.jpg!web?imageMogr2/auto-orient/strip%7CimageView2/2/w/550/format/webp"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="print">print()</h3>
<p>print函数是你学Python接触到的第一个函数，它将对象输出到标准输出流，可将任意多个对象打印出来，函数的具体定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(*objects, sep=<span class="string">' '</span>, end=<span class="string">'\n'</span>, file=sys.stdout, flush=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>objects 是可变参数，所以你可以同时将任意多个对象打印出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)  </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>默认使用空格分隔每个对象，通过指定sep参数可以使用逗号分隔</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, sep=<span class="string">','</span>)  </span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>对象默认输出的是标准输出流，你也可以将内容保存到文件中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, sep=<span class="string">','</span>, file=open(<span class="string">"hello.txt"</span>, <span class="string">"w"</span>))</span><br></pre></td></tr></table></figure>
<h3 id="isinstance">isinstance()</h3>
<p>可以用 isinstance
函数判断某个对象是否属于某个类的实例，函数的定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isinstance(object, classinfo)</span><br></pre></td></tr></table></figure>
<p>classinfo
既可以是单个类型对象，也可以是由多个类型对象组成的元组，只要object的类型是元组中任意一个就返回True，否则返回False</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">1</span>, (int, str))  </span><br><span class="line"><span class="literal">True</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">""</span>, (int, str))  </span><br><span class="line"><span class="literal">True</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], dict)  </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="range">range()</h3>
<p>range函数是个工厂方法，用于构造一个从[start, stop)
（不包含stop）之间的连续的不可变的整数序列对象，这个序列功能上和列表非常类似，函数定义：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">range([start,] stop [, step]) -&gt; range object</span><br></pre></td></tr></table></figure>
<ul>
<li>start 可选参数，序列的起点，默认是0</li>
<li>stop 必选参数，序列的终点（不包含）</li>
<li>step 可选参数，序列的步长，默认是1，生成的元素规律是 r[i] = start +
step*i</li>
</ul>
<p>生成0~5的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>range(<span class="number">5</span>)  </span><br><span class="line">range(<span class="number">0</span>, <span class="number">5</span>)     </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">5</span>))  </span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>默认从0开始，生成0到4之间的5个整数，不包含5，step
默认是1，每次都是在前一次加1</p>
<p>如果你想将某个操作重复执行n遍，就可以使用for循环配置range函数实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):  </span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"hello python"</span>)  </span><br><span class="line"><span class="meta">... </span> </span><br><span class="line">hello python  </span><br><span class="line">hello python  </span><br><span class="line">hello python</span><br></pre></td></tr></table></figure>
<p>步长为2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)  </span><br><span class="line">range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>))  </span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>起点从1开始，终点10，步长为2，每次都在前一个元素的基础上加2，构成1到10之间的奇数。</p>
<h3 id="enumerate">enumerate()</h3>
<p>用于枚举可迭代对象，同时还可以得到每次元素的下表索引值，函数定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">enumerate(iterable, start=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(<span class="string">"python"</span>):  </span><br><span class="line"><span class="meta">... </span>    print(index, value)  </span><br><span class="line"><span class="meta">... </span> </span><br><span class="line"><span class="number">0</span> p  </span><br><span class="line"><span class="number">1</span> y  </span><br><span class="line"><span class="number">2</span> t  </span><br><span class="line"><span class="number">3</span> h  </span><br><span class="line"><span class="number">4</span> o  </span><br><span class="line"><span class="number">5</span> n</span><br></pre></td></tr></table></figure>
<p>index 默认从0开始，如果显式指定参数start，下标索引就从start开始</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(<span class="string">"python"</span>, start=<span class="number">1</span>):  </span><br><span class="line"><span class="meta">... </span>    print(index, value)  </span><br><span class="line"><span class="meta">... </span> </span><br><span class="line"><span class="number">1</span> p  </span><br><span class="line"><span class="number">2</span> y  </span><br><span class="line"><span class="number">3</span> t  </span><br><span class="line"><span class="number">4</span> h  </span><br><span class="line"><span class="number">5</span> o  </span><br><span class="line"><span class="number">6</span> n</span><br></pre></td></tr></table></figure>
<p>如果不使用enumerate函数，要获取元素的下标索引，则需要更多的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_enumerate</span><span class="params">(sequence, start=<span class="number">0</span>)</span>:</span>  </span><br><span class="line">    n = start  </span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> sequence:  </span><br><span class="line">        <span class="keyword">yield</span> n, e  </span><br><span class="line">        n += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> index, value <span class="keyword">in</span> my_enumerate(<span class="string">"python"</span>):  </span><br><span class="line">    print(index, value)  </span><br><span class="line"><span class="number">0</span> p  </span><br><span class="line"><span class="number">1</span> y  </span><br><span class="line"><span class="number">2</span> t  </span><br><span class="line"><span class="number">3</span> h  </span><br><span class="line"><span class="number">4</span> o  </span><br><span class="line"><span class="number">5</span> n</span><br></pre></td></tr></table></figure>
<h3 id="len">len</h3>
<p>len 用于获取容器对象中的元素个数，例如判断列表是否为空可以用 len
函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  </span><br><span class="line"><span class="number">3</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">"python"</span>)  </span><br><span class="line"><span class="number">6</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> len([]) == <span class="number">0</span>:  </span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>并不是所有对象都支持len操作的，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="literal">True</span>)  </span><br><span class="line">Traceback (most recent call last):  </span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;  </span><br><span class="line">TypeError: object of type <span class="string">'bool'</span> has no len()</span><br></pre></td></tr></table></figure>
<p>除了序列对象和集合对象，自定义类必须实现了 <strong>len</strong>
方法能作用在len函数上</p>
<h3 id="reversed">reversed()</h3>
<p>reversed()
反转序列对象，你可以将字符串进行反转，将列表进行反转，将元组反转</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(reversed([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="open">open()</h3>
<p>open 函数用于构造文件对象，构建后可对其进行内容的读写操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">open(file, mode=<span class="string">'r'</span>, encoding=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>读操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从当前路径打开文件 test.txt， 默认以读的方式  </span></span><br><span class="line">&gt;&gt;&gt;f = open(<span class="string">"test.txt"</span>)  </span><br><span class="line">&gt;&gt;&gt;f.read()  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>有时还需要指定编码格式，否则会遇到乱码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">"test.txt"</span>, encoding=<span class="string">'utf8'</span>)</span><br></pre></td></tr></table></figure>
<p>写操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;f = open(<span class="string">"hello.text"</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf8'</span>)  </span><br><span class="line">&gt;&gt;&gt;f.write(<span class="string">"hello python"</span>))</span><br></pre></td></tr></table></figure>
<p>文件中存在内容时原来的内容将别覆盖，如果不想被覆盖，直接将新的内容追加到文件末尾，可以使用
a 模式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">"hello.text"</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf8'</span>)  </span><br><span class="line">f.write(<span class="string">"!!!"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="sorted">sorted()</h3>
<p>sroted
是对列表进行重新排序，当然其他可迭代对象都支持重新排放，返回一个新对象，原对象保持不变</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>])  </span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装MySQL</title>
    <url>/Ubuntu%E5%AE%89%E8%A3%85mysql/</url>
    <content><![CDATA[<p>服务器安装MySQL有些方法搞的十分麻烦，这里记录一个Ubuntu适用的简单的方法，同时修改字符集为utf8mb4（毕竟MySQL的utf8是个赝品）</p>
<a id="more"></a>
<p>参考 <a
href="https://blog.csdn.net/mr_hui_/article/details/88878836">Ubuntu安装mysql</a>
<a
href="https://www.cnblogs.com/silentmuh/p/11082622.html">更改数据库的编码为utf8mb4</a>
<a
href="https://www.jb51.net/article/165260.htm">MySQL字符集utf8修改为utf8mb4的方法步骤</a></p>
<h2 id="ubuntu安装mysql">1.Ubuntu安装MySQL</h2>
<p><strong>首先执行下面三条命令：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt install mysql-client</span><br><span class="line">sudo apt install libmysqlclient-dev</span><br></pre></td></tr></table></figure>
<p><strong>安装成功后可以通过下面的命令测试是否安装成功：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netstat -tap | grep mysql</span><br></pre></td></tr></table></figure>
<p><strong>出现如下信息则安装成功</strong> <img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20200429135052.png"
alt="image_1b6gfob7m1u4f2i0av11afd92m9" /></p>
<p><strong>可以通过如下命令进入MySQL服务：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p你的密码</span><br></pre></td></tr></table></figure>
<p>现在设置MySQL允许远程访问，首先编辑文件/etc/mysql/mysql.conf.d/mysqld.cnf：</p>
<p><strong>注释掉bind-address = 127.0.0.1：</strong></p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20200429134856.png"
alt="image_1b6ggmf7h1d6b17o11iha1j1nhtem" />
<figcaption
aria-hidden="true">image_1b6ggmf7h1d6b17o11iha1j1nhtem</figcaption>
</figure>
<p><strong>保存退出，然后进入mysql服务，执行授权命令：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant all on *.* to root@&#39;%&#39; identified by &#39;你的密码&#39; with grant option;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p><strong>然后执行quit命令退出mysql服务，执行如下命令重启mysql：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure>
<p>现在在windows下可以使用navicat远程连接ubuntu下的mysql服务。</p>
<h2 id="更换字符集为utf8mb4">2.更换字符集为utf8mb4</h2>
<p>utf8mb4编码是utf8编码的超集，兼容utf8，并且能存储4字节的表情字符。
采用utf8mb4编码的好处是：存储与获取数据的时候，不用再考虑表情字符的编码与解码问题。</p>
<h3 id="mysql的版本">2.1MySQL的版本</h3>
<p>utf8mb4的最低mysql版本支持版本为5.5.3+，若不是，请升级到较新版本。</p>
<h3 id="mysql驱动">2.2MySQL驱动</h3>
<p>5.1.34可用,最低不能低于5.1.13</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES WHERE Variable_name LIKE &#39;character_set_%&#39; OR Variable_name LIKE &#39;collation%&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20200429134724.png"
alt="20180828153217974" />
<figcaption aria-hidden="true">20180828153217974</figcaption>
</figure>
<h3 id="修改mysql配置文件">2.3修改MySQL配置文件</h3>
<p>修改mysql配置文件my.cnf
my.cnf一般在etc/mysql/my.cnf位置。找到后请在以下三部分里添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[client] </span><br><span class="line">default-character-set &#x3D; utf8mb4</span><br><span class="line"></span><br><span class="line">[mysql] </span><br><span class="line">default-character-set &#x3D; utf8mb4 </span><br><span class="line"></span><br><span class="line">[mysqld] </span><br><span class="line">character-set-client-handshake &#x3D; FALSE </span><br><span class="line">character-set-server &#x3D; utf8mb4 </span><br><span class="line">collation-server &#x3D; utf8mb4_unicode_ci </span><br><span class="line">init_connect&#x3D;&#39;SET NAMES utf8mb4&#39;</span><br></pre></td></tr></table></figure>
<p>在这里我遇到了问题，首先用上面的方法安装的mysql的my.cnf里面并没有实际的东西而是进行引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!includedir &#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;</span><br><span class="line">!includedir &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;</span><br></pre></td></tr></table></figure>
<p>所以我去这两个文件夹找到了相应的内容进行了修改还有一个是在my.cnf的同级文件<code>debian.cnf</code>中</p>
<p><strong>但是！！！</strong></p>
<p>我修改完之后使用<code>service mysqld restart</code>说没有mysqld，然后我查了一下我这种安装方式应该使用<code>service mysql restart</code>,但是我使用了之后报错，第一是因为权限问题，这个可以看错误日志发现，第二就是上面添加的内容有问题，问题出在[mysqld]里，具体原因是什么我也不是很清楚，我又换了一个版本发现可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[client] </span><br><span class="line">default-character-set&#x3D;utf8mb4 </span><br><span class="line">  </span><br><span class="line">[mysqld] </span><br><span class="line">character-set-server &#x3D; utf8mb4 </span><br><span class="line">collation-server &#x3D; utf8mb4_unicode_ci </span><br><span class="line">init_connect&#x3D;&#39;SET NAMES utf8mb4&#39;</span><br><span class="line">skip-character-set-client-handshake &#x3D; true </span><br><span class="line"># 一个是自己为false一个是skip自己为true，感觉上一样的，不知道啥意思</span><br><span class="line">  </span><br><span class="line">[mysql] </span><br><span class="line">default-character-set &#x3D; utf8mb4</span><br></pre></td></tr></table></figure>
<p><strong>最后</strong></p>
<p>进去mysql之后使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES WHERE Variable_name LIKE &#39;character_set_%&#39; OR Variable_name LIKE &#39;collation%&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20200429124058.png"
alt="image-20200429124011522" />
<figcaption aria-hidden="true">image-20200429124011522</figcaption>
</figure>
<p><strong>大功告成 Peace</strong></p>
<h2 id="补充">3.补充</h2>
<h3 id="修改database默认的字符集">3.1修改database默认的字符集</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE database_name CHARACTER SET &#x3D; utf8mb4 COLLATE &#x3D; utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure>
<p>虽然修改了database的字符集为utf8mb4，但是实际只是修改了database新创建的表，默认使用utf8mb4，原来已经存在的表，字符集并没有跟着改变，需要手动为每张表设置字符集</p>
<h3 id="修改table的字符集">3.2修改table的字符集</h3>
<ul>
<li>只修改表默认的字符集
<code>ALTER TABLE table_name DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</code></li>
<li>修改表默认的字符集和所有字符列的字符集
<code>ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</code></li>
</ul>
<h3 id="单独修改column默认的字符集">3.3单独修改column默认的字符集</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name CHANGE column_name column_name VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>
<p><em>注：VARCHAR(191) 根据字段实例的类型填写</em></p>
<h3 id="关于utf8mb4外键的坑">3.4关于utf8mb4外键的坑</h3>
<p>上个学期做课程设计的时候有一些外键创建不了，根据我层层抽丝剥茧最后发现问题在于utf8mb4上，但具体是为什么我也不是很清楚。今天在该字符集的时候在一篇文章里找到了原因。</p>
<p>外键的前提是索引，当索引无法创建的时候外键自然无法创建，之前在utf8的时候<code>VARCHAR(255)</code>是可以创建外键的，但是变成了utf8mb4后255个字符超出了索引的长度的限制，必须改为<code>VARCHAR(191)</code></p>
<ul>
<li>字段长度</li>
</ul>
<p>由于从utf8升级到了utf8mb4，一个字符所占用的空间也由3个字节增长到4个字节，但是我们当初创建表时，设置的字段类型以及最大的长度没有改变。例如，你在utf8下设置某一字段的类型为<code>TINYTEXT</code>,
这中字段类型最大可以容纳255字节，三个字节一个字符的情况下可以容纳85个字符，四个字节一个字符的情况下只能容纳63个字符，如果原表中的这个字段的值有一个或多个超过了63个字符，那么转换成utf8mb4字符编码时将转换失败，你必须先将<code>TINYTEXT</code>更改为<code>TEXT</code>等更高容量的类型之后才能继续转换字符编码</p>
<ul>
<li>索引</li>
</ul>
<p>在InnoDB引擎中，最大的索引长度为767字节，三个字节一个字符的情况下，索引列的字符长度最大可以达到255，四个字节一个字符的情况下，索引的字符长度最大只能到191。如果你已经存在的表中的索引列的类型为<code>VARCHAR(255)</code>那么转换utf8mb4时同样会转换失败。你需要先将<code>VARCHAR(255)</code>更改为<code>VARCHAR(191)</code>才能继续转换字符编码</p>
<h3
id="使用python操作mysql之1064错误">3.5使用Python操作mysql之1064错误</h3>
<p>我今天使用python操作mysql的时候又出现了1064错误，之前有一次也出现了这个问题，上次发现应该是与sql语句的插入数据方式有问题，上个学期是使用的format向sql语句中插入参数的，由于上个学期的参数内容比较简单也没出什么问题，这次插入一长段带符号的文字时就出了问题，今天经过对比我才知道问题在哪。</p>
<figure class="highlight python"><figcaption><span>错误方法</span></figcaption><table><tr><td class="code"><pre><span class="line">sql3 = <span class="string">"INSERT INTO user_userInfo(nickname) VALUES('&#123;&#125;')"</span>.format(dd[<span class="number">3</span>])</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行SQL语句</span></span><br><span class="line">        cursor.execute(sql3)</span><br><span class="line">        <span class="comment"># 提交修改</span></span><br><span class="line">        db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># 发生错误时回滚</span></span><br><span class="line">        db.rollback()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><figcaption><span>正确方法</span></figcaption><table><tr><td class="code"><pre><span class="line">sql3 = <span class="string">"INSERT INTO user_userInfo(nickname) VALUES(%s)"</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行SQL语句</span></span><br><span class="line">        cursor.execute(sql3, dd[<span class="number">3</span>])</span><br><span class="line">        <span class="comment"># 提交修改</span></span><br><span class="line">        db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># 发生错误时回滚</span></span><br><span class="line">        db.rollback()</span><br></pre></td></tr></table></figure>
<p>大家可以看到这两者的区别就在于插入参数的方式，第一种方式大多数时间是没错的，但是一旦遇到dd[3]里面本来就带有一些特殊符号比如<code>/</code>,<code>'</code>之类的就会报错。而是用第二种方式则不会存在这个问题，要注意第二种方式不要在<code>%s</code>周围加<code>''</code>。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Ubuntu</tag>
        <tag>utf8mb4</tag>
      </tags>
  </entry>
  <entry>
    <title>Django学习笔记</title>
    <url>/Django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>记录Django学习笔记</p>
<p>https://www.bilibili.com/video/BV1rx411X717</p>
<a id="more"></a>
<h3 id="创建工程">创建工程</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">django-admin startproject HelloDjango</span><br></pre></td></tr></table></figure>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20200513182816.png"
alt="image-20200513182805245" />
<figcaption aria-hidden="true">image-20200513182805245</figcaption>
</figure>
<h3 id="创建应用">创建应用</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py startapp App</span><br></pre></td></tr></table></figure>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20200513182932.png"
alt="image-20200513182930988" />
<figcaption aria-hidden="true">image-20200513182930988</figcaption>
</figure>
<p>在setting.py中注册应用：</p>
<figure class="highlight diff"><figcaption><span>setting.py</span></figcaption><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    'django.contrib.admin',</span><br><span class="line">    'django.contrib.auth',</span><br><span class="line">    'django.contrib.contenttypes',</span><br><span class="line">    'django.contrib.sessions',</span><br><span class="line">    'django.contrib.messages',</span><br><span class="line">    'django.contrib.staticfiles',</span><br><span class="line"><span class="addition">+   'learn1',</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="开发者服务器">开发者服务器</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure>
<h3 id="允许访问范围">允许访问范围</h3>
<figure class="highlight python"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">ALLOWED_HOSTS = [<span class="string">"*"</span>]</span><br></pre></td></tr></table></figure>
<h3 id="语言和时区设置">语言和时区设置</h3>
<figure class="highlight python"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">LANGUAGE_CODE = <span class="string">'zh-hans'</span></span><br><span class="line"></span><br><span class="line">TIME_ZONE = <span class="string">'Asia/Shanghai'</span></span><br></pre></td></tr></table></figure>
<h3 id="迁移">迁移</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>
<h3 id="注册路由">注册路由</h3>
<figure class="highlight python"><figcaption><span>urls.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> learn1 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'hello/'</span>, views.hello),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><figcaption><span>views.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"hello Django"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="html模板">html模板</h3>
<p>两种</p>
<ul>
<li>在App中进行模板配置
<ul>
<li>只需在App的根目录创建templates文件夹即可</li>
<li>如果想让代码自动提示，我们应该标记文件夹为模板文件夹</li>
</ul></li>
<li>在项目目录中进行模板配置
<ul>
<li>需要在项目目录中创建templates文件夹并标记</li>
<li>需要在settings中进行注册</li>
</ul></li>
<li>在开发中使用第二种
<ul>
<li>模板可以继承，复用</li>
</ul></li>
</ul>
<hr />
<p>在HelloDjango中新建templates文件夹并设置为模板文件夹（方便代码提示），在其中新建html模板</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20200518175701.png"
alt="image-20200518175638301" />
<figcaption aria-hidden="true">image-20200518175638301</figcaption>
</figure>
<p>然后再settings.py中加入templates路径</p>
<figure class="highlight diff"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        'BACKEND': 'django.template.backends.django.DjangoTemplates',</span><br><span class="line">        'DIRS': [</span><br><span class="line"><span class="addition">+           os.path.join(BASE_DIR, 'templates'),</span></span><br><span class="line">        ],</span><br><span class="line">        'APP_DIRS': True,</span><br><span class="line">        'OPTIONS': &#123;</span><br><span class="line">            'context_processors': [</span><br><span class="line">                'django.template.context_processors.debug',</span><br><span class="line">                'django.template.context_processors.request',</span><br><span class="line">                'django.contrib.auth.context_processors.auth',</span><br><span class="line">                'django.contrib.messages.context_processors.messages',</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>HTML小技巧：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ul&gt;li*4(tab键)</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;今天&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;天气&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;真好&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;嘿嘿嘿&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<h3 id="分发路由">分发路由</h3>
<p>这样就可以访问ip/learn2/hello了</p>
<ul>
<li>项目如果逻辑过于复杂，可以进行拆分</li>
<li>拆分为多个App</li>
<li>继续拆分路由器 urls
<ul>
<li>在App中创建自己的urls
<ul>
<li>urlpatterns 路由规则列表</li>
<li>在根urls中进行子路由的包含</li>
</ul></li>
<li>子路由使用
<ul>
<li>根路由规则 + 子路由的规则</li>
</ul></li>
</ul></li>
</ul>
<hr />
<p>在新建的应用learn2里面新建urls.py</p>
<figure class="highlight python"><figcaption><span>learn2/urls.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> learn2 <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'hello/'</span>, views.hello),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在HelloDjango的urls.py中导入learn2中的路由</p>
<figure class="highlight diff"><figcaption><span>HelloDjango/urls.py</span></figcaption><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path('admin/', admin.site.urls),</span><br><span class="line">    path('hello/', views.hello),</span><br><span class="line">    path('index/', views.index),</span><br><span class="line"><span class="addition">+   path('learn2/', include('learn2.urls')),</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="models-使用了orm技术">models 使用了ORM技术</h3>
<ul>
<li>Object Relational Mapping 对象关系映射</li>
<li>将业务逻辑进行了一个解耦合
<ul>
<li>object.save()</li>
<li>object.delete()</li>
</ul></li>
<li>关系型数据库
<ul>
<li>DDL</li>
<li>通过models定义实现 数据库表的定义</li>
</ul></li>
<li>数据操作
<ul>
<li>增删改查</li>
<li>存储
<ul>
<li>save()</li>
</ul></li>
<li>查询
<ul>
<li>查所有 objects.all()</li>
<li>查单个 objects.get(pk=xx)</li>
</ul></li>
<li>更新
<ul>
<li>基于查询的</li>
<li>查好的对象，修改属性，然后save()</li>
</ul></li>
<li>删除
<ul>
<li>基于查询的</li>
<li>调用 delete()</li>
</ul></li>
</ul></li>
</ul>
<h3 id="快捷键">快捷键</h3>
<ul>
<li>control + p
<ul>
<li>参数提示</li>
</ul></li>
</ul>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20200608171058.png"
alt="image-20200608171048103" />
<figcaption aria-hidden="true">image-20200608171048103</figcaption>
</figure>
<ul>
<li>shift + f6 重命名，重构</li>
<li>.re 快捷生成return</li>
<li>.if 多用点看看世界的美好</li>
</ul>
<h3 id="连接mysql驱动">连接mysql驱动</h3>
<ul>
<li>mysqlclient
<ul>
<li>python2,3都能直接使用</li>
<li>致命缺点
<ul>
<li>对mysql安装有要求，必须指定位置存在配置文件</li>
</ul></li>
</ul></li>
<li>python-mysql
<ul>
<li>python2 支持很好</li>
<li>python3 不支持</li>
</ul></li>
<li>pymysql
<ul>
<li>python2，python3都支持</li>
<li>它还可以伪装成前面的库</li>
</ul></li>
</ul>
<figure class="highlight python"><figcaption><span>__init__.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">pymysql.version_info = (<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="string">'final'</span>, <span class="number">0</span>)  <span class="comment"># change mysqlclient version</span></span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>
<h3 id="重新建立-migration-文件">重新建立 migration 文件</h3>
<p>1.首先要保证,目前的migration文件和数据库是同步的，通过执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure>
<p>如果看到 这样的提示: No changes detected，则可以继续接下来的步骤</p>
<p>2.通过执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py showmigrations</span><br></pre></td></tr></table></figure>
<p>结果，可以看到当前项目，所有的app及对应的已经生效的migration文件如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git_hook</span><br><span class="line"> [X] 0001_initial</span><br><span class="line">guardian</span><br><span class="line"> [X] 0001_initial</span><br><span class="line">kombu_transport_django</span><br><span class="line"> [X] 0001_initial</span><br><span class="line">message</span><br><span class="line"> (no migrations)</span><br><span class="line">order</span><br><span class="line"> [X] 0001_initial</span><br><span class="line">pay</span><br><span class="line"> [X] 0001_initial</span><br><span class="line"> [x] 0002_add_model</span><br><span class="line">sessions</span><br><span class="line"> [X] 0001_initial</span><br></pre></td></tr></table></figure>
<p>3.通过执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py migrate –fake pay zero</span><br></pre></td></tr></table></figure>
<p>这里的 pay就是你要重置的app 4.之后再执行
<code>python manage.pu showmigrations</code>，你会发现 文件前的 [x]
变成了[ ]</p>
<p>现在，你可以删除pay 这个 app下的migrations模块中 除 init.py
之外的所有文件。</p>
<p>5.之后，执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure>
<p>程序会再次为这个app 生成 0001_initial.py 之类的文件</p>
<p>6.最重要的一步来了, 执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py migrate –fake-inital</span><br></pre></td></tr></table></figure>
<p>–fake-inital 会在数据库中的 migrations表中记录当前这个app 执行到
0001_initial.py ，但是它不会真的执行该文件中的 代码。
这样就做到了，既不对现有的数据库改动，而又可以重置 migraion
文件，妈妈再也不用在 migration模块中看到一推文件了。</p>
<h3 id="重新生成数据库中的某张表">重新生成数据库中的某张表</h3>
<p>1.删除数据库中的django_migration 表中对应的记录以及你要重新导的表</p>
<p>2.将你要导的那个app中的migrate 文件删除掉</p>
<p>3.重新导入你需要的表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py makemigration shop(你要导的app)</span><br><span class="line">python manage.py migrate shop</span><br></pre></td></tr></table></figure>
<p>这样就完成了。</p>
<h3 id="表关系">表关系</h3>
<ul>
<li><p>分类</p>
<ul>
<li><p>ForeignKey：一对多，将字段定义在多的端中</p></li>
<li><p>ManyToManyField：多对多，将字段定义在两端</p></li>
<li><p>OneToOneField：一对一，将字段定义在任意一端中</p></li>
</ul></li>
<li><p>用一访问多</p>
<ul>
<li>格式
<ul>
<li>对象.模型类小写_set</li>
</ul></li>
<li>示例
<ul>
<li>grade.students_set</li>
</ul></li>
</ul></li>
<li><p>用一访问一</p>
<ul>
<li>格式
<ul>
<li>对象.模型类小写</li>
</ul></li>
<li>示例
<ul>
<li>grade.students</li>
</ul></li>
</ul></li>
<li><p>访问id</p>
<ul>
<li>格式
<ul>
<li>对象.属性_id</li>
</ul></li>
<li>示例
<ul>
<li>student.sgrade_id</li>
</ul></li>
</ul></li>
</ul>
<h3 id="模型过滤">模型过滤</h3>
<ul>
<li>filter()：返回符合筛选条件的结果</li>
<li>exclude()：返回不符合筛选条件的结果</li>
<li>all()：返回所有数据</li>
<li>order_by('id')：排序，如果要逆序就加个<code>-</code></li>
<li>values()：一条数据就是一个字典，返回一个列表</li>
<li>连续使用
<ul>
<li>链式调用</li>
<li>Person.objects.filter().filter().xxxx.eclude().exclude().yyyy</li>
</ul></li>
</ul>
<h3 id="方法">方法</h3>
<ul>
<li><p>对象方法</p>
<ul>
<li>可以调用对象的属性，也可以调用类的属性</li>
</ul></li>
<li><p>类方法</p>
<ul>
<li>不能调用对象属性，只能调用类属性</li>
</ul>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@classmethod</span><br><span class="line">def create(cls, p_name, p_age&#x3D;100):</span><br><span class="line">	return cls(p_name&#x3D;p_name, p_age&#x3D;p_age)</span><br></pre></td></tr></table></figure></p></li>
<li><p>静态方法</p>
<ul>
<li>啥都不能调用，不能获取对象属性，也不能获取类属性</li>
<li>只是寄生在我们这个类上而已</li>
</ul></li>
</ul>
<h3 id="获取单个对象">获取单个对象</h3>
<ul>
<li>get
<ul>
<li>查询条件没有匹配的对象，会抛异常，DoesNotExist</li>
<li>如果查询条件对应多个对象，会抛异常，MultipleObjectsReturned</li>
</ul></li>
<li>first</li>
<li>last</li>
<li>count</li>
<li>exist</li>
</ul>
<h3 id="first和last">first和last</h3>
<ul>
<li>默认情况下可以正常从QuerySet中获取</li>
<li>隐藏bug
<ul>
<li>可能会出现 first和last获取到的是相同的对象
<ul>
<li>显式，手动写排序规则（先order_by）</li>
</ul></li>
</ul></li>
</ul>
<h3 id="切片">切片</h3>
<ul>
<li>和python中的切片不太一样</li>
<li>QuerySet[5:15] 获取第五条到第十五条数据
<ul>
<li>相当于SQL中limit和offset</li>
</ul></li>
</ul>
<h3 id="缓存集">缓存集</h3>
<ul>
<li>filter</li>
<li>exclude</li>
<li>all</li>
<li>都不会真正的去查询数据库</li>
<li>只有我们在迭代结果集，或者获取单个对象属性的时候，它才会去查询数据库</li>
<li>懒查询
<ul>
<li>为了优化我们结构和查询</li>
</ul></li>
</ul>
<h3 id="查询条件">查询条件</h3>
<ul>
<li>属性__运算符=值</li>
<li>gt 大于</li>
<li>lt 小于</li>
<li>gte 大于等于</li>
<li>lte 小于等于</li>
<li>in 在某一集合中</li>
<li>contains 类似于 模糊查询 like</li>
<li>startswith 以xx开始 本质也是like</li>
<li>endswith 以 xx 结束 也是like</li>
<li>exact</li>
<li>前面同时添加i , ignore 忽略
<ul>
<li>iexact</li>
<li>icontains</li>
<li>istartswith</li>
<li>iendswith</li>
</ul></li>
<li>django中查询条件有时区问题
<ul>
<li>关闭django中自定义的时区</li>
<li>在数据库中创建对应的时区表</li>
</ul></li>
</ul>
<h3 id="模型成员">模型成员</h3>
<ul>
<li>显性属性
<ul>
<li>开发者手动书写的属性</li>
</ul></li>
<li>隐性属性
<ul>
<li>开发者没有书写，ORM自动生成的</li>
<li>如果你把隐性属性手动声明了，系统就不会为你产生隐性属性了</li>
</ul></li>
</ul>
<h3 id="从mysql到model">从MySql到model</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py inspectdb &gt; backstage/models.py</span><br></pre></td></tr></table></figure>
<h3 id="sort排序">sort排序</h3>
<p>2）key参数/函数
从python2.4开始，list.sort()和sorted()函数增加了key参数来指定一个函数，此函数将在每个元素比较前被调用。
例如通过key指定的函数来忽略字符串的大小写： 代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sorted(<span class="string">"This is a test string from Andrew"</span>.split(), key=str.lower)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'Andrew'</span>, <span class="string">'from'</span>, <span class="string">'is'</span>, <span class="string">'string'</span>, <span class="string">'test'</span>, <span class="string">'This'</span>]</span><br></pre></td></tr></table></figure>
<p>key参数的值为一个函数，此函数只有一个参数且返回一个值用来进行比较。这个技术是快速的因为key指定的函数将准确地对每个元素调用。</p>
<p>更广泛的使用情况是用复杂对象的某些值来对复杂对象的序列排序，例如：</p>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student_tuples = [</span><br><span class="line">(<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>),</span><br><span class="line">(<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>),</span><br><span class="line">(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>),</span><br><span class="line">]</span><br><span class="line">sorted(student_tuples, key=<span class="keyword">lambda</span> student: student[<span class="number">2</span>])   <span class="comment"># sort by age</span></span><br><span class="line">[(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="paginator分页">Paginator分页</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.paginator <span class="keyword">import</span> Paginator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行分页</span></span><br><span class="line">pagenator = Paginator(result_list, limit)</span><br><span class="line">result = pagenator.page(page).object_list</span><br></pre></td></tr></table></figure>
<h3 id="pop间接修改键的key值">pop()间接修改键的key值</h3>
<p>pop()一般用作删除列表中元素，但是它的返回值很有趣</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pop(key[,default])</span><br></pre></td></tr></table></figure>
<ul>
<li>key: 要删除的键/值对所对应的键</li>
<li>default:
可选参数，给定键不在字典中时必须设置，否者会报错(没有默认值)，此时返回default值，</li>
</ul>
<p>Python 字典 pop()
方法删除给定键所对应的键/值对，并返回被删除的值。给定键如果不在字典中，则必须设置一个default值，否则会报错，此时返回的就是default值。</p>
<h3 id="model_to_dict单个对象转字典">model_to_dict()单个对象转字典</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.forms import model_to_dict</span><br><span class="line"></span><br><span class="line">result &#x3D; UserUserinfo.objects.filter(nickname__contains&#x3D;key).first()</span><br><span class="line">result &#x3D; model_to_dict(result)</span><br></pre></td></tr></table></figure>
<h3 id="取日期区间">取日期区间</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> dateutil.relativedelta <span class="keyword">import</span> relativedelta</span><br><span class="line"></span><br><span class="line">now_date = datetime.datetime.now().date()</span><br><span class="line">dates = &#123;</span><br><span class="line">    <span class="string">'1'</span>: now_date - datetime.timedelta(days=<span class="number">1</span>),  <span class="comment"># 近一天</span></span><br><span class="line">    <span class="string">'2'</span>: now_date - datetime.timedelta(weeks=<span class="number">1</span>),  <span class="comment"># 近一周</span></span><br><span class="line">    <span class="string">'3'</span>: now_date - relativedelta(months=<span class="number">1</span>)  <span class="comment"># 近一月</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parameter_time = dates.get(<span class="string">'%s'</span> % time)</span><br><span class="line">obj_list = Customer.objects.filter(deal_date__gte=parameter_time, deal_date__lte=cur_date)</span><br></pre></td></tr></table></figure>
<h3
id="django中通过model名字获取model">django中通过model名字获取model</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from django.apps import apps</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; apps.get_app_config(<span class="string">'auth'</span>) </span></span><br><span class="line">&lt;AuthConfig: auth&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意得到的结果是迭代器(iterator)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; auth = apps.get_app_config(<span class="string">'auth'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; auth.get_models()</span></span><br><span class="line">&lt;generator object get_models at 0x31422d0&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> auth.get_models():</span></span><br><span class="line">...  print i</span><br><span class="line">... </span><br><span class="line">&lt;class 'django.contrib.auth.models.Permission'&gt;</span><br><span class="line">&lt;class 'django.contrib.auth.models.Group'&gt;</span><br><span class="line">&lt;class 'django.contrib.auth.models.User'&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; auth.get_model(<span class="string">'User'</span>)         </span></span><br><span class="line">&lt;class 'django.contrib.auth.models.User'&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; User = auth.get_model(<span class="string">'User'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; User.objects.all()[0]</span></span><br><span class="line">&lt;User: root&gt;</span><br></pre></td></tr></table></figure>
<h3 id="时间类型">时间类型</h3>
<ol type="1">
<li><p>default=datetime.now()</p>
<p>model每次初始化，都会自动设置该字段的默认值为初始化时间。</p></li>
<li><p>default=datetime.now</p>
<p>model每次进行新增或修改操作，都会自动设置该字段的值为操作时间。设置后仍可以使用ORM手动修改该字段。</p></li>
<li><p>auto_now_add=True</p>
<p>默认值为False，若设置为True，model每次进行新增操作，都会自动设置该字段的值为操作时间。设置为True后无法使用ORM手动修改该字段，哪怕填充了字段的值也会被覆盖。</p></li>
<li><p>auto_now=True</p>
<p>默认值为False，若设置为True，model每次进行新增或修改操作，都会自动设置该字段的值为操作时间。设置为True后无法使用ORM手动修改该字段，哪怕填充了字段的值也会被覆盖。</p></li>
<li><p>要注意的点</p>
<p>除非想设置动态默认时间为项目的启动时间，否则default=datetime.now()这种用法是错误的，会得到期望之外的结果。</p>
<p>使用User.objects.update方法时，设置的default=datetime.now和auto_now=True都不会生效，由于设置了auto_now=True的字段不能手动修改，此时只能使用save方法修改数据，这对于多个数据的更新是不友好的。</p>
<p>因此如果设置动态默认时间的字段，应该使用default=datetime.now和auto_now_add=True来实现。</p></li>
</ol>
<h3 id="djang获取models字段方法">djang获取models字段方法</h3>
<p>通过._meta.fields获取 以Student这个model为例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">In [59]: Student._meta.fields</span><br><span class="line">Out[59]: </span><br><span class="line">(&lt;django.db.models.fields.AutoField: id&gt;,</span><br><span class="line"> &lt;django.db.models.fields.CharField: stu_name&gt;,</span><br><span class="line"> &lt;django.db.models.fields.CharField: stu_no&gt;,</span><br><span class="line"> &lt;django.db.models.fields.CharField: stu_sex&gt;,</span><br><span class="line"> &lt;django.db.models.fields.IntegerField: stu_age&gt;,</span><br><span class="line"> &lt;django.db.models.fields.DateTimeField: stu_birth&gt;)</span><br></pre></td></tr></table></figure>
<p>获取字段名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">In [62]: stu = Student._meta.fields </span><br><span class="line">In [62]: [stu[i].name for i in range(len(stu))]</span><br><span class="line">Out[62]: [u'id', 'stu_name', 'stu_no', 'stu_sex', 'stu_age', 'stu_birth']</span><br></pre></td></tr></table></figure>
<h3 id="修改数据库中部分信息">修改数据库中部分信息</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_work</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = simplejson.loads(request.body)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">"code"</span>: <span class="number">-1</span>, <span class="string">"msg"</span>: <span class="string">'参数接受失败'</span>&#125;)</span><br><span class="line">    print(data)</span><br><span class="line">    DataModel = firsttypeid_to_model(data[<span class="string">'firsttypeid'</span>]).objects.create()</span><br><span class="line">    <span class="comment"># 获取该模型内所有字段名数据</span></span><br><span class="line">    fields_data = DataModel._meta.fields</span><br><span class="line">    <span class="comment"># 这里是将当前的model转换成数据字典，方便后面修改后提交</span></span><br><span class="line">    data_dict = DataModel.__dict__</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> fields_data:</span><br><span class="line">            <span class="comment"># 这样或输出这条记录的所有字段名，需要的话还可以输出verbose_name</span></span><br><span class="line">            <span class="keyword">if</span> field.name == key:</span><br><span class="line">                <span class="comment"># 进行匹配，将前端传来的字段匹配到，然后修改数据库里面的数据</span></span><br><span class="line">                <span class="keyword">if</span> data[key] == <span class="string">''</span>:</span><br><span class="line">                    data_dict[key] = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    data_dict[key] = data[key]</span><br><span class="line">    data_dict[<span class="string">'secondtypeid_id'</span>] = data[<span class="string">'secondtypeid'</span>]</span><br><span class="line">    <span class="comment"># 保存数据到数据库，这样的好处就是提高效率，避免过多重复操作</span></span><br><span class="line">    DataModel.save()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">"code"</span>: <span class="number">1</span>, <span class="string">"msg"</span>: <span class="string">'成功'</span>&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="外键不能直接插入">外键不能直接插入</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">publisher = UserAdmin.objects.get(id=publisherid)</span><br><span class="line">    obj = UserNotice.objects.create(noticetitle=title, noticecontent=content, publisherid=publisher)</span><br></pre></td></tr></table></figure>
<h3 id="去重查询">去重查询</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">works = MainDataTougaolanmu.objects.all().values(<span class="string">'userid_id'</span>).distinct()</span><br></pre></td></tr></table></figure>
<h3 id="解决跨域">解决跨域</h3>
<p>在整个项目的setting.py中进行修改</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    'django.contrib.admin',</span><br><span class="line">    'django.contrib.auth',</span><br><span class="line">    'django.contrib.contenttypes',</span><br><span class="line">    'django.contrib.sessions',</span><br><span class="line">    'django.contrib.messages',</span><br><span class="line">    'django.contrib.staticfiles',</span><br><span class="line"><span class="addition">+   'corsheaders',  # 跨域</span></span><br><span class="line">    'learn1',</span><br><span class="line">    'backstage',</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    'django.middleware.security.SecurityMiddleware',</span><br><span class="line">    'django.contrib.sessions.middleware.SessionMiddleware',</span><br><span class="line"><span class="addition">+   'corsheaders.middleware.CorsMiddleware',  # 解决跨域</span></span><br><span class="line">    'django.middleware.common.CommonMiddleware',</span><br><span class="line">    'django.middleware.csrf.CsrfViewMiddleware',</span><br><span class="line">    'django.contrib.auth.middleware.AuthenticationMiddleware',</span><br><span class="line">    'django.contrib.messages.middleware.MessageMiddleware',</span><br><span class="line">    'django.middleware.clickjacking.XFrameOptionsMiddleware',</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 跨域增加忽略</span></span><br><span class="line">CORS_ALLOW_CREDENTIALS = <span class="literal">True</span></span><br><span class="line">CORS_ORIGIN_ALLOW_ALL = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">CORS_ALLOW_METHODS = (</span><br><span class="line">    <span class="string">'DELETE'</span>,</span><br><span class="line">    <span class="string">'GET'</span>,</span><br><span class="line">    <span class="string">'OPTIONS'</span>,</span><br><span class="line">    <span class="string">'PATCH'</span>,</span><br><span class="line">    <span class="string">'POST'</span>,</span><br><span class="line">    <span class="string">'PUT'</span>,</span><br><span class="line">    <span class="string">'VIEW'</span>,</span><br><span class="line">)</span><br><span class="line">CORS_ALLOW_HEADERS = (</span><br><span class="line">    <span class="string">'XMLHttpRequest'</span>,</span><br><span class="line">    <span class="string">'X_FILENAME'</span>,</span><br><span class="line">    <span class="string">'accept-encoding'</span>,</span><br><span class="line">    <span class="string">'authorization'</span>,</span><br><span class="line">    <span class="string">'content-type'</span>,</span><br><span class="line">    <span class="string">'dnt'</span>,</span><br><span class="line">    <span class="string">'origin'</span>,</span><br><span class="line">    <span class="string">'user-agent'</span>,</span><br><span class="line">    <span class="string">'x-csrftoken'</span>,</span><br><span class="line">    <span class="string">'x-requested-with'</span>,</span><br><span class="line">    <span class="string">'token'</span>,    <span class="comment"># token</span></span><br><span class="line">    <span class="string">'authentication'</span>,   <span class="comment"># token</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>pycharm远程调试项目</title>
    <url>/pycharm%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>服务器上没有IDE，编写代码很不方便，所以我选择在本地用pycharm远程调试程序，但是我没有选择在本地pycharm使用ssh连接Terminal，因为真的太卡了，我还是用xshell作为命令行使用。</p>
<p>参考：https://www.cnblogs.com/weihengblog/p/9656257.html</p>
<a id="more"></a>
<p>pycharm是一个非常强大的python开发工具，现在很多代码最终在线上跑的环境都是linux，而开发环境可能还是windows下开发，这就需要经常在linux上进行调试，或者在linux对代码进行编写，而pycharm提供了非常便捷的方式。具体实现在windows上远程linux开发和调试的代码步骤如下：</p>
<ol type="1">
<li><p>本地和远程同步</p></li>
<li><p>配置Project Interpreter（使用远程的Python解释器）</p></li>
<li><p>设置Terminal运行的Python版本</p></li>
<li><p>使用Terminal登陆到Linux服务器</p></li>
</ol>
<h3 id="一本地和远程代码同步">一、本地和远程代码同步</h3>
<p>首先，在本地和远程拥有相同的项目代码：</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012105507.png"
alt="1321568-20180916144244833-1490970117" />
<figcaption
aria-hidden="true">1321568-20180916144244833-1490970117</figcaption>
</figure>
<p><strong>在windows平台使用Pycharm打开项目,然后：Tools -&gt; Deployment
-&gt; configuration，然后新建远程服务器</strong></p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012105650.png"
alt="1321568-20180916144731393-549531962" />
<figcaption
aria-hidden="true">1321568-20180916144731393-549531962</figcaption>
</figure>
<p><strong>然后进行服务器配置</strong></p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012105658.png"
alt="1321568-20180916145358775-782073356" />
<figcaption
aria-hidden="true">1321568-20180916145358775-782073356</figcaption>
</figure>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012105705.png"
alt="1321568-20180916145549234-784619187" />
<figcaption
aria-hidden="true">1321568-20180916145549234-784619187</figcaption>
</figure>
<p><strong>点击Ok</strong>，<strong>经过上面步骤的配置后，我们可以在PyCharm
界面的右边查看远端代码，如下图：</strong></p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012105836.png"
alt="1321568-20180916145725516-1886186686" />
<figcaption
aria-hidden="true">1321568-20180916145725516-1886186686</figcaption>
</figure>
<p><strong>切记！勾选 Automatic Upload
实现本地自动同步到远端</strong></p>
<h3 id="二配置project-interpreter使用远程的python解释器">二、配置Project
Interpreter（使用远程的Python解释器）</h3>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012105842.png"
alt="1321568-20180916145905889-619698935" />
<figcaption
aria-hidden="true">1321568-20180916145905889-619698935</figcaption>
</figure>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012105846.png"
alt="1321568-20180916150051936-1448125681" />
<figcaption
aria-hidden="true">1321568-20180916150051936-1448125681</figcaption>
</figure>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012105852.png"
alt="1321568-20180916150149777-1149968755" />
<figcaption
aria-hidden="true">1321568-20180916150149777-1149968755</figcaption>
</figure>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012105900.png"
alt="1321568-20180916150602788-417269814" />
<figcaption
aria-hidden="true">1321568-20180916150602788-417269814</figcaption>
</figure>
<p><strong>点击 OK 保存，点击Finish完成。然后在编辑新添加的Python
Interpreter，如下图所示：</strong></p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012110011.png"
alt="1321568-20180916151536382-1761728586" />
<figcaption
aria-hidden="true">1321568-20180916151536382-1761728586</figcaption>
</figure>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012110017.png"
alt="1321568-20180916151652947-1922094213" />
<figcaption
aria-hidden="true">1321568-20180916151652947-1922094213</figcaption>
</figure>
<p><strong>这样，本地和远程的项目
以来的pip都是相同的，解释器也是相同的。</strong></p>
<h3
id="三设置terminal运行的python版本">三、设置Terminal运行的Python版本</h3>
<p><strong>File -&gt; Settings -&gt; Tools -&gt; SSH Terminal，在
Deployment server
选择Linux服务器的Python版本路径。（配置已经存在，只要选择即可）</strong></p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012110030.png"
alt="1321568-20180916151811986-1349908586" />
<figcaption
aria-hidden="true">1321568-20180916151811986-1349908586</figcaption>
</figure>
<h3
id="四使用terminal登陆到linux服务器">四、使用Terminal登陆到Linux服务器</h3>
<p><strong>选择 Tools -&gt; Start SSH session，默认会开启Linux
ssh会话窗口，如下图：</strong></p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012110034.png"
alt="1321568-20180916151852453-923493946" />
<figcaption
aria-hidden="true">1321568-20180916151852453-923493946</figcaption>
</figure>
<p><strong>就可以执行Linux命令了，在远程Linux主机上，如下图：</strong></p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012110042.png"
alt="1321568-20180916152101674-143914985" />
<figcaption
aria-hidden="true">1321568-20180916152101674-143914985</figcaption>
</figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>python中==和is的区别</title>
    <url>/python%E4%B8%AD-%E5%92%8Cis%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>常见的一种理解是==判断值相等，is判断内存中是否指向同一个位置，但其实这个和python的交互模式，py文件模式都有点关系，这里简单总结一下网上搜罗的内容。</p>
<a id="more"></a>
<h3 id="问题出现">问题出现</h3>
<p>在py文件中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">"hello"</span></span><br><span class="line">b = <span class="string">"hello"</span></span><br><span class="line">print(a <span class="keyword">is</span> b)  <span class="comment"># 输出 True </span></span><br><span class="line">print(a == b)  <span class="comment"># 输出 True</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(a <span class="keyword">is</span> b)  <span class="comment"># 输出 False</span></span><br><span class="line">print(a == b)  <span class="comment"># 输出 True </span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">print(a <span class="keyword">is</span> b)  <span class="comment"># 输出 True </span></span><br><span class="line">print(a == b)  <span class="comment"># 输出 True</span></span><br></pre></td></tr></table></figure>
<p>官方文档中说 is 表示的是对象标示符（object identity），而 ==
表示的是相等（equality）。is
的作用是用来检查对象的标示符是否一致，也就是比较两个对象在内存中的地址是否一样，而
== 是用来检查两个对象是否相等。</p>
<p>我们在检查 a is b 的时候，其实相当于检查 id(a) == id(b)。而检查 a ==
b 的时候，实际是调用了对象 a 的 <code>__eq()__</code>方法，a == b 相当于
<code>a.__eq__(b)</code>。</p>
<p>一般情况下，如果 a is b 返回True的话，即 a 和 b
指向同一块内存地址的话，a == b 也返回True，即 a 和 b 的值也相等。</p>
<p>接下来再看下面的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">"hello"</span></span><br><span class="line">b = <span class="string">"hello"</span></span><br><span class="line">print(a <span class="keyword">is</span> b)  <span class="comment"># 输出 True </span></span><br><span class="line">print(a == b)  <span class="comment"># 输出 True</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">"hello world"</span></span><br><span class="line">b = <span class="string">"hello world"</span></span><br><span class="line">print(a <span class="keyword">is</span> b)  <span class="comment"># 输出 False</span></span><br><span class="line">print(a == b)  <span class="comment"># 输出 True</span></span><br></pre></td></tr></table></figure>
<p>这里我们又发现hello使用is判断为True，但hello
world判断为False。这就和python中的小整数对象池和大整数对象池和intern机制有关系了。</p>
<h3 id="小整数对象池">小整数对象池</h3>
<p>python解释器为了提升运行速度使用了小整数对象池，来避免为整数频繁定义与销毁内存空间。</p>
<p>小整数对象池定义的范围<strong>[-5,256]</strong>在这个范围的整数对象都是提前创建好的，不会被垃圾回收机制以内存垃圾回收，在这个范围内的整数使用的都是同一个对象(引用
id内存地址值相同)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a=-5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b=-5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a is b</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a=256</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b=256</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a is b</span></span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<h3 id="大整数对象池">大整数对象池</h3>
<p>大整数对象池是在上述范围之外</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a=-6</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b=-6</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a is b</span></span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a=257</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b=257</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a is b</span></span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<h3 id="intern机制">intern机制</h3>
<p>如果两个或以上的字符串变量它们的值相同且仅由数字字母下划线组成并且长度不超过20个字符，或者值仅含有一个字符时，内存空间中只创建一个对象来让这些变量都指向该内存地址（共享引用），当字符串不满足该条件时，相同值的字符串变量在创建时都会申请一个新的内存地址来保存值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 单个字符或者为空以及空格的字符串，是同一个对象，共享引用</span></span><br><span class="line"></span><br><span class="line">// 两个相同的单字符</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = <span class="string">'a'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = <span class="string">'a'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; id(a), id(b)</span></span><br><span class="line">(140478486488208, 140478486488208)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a is b</span></span><br><span class="line">True</span><br><span class="line">// 两个相同的空字符串</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = <span class="string">''</span> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = <span class="string">''</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; id(a), id(b)</span></span><br><span class="line">(140377617439408, 140377617439408)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a is b</span></span><br><span class="line">True</span><br><span class="line">// 两个相同空格的字符串</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = <span class="string">' '</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = <span class="string">' '</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; id(a), id(b)</span></span><br><span class="line">(140377616103608, 140377616103608)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a is b</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">#</span><span class="bash"> 两个相同值的字符串，是同一个对象，共享引用</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = <span class="string">'liunx'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = <span class="string">'liunx'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; id(a), id(b)</span></span><br><span class="line">(140478486363976, 140478486363976)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a is b</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">#</span><span class="bash"> 两个相同值但长度不超过20位的字符串，是同一个对象，共享引用</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = <span class="string">'linux'</span> * 4</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = <span class="string">'linux'</span> * 4</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; id(a), id(b)</span></span><br><span class="line">(140478486391736, 140478486391736)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a is b</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">#</span><span class="bash"> 两个相同值但长度超过20位的字符串，不是同一个对象</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = <span class="string">'linux'</span> * 5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = <span class="string">'linux'</span> * 5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; id(a), id(b)</span></span><br><span class="line">(140478486354640, 140478486355280)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a is b</span></span><br><span class="line">False</span><br><span class="line"><span class="meta">#</span><span class="bash"> 两个相同值但包含特殊字符串(非大小写字母和数字或下划线)的，不是同一个对象</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = <span class="string">'**'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = <span class="string">'**'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a is b</span></span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = <span class="string">'_-'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = <span class="string">'_-'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a is b</span></span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = <span class="string">'a*c'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = <span class="string">'a*c'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a is b</span></span><br><span class="line">False</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = <span class="string">'lin ux'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = <span class="string">'lin ux'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; id(a), id(b)</span></span><br><span class="line">(140478486364088, 140478485729384)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a is b</span></span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>以上是在交互模式下的结果，但是在pycharm中运行如下代码得到的结果会是True</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="string">"hello world"</span></span><br><span class="line">d = <span class="string">"hello world"</span></span><br><span class="line">print(c == d)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">print(c <span class="keyword">is</span> d)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>说明在交互模式下和在文件py中也还是存在区别，或者也可能是pycharm这个IDE引起的。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>lxml相关操作</title>
    <url>/lxml%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>scrapy作为爬虫框架还是比较全能的，但是我之前遇到过一个问题就是要将一个节点的某些子节点删除，这个操作好像scrapy的selector好像不能实现，也有可能是我自己没找到方法。我的解决方法是直接将response的内容构建成lxml然后再进行节点删除和信息提取。</p>
<a id="more"></a>
<h2 id="如何构建对象">1.如何构建对象</h2>
<p>首先我们要引入lxml（html也是lxml的一种）包，然后调用<code>etree.HTML()</code>函数解析html来构建Element</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">element = etree.HTML(response.text).xpath(<span class="string">'//div[@class="con_main"]'</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="去除特定节点">2.去除特定节点</h2>
<p>构建完对象后，我们选择<code>find</code>,<code>findall</code>,<code>getchildren</code>等方法选定想要剔除的节点，然后再调用<code>remove</code>函数将其去掉，Element还有很多的方法我也没有全部用过，如果有需要可以参见<a
href="https://lxml.de/api/lxml.etree._Element-class.html">lxml官方文档</a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> pp <span class="keyword">in</span> element.findall(<span class="string">'p[@style]'</span>):</span><br><span class="line">    element.remove(pp)</span><br></pre></td></tr></table></figure>
<h2 id="完成信息提取">3.完成信息提取</h2>
<p>之后就是正常的完成对所需信息的处理，去毛刺，格式化，列表化等操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">content = element.xpath(<span class="string">'string(.)'</span>).replace(<span class="string">'\xa0'</span>, <span class="string">''</span>).replace(<span class="string">'a("conten");'</span>, <span class="string">''</span>).split(<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment"># 这一句是去除列表中的空元素</span></span><br><span class="line">item[<span class="string">'content'</span>] = [i <span class="keyword">for</span> i <span class="keyword">in</span> content <span class="keyword">if</span> i != <span class="string">''</span>]</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>虽然<code>Element</code>和scrapy的<code>selector</code>都可以是调用<code>xpath</code>方法形式上也很类似但是<code>Element</code>对象<code>xpath('string(.)')</code>之后是不用<code>extract_first()</code>的</li>
</ul>
<h2 id="extract和extract_first">4.extract（）和extract_first（）</h2>
<p>如果您是Scrapy的长期用户，则可能熟悉<code>.extract()</code>和<code>.extract_first()</code>选择器方法。许多博客文章和教程也正在使用它们。Scrapy仍支持这些方法，<strong>没有计划</strong>弃用它们。</p>
<p>但是，Scrapy用法文档现在使用<code>.get()</code>和
<code>.getall()</code>方法编写。我们认为这些新方法可以使代码更简洁易读。</p>
<p>以下示例显示了这些方法如何相互映射：</p>
<ol type="1">
<li><p><code>SelectorList.get()</code>与<code>SelectorList.extract_first()</code>：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; response.css(<span class="string">'a::attr(href)'</span>).get()</span></span><br><span class="line">'image1.html'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; response.css(<span class="string">'a::attr(href)'</span>).extract_first()</span></span><br><span class="line">'image1.html'</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>SelectorList.getall()</code>与<code>SelectorList.extract()</code>：</p></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; response.css(<span class="string">'a::attr(href)'</span>).getall()</span></span><br><span class="line">['image1.html', 'image2.html', 'image3.html', 'image4.html', 'image5.html']</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; response.css(<span class="string">'a::attr(href)'</span>).extract()</span></span><br><span class="line">['image1.html', 'image2.html', 'image3.html', 'image4.html', 'image5.html']</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><code>Selector.get()</code>与<code>Selector.extract()</code>：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; response.css(<span class="string">'a::attr(href)'</span>)[0].get()</span></span><br><span class="line">'image1.html'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; response.css(<span class="string">'a::attr(href)'</span>)[0].extract()</span></span><br><span class="line">'image1.html'</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>为了保持一致性，还有<code>Selector.getall()</code>，它返回一个列表：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; response.css(<span class="string">'a::attr(href)'</span>)[0].getall()</span></span><br><span class="line">['image1.html']</span><br></pre></td></tr></table></figure>
<p>因此，主要区别在于<code>.get()</code>和<code>.getall()</code>方法的输出更可预测：<code>.get()</code>始终返回单个结果，<code>.getall()</code>
始终返回所有提取结果的列表。使用<code>.extract()</code>method时，结果是否为列表并不总是很明显；得到一个结果<code>.extract()</code>或者<code>.extract_first()</code>应该被调用。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>信息提取</tag>
      </tags>
  </entry>
  <entry>
    <title>python操作redis大全</title>
    <url>/python%E6%93%8D%E4%BD%9Credis%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p>redis是一个很常见的键值对数据库，用途广泛，我现在主要是在实现增量爬虫的时候使用了redis中的hashes类型，这里记录一些redis的相关操作。</p>
<a id="more"></a>
<h3 id="一字符串-strings">一、字符串 strings</h3>
<p>Python操作Redis的redis模块对字符串（string）的主要操作函数包括：SET、GET、GETSET、SETEX、SETNX、MSET、MSETNX、INCR(INCRBY,DECR,DECRBY在python中庸同一个函数incr实现)、APPEND、SETRANGE、STRLEN。函数说明如下：</p>
<ol type="1">
<li><strong>SET</strong>： 为指定的键（key）设置值（value）， set(self,
name, value, **kwargs)。</li>
<li><strong>GET</strong>：获取指定键（key）绑定的值（value），get(self,
name)。</li>
<li><strong>GETSET</strong>：为指定的键（key）设置新的值（value），并返回旧的值（old
Value），getset(self, name, value)</li>
<li><strong>SETEX</strong>：为指定的键（key）设置过期以秒（second）计的过期时间，setex(self,
name, value, time)</li>
<li><strong>SETNX</strong>：键（key）不存在时，为键（key）指定值（value），setnx(self,
name, value)</li>
<li><strong>MSET</strong>：一次性设置多个键-值(key-value)对,函数设置的键-值对（即mapping所指内容）数据要以Python字典数据类型传入，mset(self,
mapping)</li>
<li><strong>MSETNX</strong>：键-值(key-value)对不存在时，设置键-值（key-value）对,msetnx(self,
mapping)，mapping值参考6</li>
<li><strong>INCR</strong>：自增函数，默认步长为1，通过对步长（amount）大小以及字符的控制实现了INCRBY（amount&gt;=1）、DECR（amount=-1）、DECRBY（amount&lt;=-1）等函数功能，incr(self,
name, amount=1)</li>
<li><strong>APPEND</strong>：为指定的字符串追加值，若不存在则直接创建，append(self,
key, value)</li>
<li><strong>SETRANGE</strong>：用 value 参数覆写给定 key
所储存的字符串值，从偏移量 offset 开始，setrange(self, name, offset,
value)</li>
<li><strong>STRLEN</strong>：返回字符串的长度，当name不存在时返回0，strlen(self,
name)</li>
</ol>
<p>示例代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># __author__ = 'free'</span></span><br><span class="line"></span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line"></span><br><span class="line">r.flushall() <span class="comment"># 清空Redis</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.setex(<span class="string">'name'</span>, value=<span class="string">'natasha'</span>, time=<span class="number">2</span>) <span class="comment"># 设置新值，过期时间为3s</span></span><br><span class="line">r.mset(k1 = <span class="string">'v1'</span>, k2 = <span class="string">'v2'</span>, k3 = <span class="string">'v3'</span>) <span class="comment"># 批量设置新值</span></span><br><span class="line">print(r.mget(<span class="string">'k1'</span>, <span class="string">'k2'</span>, <span class="string">'k3'</span>, <span class="string">'k4'</span>)) <span class="comment"># 批量获取新值</span></span><br><span class="line">print(r.getset(<span class="string">'name'</span>, <span class="string">'natasha'</span>)) <span class="comment"># 设置新值并获取原来的值</span></span><br><span class="line">print(r.getrange(<span class="string">'name'</span>, <span class="number">0</span>, <span class="number">1</span>)) <span class="comment"># 获取子序列 0 &lt;= x &lt;= 1</span></span><br><span class="line">r.setrange(<span class="string">'name'</span>, <span class="number">0</span>, <span class="string">'NATASHA'</span>) <span class="comment"># 修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加），返回值的长度</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">2</span>:</span><br><span class="line">    print(r.get(<span class="string">'name'</span>))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    source = <span class="string">'foo'</span></span><br><span class="line">    r.set(<span class="string">'n1'</span>, source)</span><br><span class="line">    r.setbit(<span class="string">'n1'</span>, <span class="number">7</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">注：如果在Redis中有一个对应： n1 = "foo"，</span></span><br><span class="line"><span class="string">那么字符串foo的二进制表示为：01100110 01101111 01101111</span></span><br><span class="line"><span class="string">所以，如果执行 setbit('n1', 7, 1)，则就会将第7位设置为1，</span></span><br><span class="line"><span class="string">那么最终二进制则变成 01100111 01101111 01101111，即："goo"</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">print(r.get(<span class="string">'n1'</span>))</span><br><span class="line">print(r.getbit(<span class="string">'n1'</span>, <span class="number">7</span>)) <span class="comment"># 获取n1对应的值的二进制表示中的某位的值 （0或1）</span></span><br><span class="line">r.set(<span class="string">'n2'</span>, <span class="string">'娜塔莎'</span>)</span><br><span class="line">print(r.strlen(<span class="string">'n2'</span>)) <span class="comment"># 返回对应的字节长度（一个汉字3个字节）</span></span><br><span class="line">r.set(<span class="string">'num'</span>, <span class="number">1</span>)</span><br><span class="line">r.incr(<span class="string">'num'</span>, amount=<span class="number">10</span>)</span><br><span class="line">r.decr(<span class="string">'num'</span>, amount=<span class="number">1</span>)</span><br><span class="line">print(r.get(<span class="string">'num'</span>)) <span class="comment"># 自增num对应的值，当name不存在时，则创建name＝amount，否则，则自增。</span></span><br><span class="line">r.append(<span class="string">'num'</span>, <span class="number">111</span>)</span><br><span class="line">print(r.get(<span class="string">'num'</span>)) <span class="comment"># 在redis num对应的值后面追加内容</span></span><br></pre></td></tr></table></figure></p>
<p>输出结果如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">b'v1'</span>, <span class="string">b'v2'</span>, <span class="string">b'v3'</span>, <span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">b'natasha'</span></span><br><span class="line"></span><br><span class="line"><span class="string">b'goo'</span></span><br><span class="line"></span><br><span class="line"><span class="string">b'NAtasha'</span></span><br><span class="line"></span><br><span class="line"><span class="string">b'NAtasha'</span></span><br><span class="line"></span><br><span class="line"><span class="string">b'NAtasha'</span></span><br><span class="line"></span><br><span class="line"><span class="string">b'NAtasha'</span></span><br><span class="line"></span><br><span class="line"><span class="string">b'goo'</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="string">b'10'</span></span><br><span class="line"></span><br><span class="line"><span class="string">b'10111'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="二列表-lists">二、列表 lists</h3>
<p>Python操作Redis主要利用了redis模块来实现，list表操作函数主要模拟了Redis操作命令LPUSH，LRANGE，LINDEX，BLPOP，BRPOP。函数说明如下：</p>
<ol type="1">
<li><strong>lpush</strong>函数实现了从向指定redis列表头部压入数据功能，lpush
key value</li>
<li><strong>lrange</strong>获取列表指定范围的函数，lrange key start
end</li>
<li><strong>lindex</strong>根据列表下标量获取列表元素值， lindex key
index</li>
<li><strong>blpop</strong>从列表头部取出第一个元素，返回该元素值并从列表删除（l代表left，左边）</li>
<li><strong>brpop</strong>从列表尾部取出第一个元素，返回该元素值并从列表删除（r代表right，右边）</li>
<li><strong>LPUSHX、RPUSHX</strong>以及其他一些Redis列表（List）函数目前版本无法实现，如有可实现方法博客代码事例将会得到更新。</li>
</ol>
<p>示例代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># __author__ = 'free'</span></span><br><span class="line"></span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line"></span><br><span class="line">r.flushall() <span class="comment"># 清空Redis</span></span><br><span class="line"></span><br><span class="line">r.lpush(<span class="string">'oo'</span>, <span class="number">11</span>) <span class="comment"># 保存顺序为: 33,22,11</span></span><br><span class="line">r.lpushx(<span class="string">'oo'</span>, <span class="number">00</span>) <span class="comment"># 在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边</span></span><br><span class="line">print(r.llen(<span class="string">'oo'</span>)) <span class="comment"># name对应的list元素的个数</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">r.linsert(<span class="string">'oo'</span>, <span class="string">'before'</span>, <span class="number">11</span>, <span class="number">99</span>) <span class="comment"># 在11之前插入值99</span></span><br><span class="line">r.lset(<span class="string">'oo'</span>, <span class="number">1</span>, <span class="number">88</span>) <span class="comment"># 对name对应的list中的某一个索引位置重新赋值</span></span><br><span class="line">print(r.lrange(<span class="string">'oo'</span>, <span class="number">0</span>, <span class="number">-1</span>)) <span class="comment"># 在name对应的列表分片获取数据</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">r.lrem(<span class="string">'oo'</span>, <span class="number">88</span>, num=<span class="number">1</span>) <span class="comment"># 在name对应的list中删除指定的值.num=0，删除列表中所有的指定值；num=2,从前到后，删除2个；num=-2,从后向前，删除2个</span></span><br><span class="line">print(r.lrange(<span class="string">'oo'</span>, <span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">print(r.lpop(<span class="string">'oo'</span>)) <span class="comment"># 在name对应的列表的左侧获取第一个元素并在列表中移除，返回值则是第一个元素</span></span><br><span class="line">print(r.lindex(<span class="string">'oo'</span>, <span class="number">0</span>)) <span class="comment"># 在name对应的列表中根据索引获取列表元素</span></span><br><span class="line">r.lpush(<span class="string">'l1'</span>, <span class="number">11</span>) <span class="comment"># index为0</span></span><br><span class="line">r.rpush(<span class="string">'l1'</span>, <span class="number">22</span>)</span><br><span class="line">r.rpush(<span class="string">'l1'</span>, <span class="number">33</span>)</span><br><span class="line">r.rpush(<span class="string">'l1'</span>, <span class="number">44</span>)</span><br><span class="line">r.rpush(<span class="string">'l1'</span>, <span class="number">55</span>) <span class="comment"># index为4</span></span><br><span class="line">r.ltrim(<span class="string">'l1'</span>, <span class="number">1</span>, <span class="number">3</span>) <span class="comment"># 在name对应的列表中移除没有在[start-end]索引之间的值</span></span><br><span class="line">print(r.lrange(<span class="string">'l1'</span>, <span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">r.rpoplpush(<span class="string">'l1'</span>, <span class="string">'l1'</span>) <span class="comment"># 从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边;src要取数据的列表的name, dst要添加数据的列表的name</span></span><br><span class="line">print(r.lrange(<span class="string">'l1'</span>, <span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">r.brpoplpush(<span class="string">'l1'</span>, <span class="string">'l1'</span>, timeout=<span class="number">3</span>) <span class="comment"># # timeout，当src对应的列表中没有数据时，阻塞等待其有数据的超时时间（秒），0 表示永远阻塞</span></span><br><span class="line">print(r.lrange(<span class="string">'l1'</span>, <span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">print(r.blpop(<span class="string">'l1'</span>, <span class="number">3</span>)) <span class="comment"># 从列表头部取出第一个元素，返回该元素值并从列表删除（l代表left，左边）</span></span><br><span class="line">print(r.lrange(<span class="string">'l1'</span>, <span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"># 由于redis类库中没有提供对列表元素的增量迭代，如果想要循环name对应的列表的所有元素，那么就需要：</span></span><br><span class="line"><span class="string"># 1、获取name对应的所有列表</span></span><br><span class="line"><span class="string"># 2、循环列表</span></span><br><span class="line"><span class="string"># 但是，如果列表非常大，那么就有可能在第一步时就将程序的内容撑爆，所有有必要自定义一个增量迭代的功能：</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'自定义增量迭代：'</span>)</span><br><span class="line">r.flushall()</span><br><span class="line">r.lpush(<span class="string">'l1'</span>, <span class="number">11</span>) <span class="comment"># index为0</span></span><br><span class="line">r.rpush(<span class="string">'l1'</span>, <span class="number">22</span>)</span><br><span class="line">r.rpush(<span class="string">'l1'</span>, <span class="number">33</span>)</span><br><span class="line">r.rpush(<span class="string">'l1'</span>, <span class="number">44</span>)</span><br><span class="line">r.rpush(<span class="string">'l1'</span>, <span class="number">55</span>) <span class="comment"># index为4</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_iter</span><span class="params">(name)</span>:</span></span><br><span class="line">list_count = r.llen(name)</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(list_count):</span><br><span class="line">	<span class="keyword">yield</span> r.lindex(name, index)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> list_iter(<span class="string">'l1'</span>):</span><br><span class="line">	print(item)</span><br></pre></td></tr></table></figure> 输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">[<span class="string">b'0'</span>, <span class="string">b'88'</span>, <span class="string">b'11'</span>]</span><br><span class="line"></span><br><span class="line">[<span class="string">b'0'</span>, <span class="string">b'11'</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">b'0'</span></span><br><span class="line"></span><br><span class="line"><span class="string">b'11'</span></span><br><span class="line"></span><br><span class="line">[<span class="string">b'22'</span>, <span class="string">b'33'</span>, <span class="string">b'44'</span>]</span><br><span class="line"></span><br><span class="line">[<span class="string">b'44'</span>, <span class="string">b'22'</span>, <span class="string">b'33'</span>]</span><br><span class="line"></span><br><span class="line">[<span class="string">b'33'</span>, <span class="string">b'44'</span>, <span class="string">b'22'</span>]</span><br><span class="line"></span><br><span class="line">(<span class="string">b'l1'</span>, <span class="string">b'33'</span>)</span><br><span class="line"></span><br><span class="line">[<span class="string">b'44'</span>, <span class="string">b'22'</span>]</span><br><span class="line"></span><br><span class="line">自定义增量迭代：</span><br><span class="line"></span><br><span class="line"><span class="string">b'11'</span></span><br><span class="line"></span><br><span class="line"><span class="string">b'22'</span></span><br><span class="line"></span><br><span class="line"><span class="string">b'33'</span></span><br><span class="line"></span><br><span class="line"><span class="string">b'44'</span></span><br><span class="line"></span><br><span class="line"><span class="string">b'55'</span></span><br></pre></td></tr></table></figure>
<h3 id="三集合-sets">三、集合 sets</h3>
<p>Redis 数据库集合对象(set
object)是由string类型的无重复元素的无需集合，底层编码可以是intset或者hashtable。intset编码的集合对象用整数集合最为底层实现，所有对象元素保存在整数集合中。Python的redis模块实现了
SADD、SCARD 、SDIFF 、SDIFFSTORE、SINTER 、SINTERSTORE、SISMEMBER
、SMEMBERS
、SMOVE、SPOP、SRANDMEMBER、SREM、SUNION、SUNIONSTORE操作命令的基本用法。函数说明如下：</p>
<ol type="1">
<li><strong>SADD</strong>：向集合对象添加成员，sadd(self, name,
value)</li>
<li><strong>SCARD</strong>：获取集合元素个数，scard(self, name)</li>
<li><strong>SDIFF</strong>：返回给定多个集合对象的差集(set key1-set
key2..-set keyn)，从左到右计算集合差集，sdiff(self, keys, *args)</li>
<li><strong>SDIFFSTORE</strong>：返回给定给定多个集合对象的差集并存储在目标（dest）集合中，sdiffstore(self,
dest, keys, *args)</li>
<li><strong>SINTER</strong>：返回给定所有集合（keys, <em>args）的交集,
sinter(self, keys,</em> args)</li>
<li><strong>SINTERSTORE</strong>：返回给定所有集合（keys,
<em>args）的交集并存储在 集合(dest) 中, sinterstore(self, dest,
keys,</em> args)</li>
<li><strong>SISMEMBER</strong>：判断 value元素是否是集合 name
的成员,返回布尔逻辑值True或者False，sismember(self, name, value)</li>
<li><strong>SMEMBERS</strong>：返回集合中所元素值的Python集合类型数据，smembers(self,
name)</li>
<li><strong>SMOVE</strong>：将元素value从集合src移动到 集合
dest。若元素value在集合src中不存在，则集合dest中不会添加元素value，
smove(self, src, dest, value)</li>
<li><strong>SPOP</strong>：移除并返回集合中的一个随机元素, spop(self,
name)</li>
<li><strong>SRANDMEMBER</strong>：返回集合中一个随机数，但是不做移除操作,
srandmember(self, name)。从Redis 2.6 版本开始， 在命令行下Srandmember
命令接受可选返回元素数量的参数 redis&gt;SRANDMEMBER name count</li>
<li><strong>SREM</strong>：移除集合中一个元素，srem(self, name,
value)，redis模块任然沿用Redis 2.4 版本以前的只接受单个元素的用法。</li>
<li><strong>SUNION</strong>：返回所有给定集合的并集中所有元素，sunion(self,
keys, *args)</li>
<li><strong>SUNIONSTORE</strong>：所有给定集合的并集存储在集合dest 中,
sunionstore(self, dest, keys, *args)</li>
<li><strong>SSCAN</strong>：迭代集合中的元素，sscan(self, name,
cursor=0, match=None, count=None)</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># __author__ = 'free'</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line"></span><br><span class="line">r.flushall() <span class="comment"># 清空Redis</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">r.sadd(<span class="string">'s1'</span>, <span class="string">'v1'</span>, <span class="string">'v1'</span>, <span class="string">'v2'</span>, <span class="string">'v3'</span>) <span class="comment"># name对应的集合中添加元素</span></span><br><span class="line">r.sadd(<span class="string">'s2'</span>, <span class="string">'v2'</span>, <span class="string">'v4'</span>) <span class="comment"># name对应的集合中添加元素</span></span><br><span class="line">print(r.scard(<span class="string">'s1'</span>)) <span class="comment"># 获取name对应的集合中元素个数</span></span><br><span class="line">print(r.sdiff(<span class="string">'s1'</span>, <span class="string">'s2'</span>)) <span class="comment">#在第一个name对应的集合中且不在其他name对应的集合的元素集合</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">r.sdiffstore(<span class="string">'s3'</span>, <span class="string">'s1'</span>, <span class="string">'s2'</span>) <span class="comment"># 获取第一个name对应的集合中且不在其他name对应的集合，再将其新加入到dest对应的集合中</span></span><br><span class="line">print(r.smembers(<span class="string">'s3'</span>)) <span class="comment"># 获取s3对应的集合的所有成员</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">print(r.sinter(<span class="string">'s1'</span>, <span class="string">'s2'</span>)) <span class="comment"># 获取s1, s2对应集合的交集</span></span><br><span class="line">r.sinterstore(<span class="string">'s4'</span>, <span class="string">'s1'</span>, <span class="string">'s2'</span>) <span class="comment"># 获取s1, s2对应集合的交集，并将其存放到集合是s4中</span></span><br><span class="line">print(r.smembers(<span class="string">'s4'</span>))</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">print(r.sunion(<span class="string">'s1'</span>, <span class="string">'s2'</span>)) <span class="comment"># 获取s1, s2对应集合的并集</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">r.sunionstore(<span class="string">'s5'</span>, <span class="string">'s1'</span>, <span class="string">'s2'</span>) <span class="comment"># 获取s1, s2对应集合的交集，并将其存放到集合是s5中</span></span><br><span class="line">print(r.smembers(<span class="string">'s5'</span>))</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">print(r.sismember(<span class="string">'s4'</span>, <span class="string">'v4'</span>)) <span class="comment"># 检查value是否是name对应的集合的成员</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">r.smove(<span class="string">'s2'</span>, <span class="string">'s1'</span>, <span class="string">'v4'</span>) <span class="comment"># 将集合s2中成员v4移至集合s1中</span></span><br><span class="line">print(r.smembers(<span class="string">'s1'</span>))</span><br><span class="line">r.srem(<span class="string">'s1'</span>, <span class="string">'v1'</span>) <span class="comment"># 在name对应的集合中删除某些值</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">print(r.spop(<span class="string">'s1'</span>)) <span class="comment"># 从集合的右侧（尾部）移除一个成员，并将其返回 注意：集合是无序的，故结果随机！</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">print(r.srandmember(<span class="string">'s1'</span>)) <span class="comment"># 从name对应的集合中随机获取 numbers 个元素(Redis 2.6+)</span></span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="string">b'v3'</span>, <span class="string">b'v1'</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">b'v3'</span>, <span class="string">b'v1'</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">b'v2'</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">b'v2'</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">b'v3'</span>, <span class="string">b'v2'</span>, <span class="string">b'v4'</span>, <span class="string">b'v1'</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">b'v3'</span>, <span class="string">b'v2'</span>, <span class="string">b'v4'</span>, <span class="string">b'v1'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="string">b'v3'</span>, <span class="string">b'v2'</span>, <span class="string">b'v4'</span>, <span class="string">b'v1'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">b'v2'</span></span><br><span class="line"></span><br><span class="line"><span class="string">b'v3'</span></span><br></pre></td></tr></table></figure>
<h3 id="四有序集合-sorted-sets">四、有序集合 sorted sets</h3>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">命令</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Redis Zadd 命令</td>
<td
style="text-align: left;">向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr class="even">
<td style="text-align: left;">Redis Zcard 命令</td>
<td style="text-align: left;">获取有序集合的成员数</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Redis Zcount 命令</td>
<td style="text-align: left;">计算在有序集合中指定区间分数的成员数</td>
</tr>
<tr class="even">
<td style="text-align: left;">Redis Zincrby 命令</td>
<td style="text-align: left;">有序集合中对指定成员的分数加上增量
increment</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Redis Zinterstore 命令</td>
<td
style="text-align: left;">计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合
key 中</td>
</tr>
<tr class="even">
<td style="text-align: left;">Redis Zlexcount 命令</td>
<td
style="text-align: left;">在有序集合中计算指定字典区间内成员数量</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Redis Zrange 命令</td>
<td
style="text-align: left;">通过索引区间返回有序集合成指定区间内的成员</td>
</tr>
<tr class="even">
<td style="text-align: left;">Redis Zrangebylex 命令</td>
<td style="text-align: left;">通过字典区间返回有序集合的成员</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Redis Zrangebyscore 命令</td>
<td style="text-align: left;">通过分数返回有序集合指定区间内的成员</td>
</tr>
<tr class="even">
<td style="text-align: left;">Redis Zrank 命令</td>
<td style="text-align: left;">返回有序集合中指定成员的索引</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Redis Zrem 命令</td>
<td style="text-align: left;">移除有序集合中的一个或多个成员</td>
</tr>
<tr class="even">
<td style="text-align: left;">Redis Zremrangebylex 命令</td>
<td
style="text-align: left;">移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Redis Zremrangebyrank 命令</td>
<td
style="text-align: left;">移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr class="even">
<td style="text-align: left;">Redis Zremrangebyscore 命令</td>
<td
style="text-align: left;">移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Redis Zrevrange 命令</td>
<td
style="text-align: left;">返回有序集中指定区间内的成员，通过索引，分数从高到底</td>
</tr>
<tr class="even">
<td style="text-align: left;">Redis Zrevrangebyscore 命令</td>
<td
style="text-align: left;">返回有序集中指定分数区间内的成员，分数从高到低排序</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Redis Zrevrank 命令</td>
<td
style="text-align: left;">返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
<tr class="even">
<td style="text-align: left;">Redis Zscore 命令</td>
<td style="text-align: left;">返回有序集中，成员的分数值</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Redis Zunionstore 命令</td>
<td
style="text-align: left;">计算给定的一个或多个有序集的并集，并存储在新的
key 中</td>
</tr>
<tr class="even">
<td style="text-align: left;">Redis Zscan 命令</td>
<td
style="text-align: left;">迭代有序集合中的元素（包括元素成员和元素分值）</td>
</tr>
</tbody>
</table>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># __author__ = 'free'</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line"></span><br><span class="line">r.flushall() <span class="comment"># 清空Redis</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">r.zadd(<span class="string">'z1'</span>, <span class="string">'11'</span>, <span class="number">1</span>, <span class="string">'22'</span>, <span class="number">2</span>, <span class="string">'33'</span>, <span class="number">3</span>, <span class="string">'44'</span>, <span class="number">4</span>, <span class="string">'55'</span>, <span class="number">5</span>, <span class="string">'66'</span>, <span class="number">6</span>, <span class="string">'66'</span>, <span class="number">7</span>) <span class="comment"># 在name对应的有序集合中添加元素</span></span><br><span class="line">print(r.zcard(<span class="string">'z1'</span>)) <span class="comment"># 获取name对应的有序集合元素的数量</span></span><br><span class="line">print(r.zcount(<span class="string">'z1'</span>, <span class="number">1</span>, <span class="number">2</span>)) <span class="comment"># 获取name对应的有序集合中分数 在 [min,max] 之间的个数</span></span><br><span class="line">r.zincrby(<span class="string">'z1'</span>, <span class="string">'11'</span>, amount=<span class="number">5</span>) <span class="comment"># 自增name对应的有序集合的 name 对应的分数</span></span><br><span class="line">print(r.zrange(<span class="string">'z1'</span>, <span class="number">0</span>, <span class="number">-1</span>, desc=<span class="literal">False</span>, withscores=<span class="literal">True</span>)) <span class="comment"># 值11被排序到最后;此处表示按元素的值升序排列</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">print(r.zrank(<span class="string">'z1'</span>, <span class="number">33</span>)) <span class="comment"># 获取某个值在 name对应的有序集合中的排行（从 0 开始）</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">r.zrem(<span class="string">'z1'</span>, <span class="string">'66'</span>) <span class="comment"># 删除name对应的有序集合中值是values的成员</span></span><br><span class="line">print(r.zrange(<span class="string">'z1'</span>, <span class="number">0</span>, <span class="number">-1</span>, desc=<span class="literal">False</span>, withscores=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">r.zremrangebyrank(<span class="string">'z1'</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="comment"># 根据排行范围删除</span></span><br><span class="line">print(r.zrange(<span class="string">'z1'</span>, <span class="number">0</span>, <span class="number">-1</span>, desc=<span class="literal">False</span>, withscores=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">r.zremrangebyscore(<span class="string">'z1'</span>, <span class="number">4.5</span>, <span class="number">5.5</span>) <span class="comment"># 根据分数范围删除</span></span><br><span class="line">print(r.zrange(<span class="string">'z1'</span>, <span class="number">0</span>, <span class="number">-1</span>, desc=<span class="literal">False</span>, withscores=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">print(r.zscore(<span class="string">'z1'</span>, <span class="number">11</span>)) <span class="comment"># 获取name对应有序集合中 value 对应的分数</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">r.zadd(<span class="string">"zset_name"</span>, <span class="string">"a1"</span>, <span class="number">6</span>, <span class="string">"a2"</span>, <span class="number">2</span>, <span class="string">"a3"</span>, <span class="number">5</span>)</span><br><span class="line">r.zadd(<span class="string">'zset_name1'</span>, a1=<span class="number">7</span>, b1=<span class="number">10</span>, b2=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作</span></span><br><span class="line"><span class="string">aggregate的值为: SUM MIN MAX</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">r.zinterstore(<span class="string">'zset_name2'</span>, (<span class="string">'zset_name'</span>, <span class="string">'zset_name1'</span>), aggregate=<span class="string">'Sum'</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">print(r.zrange(<span class="string">'zset_name2'</span>, <span class="number">0</span>, <span class="number">-1</span>, desc=<span class="literal">False</span>, withscores=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">[(<span class="string">b'22'</span>, <span class="number">2.0</span>), (<span class="string">b'33'</span>, <span class="number">3.0</span>), (<span class="string">b'44'</span>, <span class="number">4.0</span>), (<span class="string">b'55'</span>, <span class="number">5.0</span>), (<span class="string">b'11'</span>, <span class="number">6.0</span>), (<span class="string">b'66'</span>, <span class="number">6.0</span>)]</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">[(<span class="string">b'22'</span>, <span class="number">2.0</span>), (<span class="string">b'33'</span>, <span class="number">3.0</span>), (<span class="string">b'44'</span>, <span class="number">4.0</span>), (<span class="string">b'55'</span>, <span class="number">5.0</span>), (<span class="string">b'11'</span>, <span class="number">6.0</span>)]</span><br><span class="line"></span><br><span class="line">[(<span class="string">b'44'</span>, <span class="number">4.0</span>), (<span class="string">b'55'</span>, <span class="number">5.0</span>), (<span class="string">b'11'</span>, <span class="number">6.0</span>)]</span><br><span class="line"></span><br><span class="line">[(<span class="string">b'44'</span>, <span class="number">4.0</span>), (<span class="string">b'11'</span>, <span class="number">6.0</span>)]</span><br><span class="line"></span><br><span class="line"><span class="number">6.0</span></span><br><span class="line"></span><br><span class="line">[(<span class="string">b'a1'</span>, <span class="number">13.0</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="五哈希-hashes">五、哈希 hashes</h3>
<p>Redis
数据库hash数据类型是一个string类型的key和value的映射表，适用于存储对象。redis
中每个hash可以存储键值对多达40亿。Python的redis模块实现了Redis哈希（Hash）命令行操作的几乎全部命令，包括HDEL、HEXISTS、HGET、HGETALL、HINCRBY、HKEYS、HLEN
、HMGET 、HMSET 、HSET 、HSETNX 、HVALS
、HINCRBYFLOAT等命令。函数说明如下：</p>
<ol type="1">
<li><strong>HDEL</strong>：删除对应哈希（Hash）表的指定键（key）的字段，hdel(self,
name, key)</li>
<li><strong>HEXISTS</strong>：检测哈希（Hash）表对应键（key）字段是否存在，返回布尔逻辑，hexists(self,
name, key)</li>
<li><strong>HGET</strong>：获取哈希（Hash）指定键（key）对应的值，hget(self,
name, key)</li>
<li><strong>HGETALL</strong>：获取哈希(Hash)表的键-值对（key-value
pairs）,返回python字典类型数据，hgetall(self, name)</li>
<li><strong>HINCRBY</strong>：为哈希表（Hash）指定键（key）对应的值（key）加上指定的整数数值（int，可为负值）hincrby(self&gt;,
name, key, amount=1)，Redis 中本操作的值被限制在 64
位(bit)有符号数字。</li>
<li><strong>HKEYS</strong>：返回哈希表（Hash）对应键（key）的数组（Python称之为列表List），hkeys(self,
name)</li>
<li><strong>HLEN</strong>： 获取哈希表（Hash）中键-值对（key-value
pairs）个数，hlen(self, name)</li>
<li><strong>HMGET</strong>：获取哈希表（Hash）中一个或多个给点字段的值，不存在返回nil(Redis命令行)/None(Python)，hmget(self,
name, keys)，其中keys可以为列表（list）</li>
<li><strong>HMSET</strong>：设置对个键-值对（key-value
pairs）到哈希表（Hash）中，python输入值（mapping）为字典（dictionary）类型，hmset(self,
name, mapping)</li>
<li><strong>HSET</strong>：为哈希表（Hash）赋值，若键（key）存在值（value）则覆盖，不存在则创建，hset(self,
name, key, value)</li>
<li><strong>HSETNX</strong>：为哈希表（Hash）不存值（value）的键（key）赋值，存在操作无效，对应值（value）无变化，hsetnx(self,
name, key, value)</li>
<li><strong>HVALS</strong>：返回哈希表（Hash）对应值（value）的列表，hvals(self,
name)</li>
<li><strong>HINCRBYFLOAT</strong>：为哈希表 key
中的指定字段的浮点数值加上增量 increment ，hincrbyfloat(self, name, key,
amount=1.0)</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># __author__ = 'free'</span></span><br><span class="line"></span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line"></span><br><span class="line">r.flushall() <span class="comment"># 清空Redis</span></span><br><span class="line"></span><br><span class="line">r.hset(<span class="string">'n1'</span>, <span class="string">'k1'</span>, <span class="string">'v1'</span>) <span class="comment"># hset(name, key, value),name对应的hash中设置一个键值对（不存在，则创建；否则，修改）</span></span><br><span class="line">print(r.hget(<span class="string">'n1'</span>, <span class="string">'k1'</span>))</span><br><span class="line">r.hmset(<span class="string">'n2'</span>, &#123;<span class="string">'k1'</span>: <span class="string">'v1'</span>, <span class="string">'k2'</span>: <span class="string">'v2'</span>, <span class="string">'k3'</span>: <span class="string">'v3'</span>&#125;) <span class="comment"># hmset(name, mapping),在name对应的hash中批量设置键值对</span></span><br><span class="line">print(r.hmget(<span class="string">'n2'</span>, <span class="string">'k2'</span>))</span><br><span class="line">print(r.hgetall(<span class="string">'n2'</span>)) <span class="comment"># 获取name对应hash的所有键值</span></span><br><span class="line">print(r.hlen(<span class="string">'n2'</span>)) <span class="comment"># 获取name对应的hash中键值对的个数</span></span><br><span class="line">print(r.hkeys(<span class="string">'n2'</span>)) <span class="comment"># 获取name对应的hash中所有的key的值</span></span><br><span class="line">print(r.hvals(<span class="string">'n2'</span>)) <span class="comment"># 获取name对应的hash中所有的value的值</span></span><br><span class="line">print(r.hexists(<span class="string">'n2'</span>, <span class="string">'k4'</span>)) <span class="comment"># 检查name对应的hash是否存在当前传入的key</span></span><br><span class="line">r.hdel(<span class="string">'n2'</span>, <span class="string">'k3'</span>) <span class="comment"># 将name对应的hash中指定key的键值对删除</span></span><br><span class="line">r.hset(<span class="string">'n3'</span>, <span class="string">'k1'</span>, <span class="number">1</span>)</span><br><span class="line">r.hincrby(<span class="string">'n3'</span>, <span class="string">'k1'</span>, amount=<span class="number">1</span>) <span class="comment"># hincrby(name, key, amount=1),自增name对应的hash中的指定key的value的值，不存在则创建key=amount</span></span><br><span class="line">print(r.hgetall(<span class="string">'n3'</span>))</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">b'v1'</span></span><br><span class="line"></span><br><span class="line">[<span class="string">b'v2'</span>]</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">b'k1'</span>: <span class="string">b'v1'</span>, <span class="string">b'k2'</span>: <span class="string">b'v2'</span>, <span class="string">b'k3'</span>: <span class="string">b'v3'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">[<span class="string">b'k1'</span>, <span class="string">b'k2'</span>, <span class="string">b'k3'</span>]</span><br><span class="line"></span><br><span class="line">[<span class="string">b'v1'</span>, <span class="string">b'v2'</span>, <span class="string">b'v3'</span>]</span><br><span class="line"></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="string">b'k1'</span>: <span class="string">b'2'</span>&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>python赋值&amp;浅拷贝&amp;深拷贝</title>
    <url>/python%E8%B5%8B%E5%80%BC-%E6%B5%85%E6%8B%B7%E8%B4%9D-%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>记录Python中赋值&amp;浅拷贝&amp;深拷贝和区别，同时还有list.append()时浅拷贝的问题</p>
<a id="more"></a>
<h2 id="赋值">赋值</h2>
<p>在python中，对象的赋值就是简单的对象引用，这点和C++是不同的</p>
<p>如下例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">b = a   <span class="comment"># 采用简单的=赋值</span></span><br><span class="line">print(a==b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是输出结果：</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>这种情况下，b和a是一样的，他们指向同一片内存，b不过是a的别名，是引用。我们可以使用a与b是否相同来判断，返回<code>True</code>，表明他们地址相同，内容相同。</p>
<p>赋值操作(包括对象作为参数、返回值)不会开辟新的内存空间，它只是复制了新对象的引用。也就是说，除了b这个名字以外，没有其它的内存开销。</p>
<p>修改了a，就影响了b；同理，修改了b就影响了a。下面的例子尝试对b进行修改，在后面加入新的元素’d’，通过观察输出结果发现：在修改列表b的同时，列表a也会被修改，因为两者用的是同一个内存空间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">b = a</span><br><span class="line">b.append(<span class="string">'d'</span>)</span><br><span class="line">print(<span class="string">'a = &#123;&#125;'</span>.format(a))</span><br><span class="line">print(<span class="string">'b = &#123;&#125;'</span>.format(b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是输出结果：</span></span><br><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line">b = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br></pre></td></tr></table></figure>
<h2 id="浅拷贝">浅拷贝</h2>
<p>浅拷贝会创建新对象，其内容是原对象的引用。</p>
<p>浅拷贝有三种形式：切片操作，工厂函数，<code>copy</code>模块中的copy函数。</p>
<p><strong>比如对上述a：</strong></p>
<ul>
<li>1、切片操作：b = a[:] 或者 b = [each for each in a]</li>
<li>2、工厂函数：b = list(a)</li>
<li>3、copy函数：b = copy.copy(a) #使用时要import copy模块</li>
</ul>
<p>浅拷贝产生的b不再是a了，使用is可以发现他们不是同一个对象，使用id查看，发现它们也不指向同一片内存。但是当我们使用
id(x) for x in a 和 id(x) for x in b
时，可以看到二者包含的元素的地址是相同的。</p>
<p>在这种情况下，a和b是不同的对象，修改b理论上不会影响a。比如b.append([4,5])。</p>
<p><strong>代码效果如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, [<span class="string">'yellow'</span>, <span class="string">'red'</span>]]</span><br><span class="line">b = a[:]  <span class="comment"># 采用了切片操作对列表b进行赋值</span></span><br><span class="line">b.append(<span class="string">'green'</span>) <span class="comment"># 对列表b执行添加元素操作</span></span><br><span class="line">print(<span class="string">'a = &#123;&#125;'</span>.format(a))</span><br><span class="line">print(<span class="string">'b = &#123;&#125;'</span>.format(b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是输出结果：</span></span><br><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, [<span class="string">'yellow'</span>, <span class="string">'red'</span>]]  <span class="comment"># a中的元素不发生变化</span></span><br><span class="line">b = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, [<span class="string">'yellow'</span>, <span class="string">'red'</span>], <span class="string">'green'</span>]  <span class="comment"># b中增加了一个元素'green'</span></span><br></pre></td></tr></table></figure>
<p><strong>但是要注意：</strong>浅拷贝之所以称为浅拷贝，是它仅仅只拷贝了一层，在a中有一个嵌套的list，如果我们修改了它，情况就不一样了。</p>
<p>a[3].append(“blue”)。查看b，你将发现b也发生了变化。这是因为，你修改了嵌套的list。修改外层元素，会修改它的引用，让它们指向别的位置，修改嵌套列表中的元素，列表的地址并为发生变化，指向的都是同一个位置。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, [<span class="string">'yellow'</span>, <span class="string">'red'</span>]]</span><br><span class="line">b = a[:]  <span class="comment"># 采用了切片操作对列表b进行赋值</span></span><br><span class="line">a[<span class="number">3</span>].append(<span class="string">'blue'</span>)  <span class="comment"># 在a列表中的第3个元素中增加元素'blue'，由于a[3]本身也是一个列表，从而是在列表后增加了元素'blue'，从输出结果中可以看出来。</span></span><br><span class="line">print(<span class="string">'a = &#123;&#125;'</span>.format(a))</span><br><span class="line">print(<span class="string">'b = &#123;&#125;'</span>.format(b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是输出结果：</span></span><br><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, [<span class="string">'yellow'</span>, <span class="string">'red'</span>, <span class="string">'blue'</span>]]</span><br><span class="line">b = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, [<span class="string">'yellow'</span>, <span class="string">'red'</span>, <span class="string">'blue'</span>]]</span><br></pre></td></tr></table></figure>
<h2 id="深拷贝">深拷贝</h2>
<p>深拷贝只有一种形式，<code>copy</code>模块中的<code>deepcopy</code>函数。</p>
<p>和浅拷贝对应，深拷贝拷贝了对象的所有元素，包括多层嵌套的元素。因而，它的时间和空间开销要高。</p>
<p>同样对la，若使用<code>b = copy.deepcopy(a)</code>，再修改b将不会影响到a了。即使嵌套的列表具有更深的层次，也不会产生任何影响，因为深拷贝出来的对象根本就是一个全新的对象，不再与原来的对象有任何关联。</p>
<p><strong>实例代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, [<span class="string">'yellow'</span>, <span class="string">'red'</span>]]</span><br><span class="line">b = copy.deepcopy(a)   <span class="comment"># 采用深拷贝对a进行深拷贝操作</span></span><br><span class="line">b.append(<span class="string">'xyz'</span>)</span><br><span class="line">print(<span class="string">'a = &#123;&#125;'</span>.format(a))</span><br><span class="line">print(<span class="string">'b = &#123;&#125;'</span>.format(b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是输出结果：</span></span><br><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, [<span class="string">'yellow'</span>, <span class="string">'red'</span>]]   <span class="comment"># 使用深拷贝，对b的修改不会影响到a</span></span><br><span class="line">b = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, [<span class="string">'yellow'</span>, <span class="string">'red'</span>], <span class="string">'xyz'</span>]</span><br></pre></td></tr></table></figure>
<p><strong>或者用下面的代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, [<span class="string">'yellow'</span>, <span class="string">'red'</span>]]</span><br><span class="line">b = copy.deepcopy(a)   <span class="comment"># 采用深拷贝对a进行深拷贝操作</span></span><br><span class="line">a[<span class="number">3</span>].append(<span class="string">'crazy'</span>)</span><br><span class="line">print(<span class="string">'a = &#123;&#125;'</span>.format(a))</span><br><span class="line">print(<span class="string">'b = &#123;&#125;'</span>.format(b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是输出结果：</span></span><br><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, [<span class="string">'yellow'</span>, <span class="string">'red'</span>, <span class="string">'crazy'</span>]]  </span><br><span class="line">b = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, [<span class="string">'yellow'</span>, <span class="string">'red'</span>]]   <span class="comment"># 对a的修改不会影响到b</span></span><br></pre></td></tr></table></figure>
<p><strong>或者用下面的代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, [<span class="string">'yellow'</span>, <span class="string">'red'</span>]]</span><br><span class="line">b = copy.deepcopy(a)   <span class="comment"># 采用深拷贝对a进行深拷贝操作</span></span><br><span class="line">a[<span class="number">3</span>].append(<span class="string">'crazy'</span>)</span><br><span class="line">b.append(<span class="string">'dddd'</span>)</span><br><span class="line">print(<span class="string">'a = &#123;&#125;'</span>.format(a))</span><br><span class="line">print(<span class="string">'b = &#123;&#125;'</span>.format(b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是输出结果：</span></span><br><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, [<span class="string">'yellow'</span>, <span class="string">'red'</span>, <span class="string">'crazy'</span>]]</span><br><span class="line">b = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, [<span class="string">'yellow'</span>, <span class="string">'red'</span>], <span class="string">'dddd'</span>]</span><br></pre></td></tr></table></figure>
<h2 id="关于拷贝操作的提醒">关于拷贝操作的提醒</h2>
<ul>
<li>对于非容器类型，如数字，字符，以及其它“原子”类型，没有拷贝一说。产生的都是原对象的引用。</li>
<li>如果元组变量值包含原子类型对象，即使采用了深拷贝，也只能得到浅拷贝。</li>
</ul>
<h2 id="list.append的浅拷贝问题">list.append()的浅拷贝问题</h2>
<p>Python中的append方法是一个常用的方法，可以将一个对象添加到列表末尾，这里面可以存在一个浅拷贝的大坑！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = [1, 3, 5, <span class="string">"a"</span>]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = []</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b.append(a)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b</span></span><br><span class="line">[[1, 3, 5, 'a']]</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a.append(<span class="string">"aha"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b    <span class="comment"># surprise?</span></span></span><br><span class="line">[[1, 3, 5, 'a', 'aha']]</span><br></pre></td></tr></table></figure>
<p>事实上，append方法是浅拷贝。在Python中，对象赋值实际上是对象的引用，当创建一个对象，然后把它赋值给另一个变量的时候，Python并没有拷贝这个对象，而只是拷贝了这个对象的引用，这就是浅拷贝。</p>
<p>我们逐步来看。首先，b.append(a)就是对a进行了浅拷贝，结果为b=[[1, 3,
5, 'a']]，但b[0]与a引用的对象是相同的，这可以通过id函数进行验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; id(b[0])</span></span><br><span class="line">3145735177480</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; id(a)</span></span><br><span class="line">3145735177480</span><br></pre></td></tr></table></figure>
<p>所以，在日常使用append函数的时候，就需要将浅拷贝变为深拷贝（其实也不能叫深拷贝，应该是双重浅拷贝，可以看上面浅拷贝的内容，只拷贝一层），有两个解决方案：</p>
<ul>
<li>b.append(list(a))</li>
<li>b.append(a[:])</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python调用CIC</title>
    <url>/python%E8%B0%83%E7%94%A8CIC/</url>
    <content><![CDATA[<p>在这里记录下使用python通过命令行调用CIC的过程，包含给pcap整体打标签，多个pcap整合等内容</p>
<a id="more"></a>
<blockquote>
<p>整体思路比较简单，使用python自带的<strong>subprocess</strong>来通过命令行调用我们部署好的CIC程序，然后将多个pcap包提取出的CSV进行打标签和整合</p>
</blockquote>
<h3 id="部分介绍">部分介绍</h3>
<p>首先是引入必要的库，其中的<strong>CIC_dfm</strong>就是CIC部署成功后dfm文件的绝对路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> utils.db_config <span class="keyword">import</span> CIC_dfm</span><br></pre></td></tr></table></figure>
<p>然后是调用CIC部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cmd = <span class="string">'%s %s %s'</span> % (CIC_dfm, pcap_path, csv_save_folder)</span><br><span class="line"><span class="comment"># 调CIC</span></span><br><span class="line">p = subprocess.Popen(cmd, shell=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 阻塞等待CIC执行完成</span></span><br><span class="line">return_code = p.wait()</span><br></pre></td></tr></table></figure>
<p>之后就是对PCAP列表中的每一个PCAP包调用CIC进行处理，然后将处理完的结果放到一个df里最后再存成CSV</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> pcap_path <span class="keyword">in</span> pcap_list:</span><br><span class="line">    pcap_name = pcap_path.split(os.sep)[<span class="number">-1</span>].replace(<span class="string">'.pcap'</span>, <span class="string">''</span>)</span><br><span class="line">    cmd = <span class="string">'%s %s %s'</span> % (CIC_dfm, pcap_path, csv_save_folder)</span><br><span class="line">    <span class="comment"># 调CIC</span></span><br><span class="line">    p = subprocess.Popen(cmd, shell=<span class="literal">True</span>)</span><br><span class="line">    return_code = p.wait()</span><br><span class="line">    csv_path = os.path.join(csv_save_folder, pcap_name + <span class="string">'.pcap_Flow.csv'</span>)</span><br><span class="line">    <span class="keyword">if</span> pcap_path == pcap_list[<span class="number">0</span>]:</span><br><span class="line">        df = pd.read_csv(csv_path, skipinitialspace=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        temp_df = pd.read_csv(csv_path, skipinitialspace=<span class="literal">True</span>)</span><br><span class="line">        df = pd.concat([df, temp_df], ignore_index=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 删除中间结果</span></span><br><span class="line">    os.remove(csv_path)</span><br><span class="line"></span><br><span class="line">csv_save_path = os.path.join(csv_save_folder, <span class="string">'%s.csv'</span> % time_now)</span><br><span class="line">df.to_csv(csv_save_path, index=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="完整程序">完整程序</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> utils.db_config <span class="keyword">import</span> CIC_dfm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unsupervise_extract</span><span class="params">(mode_id: int, pcap_list: list, csv_save_folder: str)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    无监督算法流量特征提取，包含训练，离线测试和在线测试</span></span><br><span class="line"><span class="string">    :param mode_id:</span></span><br><span class="line"><span class="string">        1为训练;</span></span><br><span class="line"><span class="string">        2为离线测试;</span></span><br><span class="line"><span class="string">        3为在线测试;</span></span><br><span class="line"><span class="string">    :param pcap_list: 要进行特征提取的pcap包路径列表(在线测试时里面只能包含一个)</span></span><br><span class="line"><span class="string">    :param csv_save_folder: 提取出的csv文件要保存的目录</span></span><br><span class="line"><span class="string">    :return: csv_save_path: 提取出的csv文件路径</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    time_now = time.strftime(<span class="string">"%Y%m%d-%H%M%S"</span>, time.localtime())</span><br><span class="line">    os.makedirs(csv_save_folder, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> mode_id <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">        print(<span class="string">'mode_id出错'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> mode_id == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">assert</span> len(pcap_list) == <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">'在线测试时pcap_list中只能包含一个pcap包'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> pcap_path <span class="keyword">in</span> pcap_list:</span><br><span class="line">        pcap_name = pcap_path.split(os.sep)[<span class="number">-1</span>].replace(<span class="string">'.pcap'</span>, <span class="string">''</span>)</span><br><span class="line">        cmd = <span class="string">'%s %s %s'</span> % (CIC_dfm, pcap_path, csv_save_folder)</span><br><span class="line">        <span class="comment"># 调CIC</span></span><br><span class="line">        p = subprocess.Popen(cmd, shell=<span class="literal">True</span>)</span><br><span class="line">        return_code = p.wait()</span><br><span class="line">        csv_path = os.path.join(csv_save_folder, pcap_name + <span class="string">'.pcap_Flow.csv'</span>)</span><br><span class="line">        <span class="keyword">if</span> pcap_path == pcap_list[<span class="number">0</span>]:</span><br><span class="line">            df = pd.read_csv(csv_path, skipinitialspace=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp_df = pd.read_csv(csv_path, skipinitialspace=<span class="literal">True</span>)</span><br><span class="line">            df = pd.concat([df, temp_df], ignore_index=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 删除中间结果</span></span><br><span class="line">        os.remove(csv_path)</span><br><span class="line"></span><br><span class="line">    csv_save_path = os.path.join(csv_save_folder, <span class="string">'%s.csv'</span> % time_now)</span><br><span class="line">    df.to_csv(csv_save_path, index=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> csv_save_path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">supervise_extract</span><span class="params">(mode_id: int, pcap_list: list, norm_pcap_list: list,</span></span></span><br><span class="line"><span class="function"><span class="params">                      abnorm_pcap_list: list, csv_save_folder: str)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    有监督算法流量特征提取，包含训练，离线测试和在线测试</span></span><br><span class="line"><span class="string">    :param mode_id:</span></span><br><span class="line"><span class="string">        1为训练;</span></span><br><span class="line"><span class="string">        2为离线测试;</span></span><br><span class="line"><span class="string">        3为在线测试;</span></span><br><span class="line"><span class="string">    :param pcap_list: 在线测试要进行特征提取的pcap包路径列表(里面只能包含一个)</span></span><br><span class="line"><span class="string">    :param norm_pcap_list: 训练和离线测试要进行特征提取的全正常流量pcap包路径列表(至少包含一个)</span></span><br><span class="line"><span class="string">    :param abnorm_pcap_list: 训练和离线测试要进行特征提取的全异常流量pcap包路径列表(至少包含一个)</span></span><br><span class="line"><span class="string">    :param csv_save_folder: 提取出的csv文件要保存的目录</span></span><br><span class="line"><span class="string">    :return: csv_save_path: 提取出的csv文件路径</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    time_now = time.strftime(<span class="string">"%Y%m%d-%H%M%S"</span>, time.localtime())</span><br><span class="line">    os.makedirs(csv_save_folder, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> mode_id <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">        print(<span class="string">'mode_id出错'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> mode_id == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">assert</span> len(pcap_list) == <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">'在线测试时pcap_list中只能包含一个pcap包'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">assert</span> len(norm_pcap_list) &gt; <span class="number">0</span> <span class="keyword">and</span> len(abnorm_pcap_list) &gt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">'需要同时包含正常和异常pcap包'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> mode_id == <span class="number">3</span>:</span><br><span class="line">        pcap_path = pcap_list[<span class="number">0</span>]</span><br><span class="line">        pcap_name = pcap_path.split(os.sep)[<span class="number">-1</span>].replace(<span class="string">'.pcap'</span>, <span class="string">''</span>)</span><br><span class="line">        cmd = <span class="string">'%s %s %s'</span> % (CIC_dfm, pcap_path, csv_save_folder)</span><br><span class="line">        <span class="comment"># 调CIC</span></span><br><span class="line">        p = subprocess.Popen(cmd, shell=<span class="literal">True</span>)</span><br><span class="line">        return_code = p.wait()</span><br><span class="line">        csv_path = os.path.join(csv_save_folder, pcap_name + <span class="string">'.pcap_Flow.csv'</span>)</span><br><span class="line">        df = pd.read_csv(csv_path, skipinitialspace=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> pcap_path <span class="keyword">in</span> norm_pcap_list:</span><br><span class="line">            pcap_name = pcap_path.split(os.sep)[<span class="number">-1</span>].replace(<span class="string">'.pcap'</span>, <span class="string">''</span>)</span><br><span class="line">            cmd = <span class="string">'%s %s %s'</span> % (CIC_dfm, pcap_path, csv_save_folder)</span><br><span class="line">            <span class="comment"># 调CIC</span></span><br><span class="line">            p = subprocess.Popen(cmd, shell=<span class="literal">True</span>)</span><br><span class="line">            return_code = p.wait()</span><br><span class="line">            csv_path = os.path.join(csv_save_folder, pcap_name + <span class="string">'.pcap_Flow.csv'</span>)</span><br><span class="line">            <span class="keyword">if</span> pcap_path == norm_pcap_list[<span class="number">0</span>]:</span><br><span class="line">                df_norm = pd.read_csv(csv_path, skipinitialspace=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp_df = pd.read_csv(csv_path, skipinitialspace=<span class="literal">True</span>)</span><br><span class="line">                df_norm = pd.concat([df_norm, temp_df], ignore_index=<span class="literal">True</span>)</span><br><span class="line">            df_norm[<span class="string">'Label'</span>] = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 删除中间结果</span></span><br><span class="line">            os.remove(csv_path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> pcap_path <span class="keyword">in</span> abnorm_pcap_list:</span><br><span class="line">            pcap_name = pcap_path.split(os.sep)[<span class="number">-1</span>].replace(<span class="string">'.pcap'</span>, <span class="string">''</span>)</span><br><span class="line">            cmd = <span class="string">'%s %s %s'</span> % (CIC_dfm, pcap_path, csv_save_folder)</span><br><span class="line">            <span class="comment"># 调CIC</span></span><br><span class="line">            p = subprocess.Popen(cmd, shell=<span class="literal">True</span>)</span><br><span class="line">            return_code = p.wait()</span><br><span class="line">            csv_path = os.path.join(csv_save_folder, pcap_name + <span class="string">'.pcap_Flow.csv'</span>)</span><br><span class="line">            <span class="keyword">if</span> pcap_path == abnorm_pcap_list[<span class="number">0</span>]:</span><br><span class="line">                df_abnorm = pd.read_csv(csv_path, skipinitialspace=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp_df = pd.read_csv(csv_path, skipinitialspace=<span class="literal">True</span>)</span><br><span class="line">                df_abnorm = pd.concat([df_abnorm, temp_df], ignore_index=<span class="literal">True</span>)</span><br><span class="line">            df_abnorm[<span class="string">'Label'</span>] = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 删除中间结果</span></span><br><span class="line">            os.remove(csv_path)</span><br><span class="line"></span><br><span class="line">        df = pd.concat([df_abnorm, df_norm], ignore_index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    csv_save_path = os.path.join(csv_save_folder, <span class="string">'%s.csv'</span> % time_now)</span><br><span class="line">    df.to_csv(csv_save_path, index=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> csv_save_path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pcap_list = [<span class="string">'/home/*/test1.pcap'</span>, <span class="string">'/home/*/test2.pcap'</span>, <span class="string">'/home/*/test3.pcap'</span>]</span><br><span class="line">    <span class="comment"># pcap_list = ['/home/*/test1.pcap']</span></span><br><span class="line">    csv_save_folder = <span class="string">'/home/*'</span></span><br><span class="line">    mode_id = <span class="number">1</span></span><br><span class="line">    _ = unsupervise_extract(mode_id, pcap_list, csv_save_folder)</span><br><span class="line"></span><br><span class="line">    norm_pcap_list = [<span class="string">'/home/*/test1.pcap'</span>, <span class="string">'/home/*/test3.pcap'</span>]</span><br><span class="line">    abnorm_pcap_list = [<span class="string">'/home/*/test2.pcap'</span>]</span><br><span class="line">    pcap_list = [<span class="string">'/home/*/test1.pcap'</span>]</span><br><span class="line">    mode_id = <span class="number">2</span></span><br><span class="line">    _ = supervise_extract(mode_id, pcap_list, norm_pcap_list, abnorm_pcap_list, csv_save_folder)</span><br><span class="line"></span><br><span class="line">    print(_)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>CICFlowMeter</category>
      </categories>
      <tags>
        <tag>CICFlowMeter</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python程序打包成exe</title>
    <url>/python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E6%88%90exe/</url>
    <content><![CDATA[<p>记录帮表姐写了一个txt转xlsx，同时进行格式转换和合并去重的脚本，最后将其打包成exe过程中遇到的小问题</p>
<a id="more"></a>
<h3 id="格式转化">格式转化</h3>
<p>本身将有格式的txt转变为xlsx是没有难度的，只需要使用<code>pd.read_csv(txt_path, sep='\t', header=0)</code>即可轻松读入。</p>
<p>后续主要需要进行格式的变化，数据本身是一个对照试验，简单来说主要是两步：</p>
<ol type="1">
<li>根据已有列进行一个新列的计算，和一些格式上的修改</li>
<li>将现在延纵轴方向的concat转变为延横轴方向的concat，把一个6*41行的数据变成41行*6列（看图就懂了）</li>
</ol>
<p><img
src="https://zchsakura-blog.oss-cn-beijing.aliyuncs.com/202308072153783.png" /></p>
<p><img
src="https://zchsakura-blog.oss-cn-beijing.aliyuncs.com/202308072154838.png" /></p>
<p>第二点主要思路就是先在第一列上建立索引，然后通过遍历索引一次取41行数据，不断地添加到一个空的dataframe上去。直接看代码吧。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_res</span><span class="params">(df)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> df[<span class="string">'Allele 1'</span>] <span class="keyword">is</span> <span class="keyword">not</span> np.nan <span class="keyword">and</span> df[<span class="string">'Allele 2'</span>] <span class="keyword">is</span> <span class="keyword">not</span> np.nan:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">','</span>.join([str(df[<span class="string">'Allele 1'</span>]), str(df[<span class="string">'Allele 2'</span>])])</span><br><span class="line">    <span class="keyword">elif</span> df[<span class="string">'Allele 1'</span>] <span class="keyword">is</span> <span class="keyword">not</span> np.nan:</span><br><span class="line">        <span class="keyword">return</span> str(df[<span class="string">'Allele 1'</span>])</span><br><span class="line">    <span class="keyword">elif</span> df[<span class="string">'Allele 2'</span>] <span class="keyword">is</span> <span class="keyword">not</span> np.nan:</span><br><span class="line">        <span class="keyword">return</span> str(df[<span class="string">'Allele 2'</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'-'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_txt</span><span class="params">(txt_path)</span>:</span></span><br><span class="line">    df = pd.read_csv(txt_path, sep=<span class="string">'\t'</span>, header=<span class="number">0</span>)</span><br><span class="line">    df = df.drop(<span class="string">'Unnamed: 4'</span>, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    df[<span class="string">'res'</span>] = df.apply(get_res, axis=<span class="number">1</span>)</span><br><span class="line">    df = df.drop([<span class="string">'Allele 1'</span>, <span class="string">'Allele 2'</span>], axis=<span class="number">1</span>)</span><br><span class="line">    df = df.set_index(<span class="string">'Sample Name'</span>)</span><br><span class="line"></span><br><span class="line">    row_index = list(set(df.index.tolist()))</span><br><span class="line">    row_index.sort()</span><br><span class="line"></span><br><span class="line">    res_df = pd.DataFrame()</span><br><span class="line">    res_df[<span class="string">'Marker'</span>] = df.reset_index()[<span class="string">'Marker'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> row_index:</span><br><span class="line">        res_df[i] = df.loc[i, <span class="string">'res'</span>].reset_index()[<span class="string">'res'</span>]</span><br><span class="line"></span><br><span class="line">    res_df = res_df.dropna()</span><br><span class="line">    <span class="comment"># res_df.to_excel(os.path.basename(txt_path.replace('.txt', '.xlsx')), sheet_name='Sheet1', index=False)</span></span><br><span class="line">    <span class="keyword">return</span> res_df</span><br></pre></td></tr></table></figure>
<h3 id="打包成exe">打包成exe</h3>
<p>因为表姐那边不方便弄Python环境，他们也不太会用，所以我尝试直接将这个简单的脚本打包成exe。过程中遇到的最大的问题就是获取exe所在路径。</p>
<p>有很多获取路径的方法会获取到C盘中地某个临时文件，这可能和Python打包有关系，也可能和exe本身机制有关系。</p>
<p>我们需要使用<code>os.path.dirname(os.path.realpath(sys.argv[0]))</code>这行代码，这行代码是可以成功获取到exe文件所在目录了，其他什么<code>os.path.dirname(os.path.abspath(__file__))</code>这种亲测都是不行的。</p>
<p>最后附上完整代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_res</span><span class="params">(df)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> df[<span class="string">'Allele 1'</span>] <span class="keyword">is</span> <span class="keyword">not</span> np.nan <span class="keyword">and</span> df[<span class="string">'Allele 2'</span>] <span class="keyword">is</span> <span class="keyword">not</span> np.nan:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">','</span>.join([str(df[<span class="string">'Allele 1'</span>]), str(df[<span class="string">'Allele 2'</span>])])</span><br><span class="line">    <span class="keyword">elif</span> df[<span class="string">'Allele 1'</span>] <span class="keyword">is</span> <span class="keyword">not</span> np.nan:</span><br><span class="line">        <span class="keyword">return</span> str(df[<span class="string">'Allele 1'</span>])</span><br><span class="line">    <span class="keyword">elif</span> df[<span class="string">'Allele 2'</span>] <span class="keyword">is</span> <span class="keyword">not</span> np.nan:</span><br><span class="line">        <span class="keyword">return</span> str(df[<span class="string">'Allele 2'</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'-'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_txt</span><span class="params">(txt_path)</span>:</span></span><br><span class="line">    df = pd.read_csv(txt_path, sep=<span class="string">'\t'</span>, header=<span class="number">0</span>)</span><br><span class="line">    df = df.drop(<span class="string">'Unnamed: 4'</span>, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    df[<span class="string">'res'</span>] = df.apply(get_res, axis=<span class="number">1</span>)</span><br><span class="line">    df = df.drop([<span class="string">'Allele 1'</span>, <span class="string">'Allele 2'</span>], axis=<span class="number">1</span>)</span><br><span class="line">    df = df.set_index(<span class="string">'Sample Name'</span>)</span><br><span class="line"></span><br><span class="line">    row_index = list(set(df.index.tolist()))</span><br><span class="line">    row_index.sort()</span><br><span class="line"></span><br><span class="line">    res_df = pd.DataFrame()</span><br><span class="line">    res_df[<span class="string">'Marker'</span>] = df.reset_index()[<span class="string">'Marker'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> row_index:</span><br><span class="line">        res_df[i] = df.loc[i, <span class="string">'res'</span>].reset_index()[<span class="string">'res'</span>]</span><br><span class="line"></span><br><span class="line">    res_df = res_df.dropna()</span><br><span class="line">    <span class="comment"># res_df.to_excel(os.path.basename(txt_path.replace('.txt', '.xlsx')), sheet_name='Sheet1', index=False)</span></span><br><span class="line">    <span class="keyword">return</span> res_df</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    input_list = glob.glob(os.path.join(os.path.dirname(os.path.realpath(sys.argv[<span class="number">0</span>])), <span class="string">'input/*.txt'</span>))</span><br><span class="line">    print(<span class="string">'在跑啦'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> len(input_list) == <span class="number">2</span></span><br><span class="line">    print(<span class="string">'输入数据:'</span>, input_list[<span class="number">0</span>], input_list[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    df1 = format_txt(input_list[<span class="number">0</span>])</span><br><span class="line">    df2 = format_txt(input_list[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># df1 = format_txt(r'E:\研究生作业\1496_1499_1500.txt')</span></span><br><span class="line">    <span class="comment"># df2 = format_txt(r'E:\研究生作业\SZ-2023080401-ZC-GoldenEye22NC_Allele Table.txt')</span></span><br><span class="line"></span><br><span class="line">    df1 = df1.append(df2, ignore_index=<span class="literal">True</span>)</span><br><span class="line">    df1 = df1.drop_duplicates()</span><br><span class="line">    save_path = os.path.join(os.path.dirname(os.path.realpath(sys.argv[<span class="number">0</span>])), <span class="string">'output'</span>)</span><br><span class="line">    os.makedirs(save_path, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    df1.to_excel(os.path.join(save_path, <span class="string">'合并_%s.xlsx'</span> % datetime.datetime.now().strftime(<span class="string">'%Y_%m_%d_%H_%M_%S'</span>)),</span><br><span class="line">                 sheet_name=<span class="string">'Sheet1'</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>对了，打包工具使用的是Pyinstaller，这里也简单记录下Pyinstaller最简单的使用方式。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pyinstaller -F test.py</span><br></pre></td></tr></table></figure>
<p>使用这个命令可以将单个py文件打包成exe，多个py我还没有试过，这个应该是需要在有Python包的虚拟环境中去运行的，我是切到相应的虚拟环境中执行的，最后生成一个dist里面有个exe，盲猜不进合适的环境会出问题。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>EXE</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy中的yield请求未被正常抛出</title>
    <url>/scrapy%E4%B8%AD%E7%9A%84yield%E8%AF%B7%E6%B1%82%E6%9C%AA%E8%A2%AB%E6%AD%A3%E5%B8%B8%E6%8A%9B%E5%87%BA/</url>
    <content><![CDATA[<p>有一次爬医书的时候有一个函数不会被执行，找了半天没有找到问题所在，只知道是上一个<code>scrapy.Request</code>执行完并没有正确的触发接下来的函数，根据查找的信息应该是由于scrapy自带的去重机制将我的请求给抛弃了。</p>
<a id="more"></a>
<p>参考：https://blog.csdn.net/qq_32670879/article/details/85042464</p>
<p>问题来源：我在爬取医书的时候因为是书籍所以存在章节信息，在书籍的介绍页既有书籍简介，又有目录，我想要写两个函数来分别处理，当书籍简介获取完之后要进入获取目录信息函数的时候不能正确进入。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20200509152400.png"
alt="image-20200509152349586" />
<figcaption aria-hidden="true">image-20200509152349586</figcaption>
</figure>
<p>经过在网上查找信息发现应该是我调用下面函数的时候，因为又请求了之前请求过的<code>response.url</code>导致scrapy自带的去重机制将本次请求全部拦截了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span> scrapy.Request(response.url, callback=self.chapterList, meta=&#123;<span class="string">'bookName'</span>: item[<span class="string">'name'</span>]&#125;)</span><br></pre></td></tr></table></figure>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20200509153757.png"
alt="20181216232557785" />
<figcaption aria-hidden="true">20181216232557785</figcaption>
</figure>
<p>解决方法：在函数参数中加入<code>dont_filter=True</code>，结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span> scrapy.Request(response.url, callback=self.chapterList, meta=&#123;<span class="string">'bookName'</span>: item[<span class="string">'name'</span>]&#125;, dont_filter=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh 22 time out</title>
    <url>/ssh-22-time-out/</url>
    <content><![CDATA[<p>这里记录一下git使用过程中总是碰到的一个错误，<code>ssh: connect to host github.com port 22: Connection timed out</code>。</p>
<a id="more"></a>
<p>我碰过的这个错误基本是由两种原因引起的，一种是公钥没配置好，另一种就是网络原因。</p>
<p>这里主要记录下网络原因引起的time out该怎么办。</p>
<h3 id="检测">检测</h3>
<p><code>ssh -T git@github.com</code></p>
<p>如果出现：You’ve successfully
authenticated，那么连接成功可以使用了。如果出现：ssh: connect to host
github.com port 22: Connection timed out，就说明连接超时。</p>
<p>连接失败后，可以同样试试<code>ssh -T -p 443 git@github.com</code>，检查是否有异常。</p>
<p>如果加上443之后能够success的话基本就是网络问题，我们需要使用443端口去连接git。</p>
<h3 id="配置">配置</h3>
<ol type="1">
<li>cd ~/.ssh</li>
<li>配置或新建config文件</li>
<li>编辑文件内容并保存退出</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User 你的邮箱</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>使用<code>ssh -T git@github.com</code>测试下</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
        <category>服务器配置</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>xpath常用相关</title>
    <url>/xpath%E5%B8%B8%E7%94%A8%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>xpath常用语法</p>
<a id="more"></a>
<h3 id="匹配文本">1.匹配文本</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[contains(text(),<span class="string">"百度搜索"</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="匹配属性">2.匹配属性</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input[contains(@name,<span class="string">'na'</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="节点关系">3.节点关系</h3>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">轴名称</th>
<th style="text-align: left;">结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">ancestor</td>
<td
style="text-align: left;">选取当前节点的所有先辈（父、祖父等）。</td>
</tr>
<tr class="even">
<td style="text-align: left;">ancestor-or-self</td>
<td
style="text-align: left;">选取当前节点的所有先辈（父、祖父等）以及当前节点本身。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">attribute</td>
<td style="text-align: left;">选取当前节点的所有属性。</td>
</tr>
<tr class="even">
<td style="text-align: left;">child</td>
<td style="text-align: left;">选取当前节点的所有子元素。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">descendant</td>
<td
style="text-align: left;">选取当前节点的所有后代元素（子、孙等）。</td>
</tr>
<tr class="even">
<td style="text-align: left;">descendant-or-self</td>
<td
style="text-align: left;">选取当前节点的所有后代元素（子、孙等）以及当前节点本身。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">following</td>
<td
style="text-align: left;">选取文档中当前节点的结束标签之后的所有节点。</td>
</tr>
<tr class="even">
<td style="text-align: left;">following-sibling</td>
<td style="text-align: left;">选取当前节点之后的所有兄弟节点</td>
</tr>
<tr class="odd">
<td style="text-align: left;">namespace</td>
<td style="text-align: left;">选取当前节点的所有命名空间节点。</td>
</tr>
<tr class="even">
<td style="text-align: left;">parent</td>
<td style="text-align: left;">选取当前节点的父节点。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">preceding</td>
<td
style="text-align: left;">选取文档中当前节点的开始标签之前的所有节点。</td>
</tr>
<tr class="even">
<td style="text-align: left;">preceding-sibling</td>
<td style="text-align: left;">选取当前节点之前的所有同级节点。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">self</td>
<td style="text-align: left;">选取当前节点。</td>
</tr>
</tbody>
</table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"1"</span> <span class="attr">href</span>=<span class="string">"www.baidu.com"</span>&gt;</span>我是第1个a标签<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"2"</span> <span class="attr">href</span>=<span class="string">"www.baidu.com"</span>&gt;</span>我是第2个a标签<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"3"</span> <span class="attr">href</span>=<span class="string">"www.baidu.com"</span>&gt;</span>我是第3个a标签<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"4"</span> <span class="attr">href</span>=<span class="string">"www.baidu.com"</span>&gt;</span>我是第4个a标签<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"5"</span> <span class="attr">href</span>=<span class="string">"www.baidu.com"</span>&gt;</span>我是第5个a标签<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>获取第三个a标签的下一个a标签："//a<span class="citation"
data-cites="id">[@id='3']</span>/following-sibling::a[1]"</p>
<p>获取第三个a标签后面的第N个标签："//a<span class="citation"
data-cites="id">[@id='3']</span>/following-sibling::*[N]"</p>
<p>获取第三个a标签的上一个a标签："//a<span class="citation"
data-cites="id">[@id='3']</span>/preceding-sibling::a[1]"</p>
<p>获取第三个a标签的前面的第N个标签："//a<span class="citation"
data-cites="id">[@id='3']</span>/preceding-sibling::*[N]"</p>
<p>获取第三个a标签的父标签："//a<span class="citation"
data-cites="id">[@id=='3']</span>/.."</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>从考研到995</title>
    <url>/%E4%BB%8E%E8%80%83%E7%A0%94%E5%88%B0995/</url>
    <content><![CDATA[<p>这么久都没更博了，主要是之前在准备参加考研，9月底突然得知因为疫情扩保把本弟弟保上了，说实话运气很好，属实要好好感谢学校，只要学校够努力就能抬我一手。今天保研尘埃落定了虽然直接开始995，但是心理压力没那么大了，还要学习新的知识，肯定要多记录记录。</p>
<a id="more"></a>
<h3 id="碎碎念">碎碎念</h3>
<p>今天是十推的第一天，保了本院，复试通知已经接受了，还在等待录取通知，昨晚填系统睡得也晚，今早起的也早这会儿困得很，也没办法学习，就来记录一下。</p>
<p>本来我的成绩就在保研边缘，只要能拿到一个省奖就能保研了，寒假和大三也参加了几个比赛，说实话一言难尽，有些人确实不是那么靠谱，也怪我之前确实不懂，也没有去深入的了解，以为跟着老师就对了，谁能想到......</p>
<p>今年因为疫情，国家为了不让毕业生在社会上乱晃，也对研究生进行了扩招，保研名额也就进行了扩招，说实话我本来都没想着能扩到我，没竞赛加分属实太弟弟了，都是意外惊喜。有时候你做好自己的事，幸福可能就那么来了。</p>
<p>因为知道保研的时间比较晚，之前的夏令营也没有参加预推免很多学校也结束了，所以可选择的空间并不大，加上之前一直在学数学，专业课确实没看，代码也很久没写了，尤其是很多学校还要求用C，因为之前做项目都用的Python，所以C也忘光了，准备时间确实十分有限。最后还是选择了本院，索性找到了一个靠谱的导师，手里也有很好的项目，反正轻松是不可能轻松的，995的快乐生活我来了。</p>
<p>保研了确实要轻松一些，可能995在时间上和考研学习差不多，但是毕竟没有那么大的压力，而且学这些新知识属实比学高数有意思多了，虽然数学肯定是要用，但是不用背啊，只要能应用就行了，我感觉研究生很大的一个阻碍还是英语，我英语属实太辣鸡了，不去冲外校英语也是很重要的原因之一。</p>
<p>因为上一个免费领的服务器到期了，换了一个学生服务器，今早把博客又弄了一下，还好不用怎么大操作。</p>
<p>都十点多了，我的待录取通知怎么还没来啊啊啊啊啊啊~~~~~~~~~~~</p>
<h3 id="小经验">小经验</h3>
<p>以下都是个人经验，不一定适用于每个学校每个人。</p>
<p>保研除了平时的课程之外，竞赛真的很重要，如果真的有保研意向一定要早准备竞赛，大二怎么都要开始了吧，还是要早做了解，有一些竞赛确实是比较好拿奖的，找几个靠谱的队友，再找个靠谱的指导老师，还是比较有希望的。</p>
<p>如果英语确实不好，像我一样保研了六级都没过估计也没几个人了，还好学校不卡这个。如果真的想要保研，还是最好过一下六级，能多高就刷多高，毕竟考试还是有应试技巧的。我之前是不知道能保研，大二也没太关注，大三发现成绩还可以，在边缘但是疫情了也没办法参加六级，所以参加了九月的那场，说实话突击了一下，现在也不知道咋样。</p>
<p>保研面试的英语确实是可以准备一下的，尽早准备，怎么都要准备至少一个礼拜吧，主要就是英文自我介绍，还有一些常见面试问题，这些网上都能找到很多教程，我英语也就是个弟弟，就不教你们了。可以面试前找朋友开个视频会议试一试。我找的同学他英语是比较好的，虽然肯定比不上母语，但是是开口交流不用准备也能随便进行的下去的那种，比我是强的太多了。我们第一次试他直接给我问沉默了，他说的我都能听懂，但我属实开不了口，感觉直接像是被沉默，说不出话。还是要找人锻炼一下下，确实好一点。</p>
<p>又是半个小时过去了，我的待录取通知还没来~~~~~~~~~~~</p>
<p>希望能在中午吃饭前来，不想把电脑搬回去，电脑像个板砖，太沉了...</p>
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
  </entry>
  <entry>
    <title>创建python虚拟环境</title>
    <url>/%E5%88%9B%E5%BB%BApython%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>如果在一台电脑上，想开发多个不同的项目， 需要用到同一个包的不同版本，
如果不使用虚拟环境， 在同一个目录下安装或者更新，
新版本会覆盖以前的版本， 其它的项目就无法运行了。</p>
<a id="more"></a>
<h2 id="安装虚拟环境">1.安装虚拟环境</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip install virtualenv</span><br><span class="line">sudo pip install virtualenvwrapper</span><br></pre></td></tr></table></figure>
<p>virtualenvwrapper类似于一个虚拟环境管理工具会比原生的virtualenv方便一些</p>
<p>安装完虚拟环境如果找不到mkvirtualenv命令，须配置环境变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1、在~（家目录）下创建目录用来存放虚拟环境</span><br><span class="line">mkdir .virtualenvs</span><br><span class="line"></span><br><span class="line"># 2、打开~&#x2F;.bashrc文件，并添加如下：</span><br><span class="line">export WORKON_HOME&#x3D;$HOME&#x2F;.virtualenvs</span><br><span class="line">source &#x2F;usr&#x2F;local&#x2F;bin&#x2F;virtualenvwrapper.sh</span><br><span class="line"></span><br><span class="line"># 3、运行</span><br><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>
<h2 id="创建虚拟环境">2.创建虚拟环境</h2>
<p>如果不指定Python版本，默认安装的是Python2的虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在python2中，创建虚拟环境</span><br><span class="line">mkvirtualenv 虚拟环境名称</span><br><span class="line">例 ：</span><br><span class="line">mkvirtualenv py_flask</span><br></pre></td></tr></table></figure>
<p>如果想要指定python版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkvirtualenv -p python3 虚拟环境名称</span><br><span class="line">例 ：</span><br><span class="line">mkvirtualenv -p python3 py3_flask</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>所有的虚拟环境都位于/~/下的隐藏目录.virtualenvs下</p>
<h2 id="使用虚拟环境">3.使用虚拟环境</h2>
<h3 id="查看已有虚拟环境">3.1查看已有虚拟环境</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">workon</span><br></pre></td></tr></table></figure>
<h3 id="进入虚拟环境">3.2进入虚拟环境</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">workon 虚拟环境名称</span><br></pre></td></tr></table></figure>
<h3 id="退出虚拟环境">3.3退出虚拟环境</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deativate</span><br></pre></td></tr></table></figure>
<h3 id="删除虚拟环境">3.4删除虚拟环境</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先退出：deactivate</span><br><span class="line">再删除：rmvirtualenv py3_flask</span><br></pre></td></tr></table></figure>
<h2 id="虚拟环境工具包位置">4.虚拟环境工具包位置</h2>
<p>~/.virtualenvs/虚拟环境名称/lib/python3.5/site-packages</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>虚拟环境</tag>
      </tags>
  </entry>
  <entry>
    <title>图片转视频</title>
    <url>/%E5%9B%BE%E7%89%87%E8%BD%AC%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<p>使用python的cv2库完成图片转视频，解决灰度图片和中文路径问题</p>
<a id="more"></a>
<p>先上代码</p>
<figure class="highlight python"><figcaption><span>img2video.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">img_array = []</span><br><span class="line"><span class="comment"># 取图片的时候排序</span></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> sorted(glob.glob(<span class="string">r'***\0X1AA30623C1AE4641\*.png'</span>), key=<span class="keyword">lambda</span> x: int(x.split(<span class="string">'.'</span>)[<span class="number">0</span>].split(<span class="string">'_'</span>)[<span class="number">-1</span>])):</span><br><span class="line">	<span class="comment"># 注意读图方式</span></span><br><span class="line">    img = cv2.imdecode(np.fromfile(filename, dtype=np.uint8), <span class="number">1</span>)</span><br><span class="line">    img_array.append(img)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">height, width, channel = img_array[<span class="number">0</span>].shape</span><br><span class="line">size = (width, height)</span><br><span class="line"></span><br><span class="line"><span class="comment"># avi：视频类型，mp4也可以</span></span><br><span class="line"><span class="comment"># cv2.VideoWriter_fourcc(*'I420')：编码格式</span></span><br><span class="line"><span class="comment"># 50：视频帧率</span></span><br><span class="line"><span class="comment"># size:视频中图片大小</span></span><br><span class="line">out = cv2.VideoWriter(<span class="string">r'***\0X1AA30623C1AE4641_predict.avi'</span>,</span><br><span class="line">                      cv2.VideoWriter_fourcc(*<span class="string">'I420'</span>),</span><br><span class="line">                      <span class="number">50</span>, size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> img <span class="keyword">in</span> img_array:</span><br><span class="line">    out.write(img)</span><br><span class="line"></span><br><span class="line">out.release()</span><br></pre></td></tr></table></figure>
<h3 id="中文路径">中文路径</h3>
<p>cv2在读取带有中文路径图片的时候不能直接使用<code>cv2.imread()</code>，读出来是None。需要使用<code>cv2.imdecode(np.fromfile(filepath, dtype=np.uint8), -1)</code>，注意后面的数字带有具体含义，下面将灰度图的时候说明。</p>
<h3 id="灰度图片">灰度图片</h3>
<p><code>cv2.imdecode(np.fromfile(filepath, dtype=np.uint8), flag=-1)</code></p>
<p>此处的<strong>flag</strong>带有明确含义：</p>
<ul>
<li>flag = -1, 8位深度，原通道，此时读取的是原来的图像</li>
<li>flag = 0, 8位深度，1通道，读取的是灰度图</li>
<li>flag = 1， 8位深度，3通道彩图</li>
<li>flag = 2， 原深度， 灰度</li>
<li>flag = 3，原深度，彩图</li>
<li>flag = 4， 8位深度， 3通道彩图</li>
</ul>
<p>我最终的结果是一张灰度图，需要读成三通道彩图才能进行保存，注意cv2读出来的是BGR而不是RGB，只要中途不经过PIL之类的转化，直接再<code>cv2.VideoWriter</code>的话其实不影响。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>处理dm字段大小写</title>
    <url>/%E5%A4%84%E7%90%86dm%E5%AD%97%E6%AE%B5%E5%A4%A7%E5%B0%8F%E5%86%99/</url>
    <content><![CDATA[<p>记录下使用达梦数据库遇到的大小写问题，达梦数据库在建库的时候可以选择不区分大小写，默认是选择区分的，我看网上的博客很多都建议取消区分大小写，但是我对接的用户这边建库的时候没有取消，然后dm好像有把字段名全部大写，就算他们建表时写的小写，没有仔细研究，我这里主要只是做了有无大写判断。</p>
<a id="more"></a>
<h4 id="cursor.fetchall">cursor.fetchall()</h4>
<p>对从数据库中获得的列数较少的数据实际上都不用判断里面字段名是大写还是小写，可以直接用try、expect来处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    folder_path = save_folder[<span class="number">0</span>][<span class="string">'SAVE_FOLDER'</span>]</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    folder_path = save_folder[<span class="number">0</span>][<span class="string">'SAVE_FOLDER'</span>.lower()]</span><br></pre></td></tr></table></figure>
<h4 id="df-pd.dataframe.from_recordsdb_data">df =
pd.DataFrame.from_records(db_data)</h4>
<p>为了对数据进行更好的处理，在Python中经常会使用到pandas来处理数据，当我们在<code>dmPython.connect</code>中设置了<code>cursorclass=dmPython.DictCursor</code>时，我们<code>cursor.fetchall()</code>回来的数据会是一个list包裹若干dict的形式，每一个dict是数据库中的一行，dict中的key就是数据表中的列名。此时我们可以采用<code>pd.DataFrame.from_records()</code>将这种list直接变为pandas的DataFrame格式来进行处理。</p>
<p>这里我需要将数据库中取出来的数据先修改类型，使用<code>df.astype()</code>可以直接修改df的列数据类型，这里需要用到一个dict来完成数据类型修改，dict的key是df的列名，value是要修改成的数据类型，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data_types_dict &#x3D; &#123;</span><br><span class="line">    &quot;time_start&quot;: float,</span><br><span class="line">    &quot;ip_client&quot;: str,</span><br><span class="line">    &quot;byte_up&quot;: float,</span><br><span class="line">    &quot;byte_dn&quot;: float</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就涉及到判断从数据库中取出来的数据字段名是大写还是小写，可以用以下代码完成数据修改，主要思路就是当我判断数据库字段名是大写的时候把我的dict的key也改为大写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if &#39;time_start&#39; in df.columns.tolist():</span><br><span class="line">    df &#x3D; df.astype(data_types_dict)</span><br><span class="line">elif &#39;time_start&#39;.upper() in df.columns.tolist():</span><br><span class="line">    data_types_dict_upper &#x3D; &#123;&#125;</span><br><span class="line">    for i, j in data_types_dict.items():</span><br><span class="line">        data_types_dict_upper[i.upper()] &#x3D; j</span><br><span class="line">    # print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;, data_types_dict_upper)</span><br><span class="line">    df &#x3D; df.astype(data_types_dict_upper)</span><br></pre></td></tr></table></figure>
<p>如果需要进行列名修改也是类似的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rename_col &#x3D; &#123;</span><br><span class="line">    &#39;time_start&#39;: &#39;time&#39;,</span><br><span class="line">    &#39;ip_client&#39;: &#39;sIP&#39;,</span><br><span class="line">    &#39;byte_up&#39;: &#39;outlen&#39;,</span><br><span class="line">    &#39;byte_dn&#39;: &#39;inlen&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if &#39;time_start&#39; in df.columns.tolist():</span><br><span class="line">    df &#x3D; df.rename(columns&#x3D;rename_col)</span><br><span class="line">elif &#39;time_start&#39;.upper() in df.columns.tolist():</span><br><span class="line">    rename_col_upper &#x3D; &#123;&#125;</span><br><span class="line">    for i, j in rename_col.items():</span><br><span class="line">        rename_col_upper[i.upper()] &#x3D; j</span><br><span class="line">    # print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;, rename_col_upper)</span><br><span class="line">    df &#x3D; df.rename(columns&#x3D;rename_col_upper)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>达梦</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>达梦</tag>
      </tags>
  </entry>
  <entry>
    <title>多台电脑同步博客</title>
    <url>/%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>记录一下在多台电脑上同时写博客时候的同步问题</p>
<p><a href="https://www.zhihu.com/question/23934523" target="_blank" rel="noopener">参考</a></p>
<a id="more"></a>
<h3 id="环境安装">环境安装</h3>
<h4 id="nodejs">nodejs</h4>
<p>首先在自己的电脑上安装 Node.js，下载地址：<a
href="https://nodejs.org/zh-cn/download/">node.js</a></p>
<p>建议下载nodejs
14以下的版本，14以上的版本和一些老版的hexo不兼容，会报错</p>
<h4 id="hexo">hexo</h4>
<p>使用如下命令安装hexo，-g可以全局安装，在所有文件夹都能使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h3 id="git同步">git同步</h3>
<p>我这里默认已经至少在一个电脑上配置好博客站点信息了，就不写怎么配置站点信息了，直接写如何在git上新建分支存放hexo源码</p>
<p>在博客根目录下在git bash中使用以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git checkout -b source</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &quot;init blog&quot;</span><br><span class="line">git remote add origin git@github.com:&#123;username&#125;&#x2F;&#123;username&#125;.github.io.git</span><br><span class="line">git push origin source</span><br></pre></td></tr></table></figure>
<p>如果是在第二台电脑上要拉取的话就新建一个博客文件夹使用init之后将clone下来的文件放到博客文件夹里再执行后续操作就好了</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>基于redis使用scrapy下载中间件实现简单的增量爬虫</title>
    <url>/%E5%9F%BA%E4%BA%8Eredis%E4%BD%BF%E7%94%A8scrapy%E4%B8%8B%E8%BD%BD%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%A2%9E%E9%87%8F%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<p>在爬虫中有一种很重要的操作就是增量爬取，scrapy自带的管道中的去重只能实现该次爬取链接的去重，并不能实现对过往爬取数据的去重，所以选择使用redis来实现增量爬取，这也是大家现在使用较多的方法</p>
<a id="more"></a>
<p>参考https://www.jianshu.com/p/f03479b9222d</p>
<h1 id="官方去重">1.官方去重</h1>
<p>上面提起过，官方文档中的在管道里预设了去重模块，但只能在本次爬取内容中去重，无法对比以往爬取的数据。</p>
<figure class="highlight python"><figcaption><span>官方去重DuplicatesPipeline</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuplicatesPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.url_seen = set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> item[<span class="string">'art_url'</span>] <span class="keyword">in</span> self.url_seen: <span class="comment">#这里替换成你的item['#']</span></span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">"Duplicate item found: %s"</span> % item)</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.url_seen.add(item[<span class="string">'art_url'</span>]) <span class="comment">#这里替换成你的item['#']</span></span><br><span class="line">            <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>
<p>可以看出官方自带的DuplicatesPipeline管道中间件没办法完成我们所需要的增量爬取（对比曾经爬过的内容而不只是本次）</p>
<h1 id="使用管道中间件">2.使用管道中间件</h1>
<p>我在网上找到的大部分方法都是在管道中间件中通过使用redis实现了简单的增量爬取，原理就是在redis中存储之前爬虫爬取过的页面url，然后item进入管道的时候判断这个item对应的url在不在redis里，如果在说明爬过，把这个item丢弃；如果不在就继续下一步。</p>
<p>但是这里并没有解决页面url没变但是页面内容发生了变化的情况，如果要解决这个问题那么还应该将item内容编成md5编码，然后对比url的同时对比md5编码，url相同md5不同就覆盖掉原来的。但是我本次并没有实现这个功能，这个功能只适用于内容会发生变化的详情页，一般都用不上，只是提出来解决方法。</p>
<figure class="highlight python"><figcaption><span>pipelines.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  <span class="comment">#用来读MySQL</span></span><br><span class="line"><span class="keyword">import</span> redis </span><br><span class="line">redis_db = redis.Redis(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>, db=<span class="number">4</span>) <span class="comment">#连接redis，相当于MySQL的conn</span></span><br><span class="line">redis_data_dict = <span class="string">"f_url"</span>  <span class="comment">#key的名字，写什么都可以，这里的key相当于字典名称，而不是key值。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuplicatesPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    conn = mysql.connector.connect(user = <span class="string">'root'</span>, password=<span class="string">'yourpassword'</span>, database=<span class="string">'dbname'</span>, charset=<span class="string">'utf8'</span>)    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        redis_db.flushdb() <span class="comment">#删除全部key，保证key为0，不然多次运行时候hlen不等于0，刚开始这里调试的时候经常出错。</span></span><br><span class="line">        <span class="keyword">if</span> redis_db.hlen(redis_data_dict) == <span class="number">0</span>: <span class="comment">#</span></span><br><span class="line">            sql = <span class="string">"SELECT url FROM your_table_name;"</span>  <span class="comment">#从你的MySQL里提数据，我这里取url来去重。</span></span><br><span class="line">            df = pd.read_sql(sql, self.conn) <span class="comment">#读MySQL数据</span></span><br><span class="line">            <span class="keyword">for</span> url <span class="keyword">in</span> df[<span class="string">'url'</span>].get_values(): <span class="comment">#把每一条的值写入key的字段里</span></span><br><span class="line">                redis_db.hset(redis_data_dict, url, <span class="number">0</span>) <span class="comment">#把key字段的值都设为0，你要设成什么都可以，因为后面对比的是字段，而不是值。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">    	<span class="keyword">if</span> redis_db.hexists(redis_data_dict, item[<span class="string">'url'</span>]): <span class="comment">#取item里的url和key里的字段对比，看是否存在，存在就丢掉这个item。不存在返回item给后面的函数处理</span></span><br><span class="line">             <span class="keyword">raise</span> DropItem(<span class="string">"Duplicate item found: %s"</span> % item)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>
<p>注意要将新写的管道中间件在setting中注册：</p>
<figure class="highlight diff"><figcaption><span>setting.py</span></figcaption><table><tr><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">	'shaoerkepu.pipelines.ShaoerkepuPipeline': 300,</span><br><span class="line"><span class="addition">+	'shaoerkepu.pipelines.DuplicatesPipeline': 200,</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要使用reids中的hash类型，原因是速度，但是为什么速度快俺也不懂，没有深入了解过。个人感觉这里的hash其实有点像是字典，redis_db.hset(redis_data_dict,
url,
0)，这里面redis_data_dict类似字典名，然后url是key，0是value。一个redis_data_dict里面有很多对key，value。这里由于我们只需要使用url作为key所以所有的value都写了0。详细的python操作redis可以看我的另一篇博客。</p>
<h1 id="使用下载中间件">3.使用下载中间件</h1>
<p>上面介绍了大部分去重工作都在管道中间件中实现，如果涉及到内容的去重也就是md5那么就必须在管道中间件中实现，但是如果只涉及到对url的判断我觉得可以在下载中间件中实现，这样可以省去更多的时间（理论上应该是这样的吧，毕竟下载中间件在request的时候就起作用，管道在最后面才起作用）。</p>
<figure class="highlight python"><figcaption><span>middlewares.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> signals</span><br><span class="line"><span class="keyword">from</span> scrapy.exceptions <span class="keyword">import</span> IgnoreRequest</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">redis_db = redis.Redis(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>, db=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IngoreRequestMiddleware</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></span><br><span class="line">        <span class="comment"># 通过这一行代码实现下载中间件的自定义，不可能每一个请求都调用该中间件，我们是多层爬虫，会导致第一层就被抛弃，到不了详情页</span></span><br><span class="line">        <span class="keyword">if</span> request.meta.get(<span class="string">'middleware'</span>) == <span class="string">'IngoreRequestMiddleware'</span>:</span><br><span class="line">            <span class="keyword">if</span> redis_db.hexists(<span class="string">'urls'</span>, request.url):</span><br><span class="line">                <span class="comment"># 调用异常抛弃request</span></span><br><span class="line">                <span class="keyword">raise</span> IgnoreRequest(<span class="string">"IgnoreRequest : %s"</span> % request.url)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                redis_db.hset(<span class="string">'urls'</span>, request.url, <span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 返回None进行接下来的操作</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>注意要将新写的下载中间件在setting中注册：</p>
<figure class="highlight diff"><figcaption><span>settings.py</span></figcaption><table><tr><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">#    'shaoerkepu.middlewares.ShaoerkepuDownloaderMiddleware': 543,</span><br><span class="line"><span class="addition">+   'shaoerkepu.middlewares.IngoreRequestMiddleware': 543,</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>redis</tag>
        <tag>scrapy</tag>
        <tag>增量爬取</tag>
      </tags>
  </entry>
  <entry>
    <title>将flask部署到Ubuntu服务器上</title>
    <url>/%E5%B0%86flask%E9%83%A8%E7%BD%B2%E5%88%B0Ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/</url>
    <content><![CDATA[<p>我们做的项目最终都是要跑在服务器上的，我们不可能在服务器上一直跑着我们的Flask程序，而且程序也可能因为某些错误而挂掉，我们需要保证它的可用性，这篇文章就是我根据别人的<a
href="https://www.cnblogs.com/Ray-liang/p/4173923.html">Flask部署教程</a>总结出来的东西还有几个特别需要注意的小坑。</p>
<a id="more"></a>
<p>总体部署方案是：</p>
<ul>
<li><p>Web 服务器采用 uwsgi host Flask</p></li>
<li><p>用 Supervisor 引用 uwsgi 作常规启动服务</p></li>
<li><p>基于 Nginx 作反向代理</p></li>
</ul>
<h1 id="安装python并创建虚拟环境">1.安装python并创建虚拟环境</h1>
<p>安装python的教程有很多也很简单这里就不再赘述了。</p>
<p>要说一下的是python的虚拟环境创建，大家可能都知道virtualenv，但是其实原生的virtualenv使用起来不是那么方便，所以我推荐使用virtualenvwrapper来管理我们的虚拟环境。具体操作可以参考我的另一篇文章<a href="/%E5%88%9B%E5%BB%BApython%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/" title="[创建python虚拟环境]">[创建python虚拟环境]</a>。</p>
<h1 id="安装-uwsgi">2.安装 uWSGI</h1>
<p>安装uwsgi还是比较简单的，记得进入相应的虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(venv)my_flask root$ pip install uwsgi</span><br></pre></td></tr></table></figure>
<p>应该是秒装，安装完我们先不管他，后面再来配置他。</p>
<h1 id="安装flask">3.安装Flask</h1>
<p>我是用清单文件一次性安装Flask和他的相关依赖的，这样会更快。我的引用清单是这样的：</p>
<figure class="highlight plain"><figcaption><span>requirements.txt</span></figcaption><table><tr><td class="code"><pre><span class="line">Flask&#x3D;&#x3D;0.10.1</span><br><span class="line">Flask-Login&#x3D;&#x3D;0.2.11</span><br><span class="line">Flask-Mail&#x3D;&#x3D;0.9.1</span><br><span class="line">Flask-Moment&#x3D;&#x3D;0.4.0</span><br><span class="line">Flask-PageDown&#x3D;&#x3D;0.1.5</span><br><span class="line">Flask-SQLAlchemy&#x3D;&#x3D;2.0</span><br><span class="line">Flask-Script&#x3D;&#x3D;2.0.5</span><br><span class="line">Flask-WTF&#x3D;&#x3D;0.10.2</span><br><span class="line">Flask-Cache&#x3D;&#x3D;0.13.1</span><br><span class="line">Flask-Restless&#x3D;&#x3D;0.15.0</span><br><span class="line">Flask-Uploads&#x3D;&#x3D;0.1.3</span><br><span class="line">Jinja2&#x3D;&#x3D;2.7.3</span><br><span class="line">Mako&#x3D;&#x3D;1.0.0</span><br><span class="line">Markdown&#x3D;&#x3D;2.5.1</span><br><span class="line">MarkupSafe&#x3D;&#x3D;0.23</span><br><span class="line">SQLAlchemy&#x3D;&#x3D;0.9.8</span><br><span class="line">WTForms&#x3D;&#x3D;2.0.1</span><br><span class="line">Werkzeug&#x3D;&#x3D;0.9.6</span><br><span class="line">html5lib&#x3D;&#x3D;1.0b3</span><br><span class="line">itsdangerous&#x3D;&#x3D;0.24</span><br><span class="line">six&#x3D;&#x3D;1.8.0</span><br><span class="line">awesome-slugify&#x3D;&#x3D;1.6</span><br></pre></td></tr></table></figure>
<p>安装清单文件（记得在虚拟环境中操作）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(venv)my_flask root$ pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
<h1 id="项目文件">4.项目文件</h1>
<p>接下来就是上传
Flask的项目文件，之前我在各大的“转载专业户”里找了好多的资料，在这一步中大多只是在上面加个标准的Flask运行文件，虽说做个范例可以但说实在的这很让人迷惑，为什么？先看看代码吧：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"> </span><br><span class="line">app = Flask(__name__)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World!"</span></span><br></pre></td></tr></table></figure>
<p>生产环境内，谁会用这样的代码呢，这只是Flask
的最简入门范，我的Flask项目中 app
是被做在包内的，相信很多人都是这样做的，在包外我们采用 Flask Script
写一个 <code>manage.py</code> 文件
作为启动文件，这更方便于支持各种的项目</p>
<figure class="highlight python"><figcaption><span>manage.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_script <span class="keyword">import</span> Manager,Server</span><br><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line">manager = Manager(app)</span><br><span class="line">manager.add_command(<span class="string">'runserver'</span>,Server(host=<span class="string">'0.0.0.0'</span>,port=<span class="number">5000</span>,use_debugger=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    manager.run()</span><br></pre></td></tr></table></figure>
<p>此时如果我们使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>
<p>已经可以运行在本地
<code>http://127.0.0.1:5000</code>（记得开启5000端口）</p>
<h1 id="配置uwsgi">5.配置uWSGI</h1>
<p>uWSGI有两种启动方式，在这里我们选了通过配置文件启动的方法</p>
<p>在项目目录中新建<code>config.ini</code>，写入如下内容：</p>
<figure class="highlight python"><figcaption><span>config.ini</span></figcaption><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line"></span><br><span class="line"><span class="comment"># uwsgi 启动时所使用的地址与端口</span></span><br><span class="line"><span class="comment">#http=0.0.0.0:9102</span></span><br><span class="line">socket=<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">9102</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指向网站目录</span></span><br><span class="line">chdir = /var/www/flask</span><br><span class="line"></span><br><span class="line">home = /root/.virtualenvs/py3_flask</span><br><span class="line"></span><br><span class="line"><span class="comment"># python 启动程序文件</span></span><br><span class="line">wsgi-file = manage.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># python 程序内用以启动的 application 变量名</span></span><br><span class="line">callable = app</span><br><span class="line"></span><br><span class="line"><span class="comment">#daemonize=/www/wwwroot/www.chineseculture.xyz/flask_test/my_flask.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理器数</span></span><br><span class="line">processes = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程数</span></span><br><span class="line">threads = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这里的9102就是我们外网访问时服务器监听的地址，记得在控制台开启9102端口。</p>
<p>配置好端口之后，输入命令直接运行uWSGI：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uwsgi config.ini</span><br></pre></td></tr></table></figure>
<p>到此为止，我们已经可以通过<code>服务器公网ip:9102</code>访问你的Flask应用</p>
<p><strong>注意！！这里出现了第一个坑</strong></p>
<p>uwsgi
启动时所使用的地址与端口前面可以写http也可以写socket，当我们这里写http的时候我们是可以通过<code>服务器公网ip:9102</code>访问Flask的，但如果是socket则不可以。相应的我们后期使用nginx进行端口转发到uwsgi的时候我们这里必须是socket，如果是http将不成功。</p>
<p>OK， 此时已经正常启动 uwsgi 并将 Flask 项目载入其中了，ctrl+c
关闭程序。但这只是命令启动形式，要使其随同服务器启动并作为后台服务运行才是运营环境的实际所需要。因此接下来我们需要安装另一个工具来引导
uwsgi 。</p>
<h1 id="安装-supervisor">6.安装 Supervisor</h1>
<p><a
href="http://supervisord.org/configuration.html">Supervisor</a>可以同时启动多个应用，最重要的是，当某个应用Crash的时候，他可以自动重启该应用，保证可用性。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install supervisor</span><br></pre></td></tr></table></figure>
<p>Supervisor 的全局的配置文件位置在：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;supervisor&#x2F;supervisor.conf</span><br></pre></td></tr></table></figure>
<p>正常情况下我们并不需要去对其作出任何的改动，只需要添加一个新的 *.conf
文件放在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;supervisor&#x2F;conf.d&#x2F;</span><br></pre></td></tr></table></figure>
<p>下就可以，那么我们就新建立一个用于启动 my_flask 项目的 uwsgi 的
supervisor 配置 (命名为：flask_supervisor.conf)：</p>
<figure class="highlight python"><figcaption><span>flask_supervisor.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">[program:my_flask]</span><br><span class="line"><span class="comment"># 启动命令入口</span></span><br><span class="line">command=/root/.virtualenvs/py3_flask/bin/uwsgi /var/www/flask/config.ini</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令程序所在目录</span></span><br><span class="line">directory=/var/www/flask</span><br><span class="line"><span class="comment">#运行命令的用户名</span></span><br><span class="line">user=root</span><br><span class="line"></span><br><span class="line">stopasgroup = true</span><br><span class="line">killasgroup = true</span><br><span class="line"></span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line"><span class="comment">#日志地址</span></span><br><span class="line">stdout_logfile=/var/www/flask/uwsgi_supervisor.log</span><br></pre></td></tr></table></figure>
<p><strong>注意！！这里是第二个坑</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stopasgroup = true  <span class="comment"># 用于停止进程组，即停止所有通过“uwsgi.ini”配置启动的进程。</span></span><br><span class="line">killasgroup = true  <span class="comment"># 用于关闭进程组，即关闭所有通过“uwsgi.ini”配置启动的进程。</span></span><br></pre></td></tr></table></figure>
<p>这两句话在很多教程里是没有的，如果没有这两局代码也就意味着我们使用<code>supervisorctl</code>命令stop了<code>my_flask</code>之后这个uwsgi进程占用的<code>9102端口</code>不会被释放也就意味着我们无法再start
<code>my_flask</code>。这个问题一开始困扰了我好久，我一直不明白哪里出了问题，每次restart都不成功，希望看到的有缘人能注意一下。</p>
<p><strong>启动服务</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service supervisor start</span><br></pre></td></tr></table></figure>
<p><strong>终止服务</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service supervisor stop</span><br></pre></td></tr></table></figure>
<h2 id="supervisor补充">Supervisor补充</h2>
<p>supervisor：要安装的软件的名称。
supervisord：装好supervisor软件后，supervisord用于启动supervisor服务。
supervisorctl：用于管理supervisor配置文件中program。</p>
<p><strong>启动supervisor服务：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">supervisord -c /etc/supervisor/supervisord.conf</span><br></pre></td></tr></table></figure>
<p><strong>supervisorctl 操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">supervisorctl status</span><br><span class="line"></span><br><span class="line">supervisorctl reload</span><br><span class="line"></span><br><span class="line">supervisorctl stop program_name</span><br><span class="line"></span><br><span class="line">supervisorctl start program_name</span><br><span class="line"></span><br><span class="line">supervisorctl restart program_name</span><br></pre></td></tr></table></figure>
<p># 7.安装并配置nginx</p>
<p><a
href="http://nginx.com/">Nginx</a>是轻量级、性能强、占用资源少，能很好的处理高并发的反向代理软件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure>
<p>Ubuntu 上配置 Nginx 也是很简单，不要去改动默认的 nginx.conf
只需要将</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default</span><br></pre></td></tr></table></figure>
<p>文件替换掉就可以了。</p>
<p>新建一个 default 文件:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  <span class="number">80</span>;</span><br><span class="line">    server_name XXX.XXX.XXX; <span class="comment">#公网地址</span></span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        include uwsgi_params;<span class="comment">#转发到那个地址，转发到uwgi的地址，在通过uwsgi来启动我们的项目</span></span><br><span class="line">        uwsgi_pass <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">9102</span>;</span><br><span class="line">        uwsgi_connect_timeout <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将default配置文件替换掉就大功告成了！
还有，更改配置还需要记得重启一下nginx:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Flask</tag>
        <tag>部署至服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>强制关闭端口</title>
    <url>/%E5%BC%BA%E5%88%B6%E5%85%B3%E9%97%AD%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>很多情况下我们会遇到程序非正常退出那么它所占用的端口很有可能就没有被正常释放，导致我们下一次启动他的时候无法启动，这时候我们就需要手动释放端口。</p>
<p>参考：https://blog.csdn.net/why444216978/article/details/84062977</p>
<a id="more"></a>
<p>1、强制杀死该端口进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo fuser -k -n tcp 80</span><br></pre></td></tr></table></figure>
<p>2、根据PID关闭某个被占用的端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -tunlp | grep 80</span><br><span class="line"></span><br><span class="line">lsof -i:80</span><br><span class="line"></span><br><span class="line">sudo kill -9 PID</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>服务器配置</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器安装jupyter</title>
    <url>/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85jupyter/</url>
    <content><![CDATA[<p>属实不想用xshell上的ipython，命令行也确实没有jupyter方便，毕竟jupyter还可以保存运行过程，还可以进行拓展。所以我在服务器上搭建了一个jupyter</p>
<a id="more"></a>
<h2 id="参考">参考</h2>
<p>https://blog.csdn.net/qq_42137895/article/details/104283459?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</p>
<h2 id="安装jupyter服务">1. 安装jupyter服务</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3.7 install jupyter</span><br></pre></td></tr></table></figure>
<h2 id="配置远程访问jupyter">2. 配置远程访问jupyter</h2>
<p>先输入ipython进入交互模式 ，见图输入以下内容，设置好密码过后</p>
<p>会自动生成一个<strong>Verify password</strong>复制保存下来</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201015101310.png"
alt="aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZTQzZDQwZTJmYjM4YjhjM2NkNDMwOTcucG5n" />
<figcaption
aria-hidden="true">aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZTQzZDQwZTJmYjM4YjhjM2NkNDMwOTcucG5n</figcaption>
</figure>
<h3 id="生成配置文件">2.1生成配置文件</h3>
<p>在输入以下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure>
<p>就会自动在根目录下生成文件（~/.jupyter/jupyter_notebook_config.py），如果看不到，选项中选择显示隐藏文件</p>
<h3 id="修改配置文件">2.2修改配置文件</h3>
<p>建议先把jupyter_notebook_config.py文件传输到本地修改完成再上传</p>
<p>找到以下字符串进行修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.ip = <span class="string">'*'</span> <span class="comment"># 如果这里修过过后启动服务报错 则修改为c.NotebookApp.ip='0.0.0.0'</span></span><br><span class="line">c.NotebookApp.password = <span class="string">u'sha1****'</span> <span class="comment">#就之前保存的验证密码</span></span><br><span class="line">c.NotebookApp.open_browser = <span class="literal">False</span> <span class="comment"># 设置是否自动打开浏览器</span></span><br><span class="line">c.NotebookApp.port = <span class="number">9999</span>  <span class="comment"># 设置端口</span></span><br><span class="line">c.NotebookApp.allow_remote_access = <span class="literal">True</span></span><br><span class="line">c.ContentsManager.root_dir = <span class="string">'/var/www/jupyter_python'</span>	<span class="comment"># 设置jupyter显示目录</span></span><br></pre></td></tr></table></figure>
<h3 id="启动服务">3. 启动服务</h3>
<p>这里推荐两种</p>
<ol type="1">
<li><p>入门：<code>jupyter notebook --allow-root</code></p>
<blockquote>
<p>但这种会一直占着窗口，无法执行其他命令</p>
<p>Ctrl + C 即可结束</p>
</blockquote></li>
<li><p>进阶: <code>nohup jupyter notebook --allow-root &amp;</code></p>
<blockquote>
<p>nohup表示no hang up, 就是不挂起, 于是这个命令执行后即使终端退出,
也不会停止运行.</p>
<p>但要手动结束</p>
<p>lsof -i : {端口号}</p>
<p>然后 kill -9 {对应pid} #
9的意思是发送KILL信号，立刻结束，可能会有数据丢失</p>
</blockquote></li>
</ol>
<p>启动以后在本机 输入<code>http://{服务器ip}:9999</code>进行访问</p>
<h2 id="安装增强功能自动补全之类">4. 安装增强功能（自动补全之类）</h2>
<p>在终端中依次执行以下4行代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line">jupyter contrib nbextension install --user</span><br><span class="line">pip install jupyter_nbextensions_configurator</span><br><span class="line">jupyter nbextensions_configurator enable --user</span><br></pre></td></tr></table></figure>
<p><strong>执行完成以后，重启jupyter，即可看到附加项</strong></p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201015101630.png"
alt="aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZTQzZDhiYTJmYjM4YjhjM2NkNGVlZjUucG5n" />
<figcaption
aria-hidden="true">aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZTQzZDhiYTJmYjM4YjhjM2NkNGVlZjUucG5n</figcaption>
</figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>服务器配置</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习笔记(一)---基础</title>
    <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)---%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>待录取已经下来了，应该没什么意外就尘埃落定了，这几天都没怎么睡好，下午困得很。今天下午和晚上就看看什么是深度学习，稍微了解一下，晚上跑个步回去早点睡。</p>
<a id="more"></a>
<h2 id="参考">参考</h2>
<p>https://baike.baidu.com/item/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/3729729?fr=aladdin</p>
<p>https://www.zhihu.com/question/24097648</p>
<p>https://blog.csdn.net/testcs_dn/article/details/85009917</p>
<h2 id="什么是深度学习">什么是深度学习</h2>
<p>人工智能、机器学习、深度学习这几个名词都很火热，但是他们到底是什么意思呢。</p>
<p>根据我的查找发现，机器学习是实现人工智能的一种方式，而深度学习又是实现机器学习的一种方式，所以他们应该是一种包含的关系。类似于下图</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012154552.png"
alt="20181218165055573" />
<figcaption aria-hidden="true">20181218165055573</figcaption>
</figure>
<h2 id="机器学习神经网络深度学习">机器学习、神经网络、深度学习</h2>
<h3 id="机器学习">机器学习</h3>
<p>简单的说机器学习就是让机器去分析数据找规律，并通过找到的规律对新的数据进行处理。</p>
<p>机器学习理论主要是设计和分析一些让计算机可以自动“学习”的算法。<strong>机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。</strong>因为学习算法中涉及了大量的统计学理论，机器学习与推断统计学联系尤为密切，也被称为统计学习理论。算法设计方面，机器学习理论关注可以实现的，行之有效的学习算法。很多推论问题属于无程序可循难度，所以部分的机器学习研究是开发容易处理的近似算法。</p>
<h3 id="神经网络">神经网络</h3>
<p>神经网络简单点将就是由好多个神经元组成的系统。这是模拟人类的神经网络。</p>
<p>神经元是一个简单的分类器。</p>
<p>比如我们有一大堆猫、狗照片，把每一张照片送进一个机器里，机器需要判断这幅照片里的东西是猫还是狗。我们把猫狗图片处理一下，左边是狗的特征向量，右边是猫的。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012160259.png"
alt="20181218165203514" />
<figcaption aria-hidden="true">20181218165203514</figcaption>
</figure>
<p>神经元一个缺点是：它只能切一刀！你给我说说一刀怎么能把下面这两类分开吧。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012160321.png"
alt="20181218165215861" />
<figcaption aria-hidden="true">20181218165215861</figcaption>
</figure>
<p>解决办法是多层神经网络，底层神经元的输出是高层神经元的输入。我们可以在中间横着砍一刀，竖着砍一刀，然后把左上和右下的部分合在一起，与右上的左下部分分开；也可以围着左上角的边沿砍10刀把这一部分先挖出来，然后和右下角合并。</p>
<p>每砍一刀，其实就是使用了一个神经元，把不同砍下的半平面做交、并等运算，就是把这些神经元的输出当作输入，后面再连接一个神经元。这个例子中特征的形状称为异或，这种情况一个神经元搞不定，但是两层神经元就能正确对其进行分类。</p>
<p>只要你能砍足够多刀，把结果拼在一起，什么奇怪形状的边界神经网络都能够表示，所以说神经网络在理论上可以表示很复杂的函数/空间分布。但是真实的神经网络是否能摆动到正确的位置还要看网络初始值设置、样本容量和分布。</p>
<h3 id="深度学习">深度学习</h3>
<p>那什么是深度学习呢？深度学习简单点说就是一种为了让层数较多的多层神经网络可以训练，能够运行起来而演化出来的一系列的新的结构和新的方法。</p>
<p><strong>深度学习（Deep
Learning）</strong>是机器学习研究中的一个新的领域，其动机在于建立、模拟人脑进行分析学习的神经网络，<strong>它模仿人脑的机制来解释数据</strong>，例如图像，声音和文本。深度学习是无监督学习的一种。</p>
<p>深度学习的概念源于人工神经网络的研究。含多隐层的多层感知器就是一种深度学习结构。深度学习通过组合低层特征形成更加抽象的高层表示属性类别或特征，以发现数据的分布式特征表示。</p>
<p>就像下图</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012160356.png"
alt="20181218165227159" />
<figcaption aria-hidden="true">20181218165227159</figcaption>
</figure>
<p>普通的神经网络可能只有几层，深度学习可以达到十几层。深度学习中的深度二字也代表了神经网络的层数。现在流行的深度学习网络结构有"CNN(卷积神经网络)、RNN(循环神经网络)、DNN(深度神经网络)的等。</p>
<p>机器学习是人工智能的一个子集，深度学习又是机器学习的一个子集。机器学习与深度学习都是需要大量数据支撑的，是大数据技术上的一个应用，同时深度学习还需要更高的运算能力支撑，如GPU。</p>
<h2 id="深度学习典型模型">深度学习典型模型</h2>
<p>典型的深度学习模型有卷积神经网络( convolutional neural
network)、DBN和堆栈自编码网络(stacked auto-encoder
network)模型等，下面对这些模型进行描述。</p>
<h3 id="卷积神经网络模型">卷积神经网络模型</h3>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012161738.jpg"
alt="bd3eb13533fa828b269a8a0ff31f4134960a5aa4" />
<figcaption
aria-hidden="true">bd3eb13533fa828b269a8a0ff31f4134960a5aa4</figcaption>
</figure>
<p>在无监督预训练出现之前，训练深度神经网络通常非常困难，而其中一个特例是卷积神经网络。卷积神经网络受视觉系统的结构启发而产生。第一个卷积神经网络计算模型是在Fukushima(D的神经认知机中提出的，基于神经元之间的局部连接和分层组织图像转换，将有相同参数的神经元应用于前一层神经网络的不同位置，得到一种平移不变神经网络结构形式。后来，Le
Cun等人在该思想的基础上，用误差梯度设计并训练卷积神经网络，在一些模式识别任务上得到优越的性能。至今，基于卷积神经网络的模式识别系统是最好的实现系统之一，尤其在手写体字符识别任务上表现出非凡的性能。</p>
<h3 id="深度信任网络模型">深度信任网络模型</h3>
<p>DBN可以解释为贝叶斯概率生成模型，由多层随机隐变量组成，上面的两层具有无向对称连接，下面的层得到来自上一层的自顶向下的有向连接，最底层单元的状态为可见输入数据向量。DBN由若2F结构单元堆栈组成，结构单元通常为RBM（RestIlcted
Boltzmann
Machine，受限玻尔兹曼机）。堆栈中每个RBM单元的可视层神经元数量等于前一RBM单元的隐层神经元数量。根据深度学习机制，采用输入样例训练第一层RBM单元，并利用其输出训练第二层RBM模型，将RBM模型进行堆栈通过增加层来改善模型性能。在无监督预训练过程中，DBN编码输入到顶层RBM后，解码顶层的状态到最底层的单元，实现输入的重构。RBM作为DBN的结构单元，与每一层DBN共享参数。</p>
<h3 id="堆栈自编码网络模型">堆栈自编码网络模型</h3>
<p>堆栈自编码网络的结构与DBN类似，由若干结构单元堆栈组成，不同之处在于其结构单元为自编码模型(
auto-en-coder)而不是RBM。自编码模型是一个两层的神经网络，第一层称为编码层，第二层称为解码层。</p>
<h2 id="cuadcompute-unified-device-architecture">CUAD（Compute Unified
Device Architecture）</h2>
<p>CUDA（Compute Unified Device Architecture），是显卡厂商<a
href="https://baike.baidu.com/item/NVIDIA">NVIDIA</a>推出的运算平台。
CUDA™是一种由NVIDIA推出的通用<a
href="https://baike.baidu.com/item/并行计算/113443">并行计算</a>架构，该架构使<a
href="https://baike.baidu.com/item/GPU">GPU</a>能够解决复杂的计算问题。
它包含了CUDA<a
href="https://baike.baidu.com/item/指令集架构">指令集架构</a>（<a
href="https://baike.baidu.com/item/ISA">ISA</a>）以及GPU内部的并行计算引擎。
开发人员可以使用<a
href="https://baike.baidu.com/item/C语言">C语言</a>来为CUDA™架构编写程序，C语言是应用最广泛的一种高级编程语言。所编写出的程序可以在支持CUDA™的处理器上以超高性能运行。CUDA3.0已经开始支持<a
href="https://baike.baidu.com/item/C%2B%2B">C++</a>和<a
href="https://baike.baidu.com/item/FORTRAN">FORTRAN</a>。</p>
<p>在上文提到了，深度学习需要多的数据来进行学习，那么计算能力就是很重要的一环。</p>
<p>随着GPU的不断发展，它在计算能力上已经超过了通用CPU，仅仅用来做显卡有点浪费了。于是开发人员就将目光瞄向了GPU。</p>
<p>像许多的技术方向一样，深度学习也拥有着自己的框架，它可以让开发人员不需要手写CUDA就能跑GPU。</p>
<h2 id="深度学习框架">深度学习框架</h2>
<p><strong>为何要用深度学习框架？</strong></p>
<ul>
<li>不需要手写CUDA就能跑GPU</li>
<li>自动帮你复杂复合函数的梯度</li>
</ul>
<p>深度学习从此变得傻瓜！</p>
<h3 id="框架总览">框架总览</h3>
<p>现如今开源生态非常完善，深度学习相关的开源框架众多，光是为人熟知的就有caffe，tensorflow，pytorch/caffe2，keras，mxnet，paddldpaddle，theano，cntk，deeplearning4j，matconvnet等。</p>
<p>如何选择最适合你的开源框架是一个问题。有三AI在前段时间里，给大家整理了<strong>12个深度学习开源框架快速入门的教程和代码</strong>，供初学者进行挑选，一个合格的深度学习算法工程师怎么着得熟悉其中的3个以上吧。</p>
<p>下面是各大开源框架的一个总览。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201012165318.jpg"
alt="v2-d2af0dc0108888b3eea1140d20656883_720w" />
<figcaption
aria-hidden="true">v2-d2af0dc0108888b3eea1140d20656883_720w</figcaption>
</figure>
<p><strong>(1)
不管怎么说，tensorflow/pytorch你都必须会，这是目前开发者最喜欢，开源项目最丰富的两个框架。</strong></p>
<p><strong>(2)
如果你要进行移动端算法的开发，那么Caffe是不能不会的。</strong></p>
<p><strong>(3)
如果你非常熟悉Matlab，matconvnet你不应该错过。</strong></p>
<p><strong>(4)
如果你追求高效轻量，那么darknet和mxnet你不能不熟悉。</strong></p>
<p><strong>(5)
如果你很懒，想写最少的代码完成任务，那么用keras吧。</strong></p>
<p><strong>(6)
如果你是java程序员，那么掌握deeplearning4j没错的。</strong></p>
<p><strong>其他的框架，也自有它的特点，大家可以自己多去用用。</strong></p>
<h2 id="监督学习与非监督学习">监督学习与非监督学习</h2>
<h3 id="监督学习supervised-learning">监督学习（supervised
learning）</h3>
<p>从给定的训练数据集中学习出一个函数（模型参数），当新的数据到来时，可以根据这个函数预测结果。监督学习的训练集要求包括输入输出，也可以说是特征和目标。训练集中的目标是由人标注的。监督学习就是最常见的分类（注意和聚类区分）问题，通过已有的训练样本（即已知数据及其对应的输出）去训练得到一个最优模型（这个模型属于某个函数的集合，最优表示某个评价准则下是最佳的），再利用这个模型将所有的输入映射为相应的输出，对输出进行简单的判断从而实现分类的目的。也就具有了对未知数据分类的能力。监督学习的目标往往是让计算机去学习我们已经创建好的分类系统（模型）。</p>
<p>监督学习是训练神经网络和决策树的常见技术。这两种技术高度依赖事先确定的分类系统给出的信息，对于神经网络，分类系统利用信息判断网络的错误，然后不断调整网络参数。对于决策树，分类系统用它来判断哪些属性提供了最多的信息。</p>
<p>常见的有监督学习算法：回归分析和统计分类。最典型的算法是KNN和SVM。</p>
<p>有监督学习最常见的就是：regression&amp;classification</p>
<p>Regression：Y是实数vector。回归问题，就是拟合(x,y)的一条曲线，使得价值函数(costfunction)
L最小</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013165823.gif"
alt="20150919203859752" />
<figcaption aria-hidden="true">20150919203859752</figcaption>
</figure>
<p>Classification：Y是一个有穷数(finitenumber)，可以看做类标号，分类问题首先要给定有lable的数据训练分类器，故属于有监督学习过程。分类过程中cost
function l(X,Y)是X属于类Y的概率的负对数。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013165841.gif"
alt="20150919203917364" />
<figcaption aria-hidden="true">20150919203917364</figcaption>
</figure>
<p>其中fi(X)=P(Y=i|X)。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013165858.gif"
alt="20150919203935408" />
<figcaption aria-hidden="true">20150919203935408</figcaption>
</figure>
<h3 id="无监督学习unsupervised-learning">无监督学习（unsupervised
learning）</h3>
<p>输入数据没有被标记，也没有确定的结果。样本数据类别未知，需要根据样本间的相似性对样本集进行分类（聚类，clustering）试图使类内差距最小化，类间差距最大化。通俗点将就是实际应用中，不少情况下无法预先知道样本的标签，也就是说没有训练样本对应的类别，因而只能从原先没有样本标签的样本集开始学习分类器设计。</p>
<p>非监督学习目标不是告诉计算机怎么做，而是让它（计算机）自己去学习怎样做事情。非监督学习有两种思路。第一种思路是在指导Agent时不为其指定明确分类，而是在成功时，采用某种形式的激励制度。需要注意的是，这类训练通常会置于决策问题的框架里，因为它的目标不是为了产生一个分类系统，而是做出最大回报的决定，这种思路很好的概括了现实世界，agent可以对正确的行为做出激励，而对错误行为做出惩罚。</p>
<p>无监督学习的方法分为两大类：</p>
<ol type="1">
<li><p>一类为基于概率密度函数估计的直接方法：指设法找到各类别在特征空间的分布参数，再进行分类。</p></li>
<li><p>另一类是称为基于样本间相似性度量的简洁聚类方法：其原理是设法定出不同类别的核心或初始内核，然后依据样本与核心之间的相似性度量将样本聚集成不同的类别。</p></li>
</ol>
<p>利用聚类结果，可以提取数据集中隐藏信息，对未来数据进行分类和预测。应用于数据挖掘，模式识别，图像处理等。</p>
<p>PCA和很多deep learning算法都属于无监督学习。</p>
<h3 id="两者的不同点">两者的不同点</h3>
<ol type="1">
<li><p>有监督学习方法必须要有训练集与测试样本。在训练集中找规律，而对测试样本使用这种规律。而非监督学习没有训练集，只有一组数据，在该组数据集内寻找规律。</p></li>
<li><p>有监督学习的方法就是识别事物，识别的结果表现在给待识别数据加上了标签。因此训练样本集必须由带标签的样本组成。而非监督学习方法只有要分析的数据集的本身，预先没有什么标签。如果发现数据集呈现某种聚集性，则可按自然的聚集性分类，但不予以某种预先分类标签对上号为目的。</p></li>
<li><p>非监督学习方法在寻找数据集中的规律性，这种规律性并不一定要达到划分数据集的目的，也就是说不一定要“分类”。</p>
<p>这一点是比有监督学习方法的用途要广。
譬如分析一堆数据的主分量，或分析数据集有什么特点都可以归于非监督学习方法的范畴。</p></li>
<li><p>用非监督学习方法分析数据集的主分量与用K-L变换计算数据集的主分量又有区别。后者从方法上讲不是学习方法。因此用K-L变换找主分量不属于无监督学习方法，即方法上不是。而通过学习逐渐找到规律性这体现了学习方法这一点。在人工神经元网络中寻找主分量的方法属于无监督学习方法。</p></li>
</ol>
<h3 id="何时采用哪种方法">何时采用哪种方法</h3>
<p>简单的方法就是从定义入手，有训练样本则考虑采用监督学习方法；无训练样本，则一定不能用监督学习方法。但是，现实问题中，即使没有训练样本，我们也能够凭借自己的双眼，从待分类的数据中，人工标注一些样本，并把它们作为训练样本，这样的话，可以把条件改善，用监督学习方法来做。对于不同的场景，正负样本的分布如果会存在偏移（可能大的偏移，可能比较小），这样的话，监督学习的效果可能就不如用非监督学习了。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>CUAD</tag>
        <tag>神经网络</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习笔记(三)---基础理解</title>
    <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)---%E5%9F%BA%E7%A1%80%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>稍微记录一下看吴恩达课程后对深度学习各种概念的理解</p>
<a id="more"></a>
<h2 id="深度学习的大致过程">深度学习的大致过程</h2>
<p>在看了吴恩达的第一节课之后我对深度学习的理解是这样的：</p>
<p>深度学习其实就是一个寻找拟合函数的过程，让数据通过这个函数之后能输出和人看法相似的结果。</p>
<p>首先我们先需要选定一个/几个模型，确定需要的参数，超参数之类的</p>
<p>然后我们要将已有的数据划分为训练集，验证集和测试集，以往的比例是60，20，20之类的，但是由于现在已经是大数据时代了，有些数据集已经足够大了，我们不需要那么大的验证集和测试集，可以适当减少Dev和Test的占比，比如1，0.5之类的。<strong>还有一点要注意</strong>，我们很有可能训练集和验证，测试集的来源不一样，难以保证同分布，吴恩达老师建议大家要确保验证集和测试集的数据来自同一分布</p>
<p>之后我们要将参数初始化，注意初始化的时候参数是否能为0，是否需要进行归一化。当然训练集的输入输出也要进行预处理，但是预处理的方法目前还没有进行太多的讲解，只有一个将图像拉成一维向量</p>
<p>之后就是让神经网络通过训练找到合适的参数使得训练集的成本函数不断降低。整个过程主要包括前向传播和后向传播。在我看来，前向传播就是为了计算出成本函数，后向传播就是让成本函数对各个参数求导，然后通过梯度下降的方法让成本函数进一步降低。</p>
<p>前后向传播的迭代次数和梯度下降学习率都通过超参数来控制，最后将训练出来的各种参数保存下来，这样就完成了一个模型的简单训练。当然其中还有很多的正则化，归一化之类的操作，但是最简单的一个模型（比如逻辑回归）大致就是这些步骤了。</p>
<p>然后在验证集上通过运行同一网络不同超参数和不同网络之间的模型来比较模型性能，然后再跑测试集。</p>
<h2 id="为什么要向量化">为什么要向量化</h2>
<p>因为输入数据肯定是一个庞大的数据集，如果用单纯的标量那么一定需要很多的循环，但是循环的效率是很低的，所以我们需要引入向量操作，向量操作一次性可以完成整个循环的所有运算，效率提升极大。</p>
<h2 id="为什么要非线性的激活函数">为什么要非线性的激活函数</h2>
<p>因为如果使用线性的激活函数那么正向传播的输出仅仅是输入的线性组合，根本没有改变，不管你使用多少隐层都和单隐层是一样的效果。</p>
<h2 id="参数初始化">参数初始化</h2>
<p>为什么w参数不能直接初始化为全0？</p>
<p>当你这一层只有一个节点的时候，你是可以将这个节点的w参数初始化为0的。但是如果你这一层不止一个节点，而且采用了全连接的话，你还将W矩阵初始化成了0矩阵，那么你这一层每个节点的w参数之间是一个线性关系，和只有一个节点效果是一样的。</p>
<h2 id="为什么要用深层表示">为什么要用深层表示</h2>
<p>你可以直觉上把这种神经网络的前几层当作探测简单的函数，比如边缘，之后把它们跟后几层结合在一起，那么总体上就能学习更多复杂的函数。一般你会从比较小的细节入手，比如边缘，然后再一步步到更大更复杂的区域，比如一只眼睛或是一个鼻子，再把眼睛鼻子装一块组成更复杂的部分。</p>
<h2 id="超参数">超参数</h2>
<p>比如算法中的<strong>learning rate</strong> $ a $
（学习率）、<strong>iterations</strong>(梯度下降法循环的数量)、$ L $
（隐藏层数目）、$ n^{[l]} $ （隐藏层单元数目）、<strong>choice of
activation
function</strong>（激活函数的选择）都需要你来设置，这些数字实际上控制了最后的参数$
W $ 和 $ b
$的值，所以它们被称作超参数。后面还有很多超参数我还有没学到，总的来讲就是能影响参数的更高级参数。</p>
<p>超参数的取值并没有明确的规定，这目前还是一个经验性的过程，新手上路最多的还是要不断的尝试，通过不断地修改超参数对比结果来不断修正最后找到一个相对合适的。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习打印训练日志</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%89%93%E5%8D%B0%E8%AE%AD%E7%BB%83%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>这里记录下我使用python的sklearn库中的机器学习模型，训练过程中使用打印训练日志的方法。</p>
<a id="more"></a>
<blockquote>
<p>scikit-learn是Python十分出名的一个算法库，里面包含了非常多的机器学习算法，我们有一个场景需要选用多个机器学习算法同时要在训练过程中进行训练信息的打印，库中的有些算法本身是自带训练日志打印的，但是有些没有，因此我们主要需要解决以下两个问题：</p>
<ol type="1">
<li>带训练过程的算法将训练过程打印到指定文件中</li>
<li>不带训练过程的算法人为在训练过程中打印一些简单的训练内容</li>
</ol>
</blockquote>
<h3 id="带过程算法训练日志打印">带过程算法训练日志打印</h3>
<h4 id="启用训练日志">启用训练日志</h4>
<p>虽然有一些算法是自带训练过程输出的，但是基本默认都是不输出或者只输出很少一部分信息的，这里我们需要查看sklearn库中这个算法的实现注释，看有没有控制训练过程输出的参数，下面举一些例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 很多算法的训练过程打印都是通过verbose这个参数控制的，例如</span></span><br><span class="line">clf = ensemble.HistGradientBoostingClassifier(verbose=<span class="number">1</span>, **hyperparameter)</span><br><span class="line">clf = ExtraTreesClassifier(verbose=<span class="number">3</span>, **hyperparameter)</span><br><span class="line">clf = RandomForestClassifier(verbose=<span class="number">99</span>, **hyperparameter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但也有一些是通过别的参数控制的，还是要自己去看算法实现里面的注释</span></span><br><span class="line">clf = LocalOutlierFactor(novelty=<span class="literal">True</span>, **hyperparameter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 甚至Lightgbm还是在fit()函数中控制的</span></span><br><span class="line">clf.fit(x, y, eval_set=[(x, y)], callbacks=[lgb.log_evaluation(<span class="number">1</span>)])</span><br></pre></td></tr></table></figure>
<h4 id="将训练日志输出到指定文件">将训练日志输出到指定文件</h4>
<p>这些算法基本都没有参数来接受训练日志输出位置（我遇见的只有一个例外，下面会讲），基本都是将训练日志直接默认输出到命令行，所以我们需要将原本输出到命令行中的内容重定向输出到指定文件中。</p>
<p>这里主要用到<strong>sys.stdout</strong>，下面先简单介绍下<strong>sys.stdout</strong>的基本用法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(<span class="string">'111'</span>)</span><br><span class="line"></span><br><span class="line">oldPrint = sys.stdout   <span class="comment"># 用于后期还原</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把输出重定向到文件</span></span><br><span class="line">sys.stdout=open(<span class="string">'outfile.log'</span>,<span class="string">"a+"</span>) </span><br><span class="line">print(<span class="string">'222'</span>)</span><br><span class="line"></span><br><span class="line">sys.stdout.close() <span class="comment"># 关闭文件</span></span><br><span class="line">sys.stdout = oldPrint  <span class="comment"># 还原输出位置到命令行</span></span><br></pre></td></tr></table></figure>
<p>这里其实看起来已经重定向的功能已经实现了，我们只需要将print('222')换为我们执行模型训练的内容即可，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">(algorithm, clf, x, y, train_log_path)</span>:</span></span><br><span class="line">    cmd = sys.stdout</span><br><span class="line">    sys.stdout = open(train_log_path, mode=<span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    clf.fit(x, y)</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    sys.stdout.close()</span><br><span class="line">    sys.stdout = cmd</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start, end</span><br></pre></td></tr></table></figure>
<p>但是我们在实际使用的过程中还是发现了一些问题，就是有些算法使用的时候是没问题的，但是有些算法就不会实时写入，而是整个训练结束了才把内容写入指定文件，我们思考应该是flush的问题，于是重写了下<strong>sys.stdout</strong>的<strong>wirte()</strong>和<strong>flush()</strong>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename=<span class="string">'default.log'</span>, stream=sys.stdout)</span>:</span></span><br><span class="line">        self.terminal = stream</span><br><span class="line">        self.log = open(filename, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, message)</span>:</span></span><br><span class="line">        <span class="comment"># self.terminal.write(message)</span></span><br><span class="line">        <span class="comment"># self.terminal.flush()</span></span><br><span class="line">        self.log.write(message)</span><br><span class="line">        self.log.flush()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flush</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">(algorithm, clf, x, y, train_log_path)</span>:</span></span><br><span class="line">    cmd = sys.stdout</span><br><span class="line">    sys.stdout = Logger(train_log_path, sys.stdout)</span><br><span class="line">    <span class="comment"># sys.stdout = open(train_log_path, mode='a', encoding='utf-8')</span></span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    clf.fit(x, y)</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="comment"># sys.stdout.close()</span></span><br><span class="line">    sys.stdout = cmd</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start, end</span><br></pre></td></tr></table></figure>
<p>这样进行修改之后发现所有算法的训练日志都能实时写入到指定文件中。</p>
<h4 id="重定向问题">重定向问题</h4>
<p>将训练日志重定向到指定文件说白了就是修改<strong>sys.stdout</strong>的指向，但是还有极个别的算法内部会有一个专门的参数来指定训练日志输出位置，例如catboost</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y=None, cat_features=None, text_features=None, embedding_features=None, sample_weight=None, baseline=None, use_best_model=None, eval_set=None, verbose=None, logging_level=None, plot=False, column_description=None, verbose_eval=None, metric_period=None, silent=None, early_stopping_rounds=None, save_snapshot=None, snapshot_file=None, snapshot_interval=None, init_model=None, callbacks=None, log_cout=sys.stdout, log_cerr=sys.stderr)</span>:</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到catboost的<strong>fit()</strong>函数中有一个专门的参数<strong>log_cout</strong>来控制输出，这种算法在重定向训练日志的时候就需要将我们修改过的<strong>sys.stdout</strong>传入<strong>fit()</strong>中。</p>
<h4 id="效果展示">效果展示</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">算法HGB正在进行训练</span><br><span class="line">Binning 0.123 GB of training data: 1.479 s</span><br><span class="line">Binning 0.014 GB of validation data: 0.017 s</span><br><span class="line">Fitting gradient boosted rounds:</span><br><span class="line">[1&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 10, train loss: 0.40411, val loss: 0.40415, in 0.159s</span><br><span class="line">[2&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 9, train loss: 0.34343, val loss: 0.34353, in 0.062s</span><br><span class="line">[3&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 8, train loss: 0.29777, val loss: 0.29790, in 0.058s</span><br><span class="line">[4&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 8, train loss: 0.26076, val loss: 0.26084, in 0.059s</span><br><span class="line">[5&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 8, train loss: 0.23027, val loss: 0.23030, in 0.057s</span><br><span class="line">[6&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 9, train loss: 0.20460, val loss: 0.20460, in 0.056s</span><br><span class="line">[7&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 8, train loss: 0.18270, val loss: 0.18263, in 0.061s</span><br><span class="line">[8&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 9, train loss: 0.16379, val loss: 0.16374, in 0.060s</span><br><span class="line">[9&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 10, train loss: 0.14730, val loss: 0.14720, in 0.060s</span><br><span class="line">[10&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 9, train loss: 0.13293, val loss: 0.13283, in 0.061s</span><br><span class="line">[11&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 9, train loss: 0.12029, val loss: 0.12016, in 0.061s</span><br><span class="line">[12&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 11, train loss: 0.10902, val loss: 0.10894, in 0.063s</span><br><span class="line">[13&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 12, train loss: 0.09799, val loss: 0.09816, in 0.064s</span><br><span class="line">[14&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 8, train loss: 0.08923, val loss: 0.08939, in 0.060s</span><br><span class="line">[15&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 9, train loss: 0.08115, val loss: 0.08130, in 0.061s</span><br><span class="line">[16&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 10, train loss: 0.07382, val loss: 0.07382, in 0.064s</span><br><span class="line">[17&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 9, train loss: 0.06734, val loss: 0.06732, in 0.062s</span><br><span class="line">[18&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 9, train loss: 0.06146, val loss: 0.06148, in 0.064s</span><br><span class="line">[19&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 9, train loss: 0.05623, val loss: 0.05628, in 0.063s</span><br><span class="line">[20&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 11, train loss: 0.05124, val loss: 0.05127, in 0.063s</span><br><span class="line">[21&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 10, train loss: 0.04676, val loss: 0.04682, in 0.066s</span><br><span class="line">[22&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 12, train loss: 0.04273, val loss: 0.04286, in 0.063s</span><br><span class="line">[23&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 13, train loss: 0.03913, val loss: 0.03934, in 0.061s</span><br><span class="line">[24&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 13, train loss: 0.03588, val loss: 0.03615, in 0.064s</span><br><span class="line">[25&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 14, train loss: 0.03303, val loss: 0.03333, in 0.063s</span><br><span class="line">[26&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 14, train loss: 0.03044, val loss: 0.03079, in 0.065s</span><br><span class="line">[27&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 14, train loss: 0.02812, val loss: 0.02852, in 0.067s</span><br><span class="line">[28&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 9, train loss: 0.02533, val loss: 0.02568, in 0.061s</span><br><span class="line">[29&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 12, train loss: 0.02338, val loss: 0.02374, in 0.067s</span><br><span class="line">[30&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 11, train loss: 0.02164, val loss: 0.02198, in 0.062s</span><br><span class="line">[31&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 11, train loss: 0.02003, val loss: 0.02043, in 0.065s</span><br><span class="line">[32&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 11, train loss: 0.01863, val loss: 0.01887, in 0.060s</span><br><span class="line">[33&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 11, train loss: 0.01729, val loss: 0.01762, in 0.064s</span><br><span class="line">[34&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 10, train loss: 0.01607, val loss: 0.01643, in 0.065s</span><br><span class="line">[35&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 10, train loss: 0.01503, val loss: 0.01544, in 0.069s</span><br><span class="line">[36&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 10, train loss: 0.01404, val loss: 0.01454, in 0.068s</span><br><span class="line">[37&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 9, train loss: 0.01317, val loss: 0.01373, in 0.064s</span><br><span class="line">[38&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 10, train loss: 0.01239, val loss: 0.01297, in 0.065s</span><br><span class="line">[39&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 11, train loss: 0.01160, val loss: 0.01222, in 0.064s</span><br><span class="line">[40&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 14, train loss: 0.01092, val loss: 0.01152, in 0.066s</span><br><span class="line">[41&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 12, train loss: 0.01032, val loss: 0.01089, in 0.066s</span><br><span class="line">[42&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 11, train loss: 0.00974, val loss: 0.01033, in 0.068s</span><br><span class="line">[43&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 11, train loss: 0.00921, val loss: 0.00981, in 0.065s</span><br><span class="line">[44&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 11, train loss: 0.00873, val loss: 0.00935, in 0.071s</span><br><span class="line">[45&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 13, train loss: 0.00831, val loss: 0.00895, in 0.067s</span><br><span class="line">[46&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 14, train loss: 0.00792, val loss: 0.00857, in 0.066s</span><br><span class="line">[47&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 12, train loss: 0.00753, val loss: 0.00820, in 0.068s</span><br><span class="line">[48&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 11, train loss: 0.00716, val loss: 0.00790, in 0.062s</span><br><span class="line">[49&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 10, train loss: 0.00682, val loss: 0.00760, in 0.063s</span><br><span class="line">[50&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 14, train loss: 0.00650, val loss: 0.00734, in 0.062s</span><br><span class="line">[51&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 10, train loss: 0.00620, val loss: 0.00703, in 0.064s</span><br><span class="line">[52&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 12, train loss: 0.00593, val loss: 0.00676, in 0.067s</span><br><span class="line">[53&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 13, train loss: 0.00572, val loss: 0.00654, in 0.062s</span><br><span class="line">[54&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 11, train loss: 0.00553, val loss: 0.00634, in 0.068s</span><br><span class="line">[55&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 12, train loss: 0.00535, val loss: 0.00616, in 0.068s</span><br><span class="line">[56&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 18, train loss: 0.00516, val loss: 0.00598, in 0.061s</span><br><span class="line">[57&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 17, train loss: 0.00497, val loss: 0.00579, in 0.067s</span><br><span class="line">[58&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 17, train loss: 0.00481, val loss: 0.00563, in 0.064s</span><br><span class="line">[59&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 11, train loss: 0.00467, val loss: 0.00550, in 0.064s</span><br><span class="line">[60&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 15, train loss: 0.00452, val loss: 0.00537, in 0.066s</span><br><span class="line">[61&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 13, train loss: 0.00440, val loss: 0.00526, in 0.069s</span><br><span class="line">[62&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 15, train loss: 0.00426, val loss: 0.00513, in 0.064s</span><br><span class="line">[63&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 17, train loss: 0.00414, val loss: 0.00502, in 0.070s</span><br><span class="line">[64&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 16, train loss: 0.00403, val loss: 0.00494, in 0.067s</span><br><span class="line">[65&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 12, train loss: 0.00395, val loss: 0.00488, in 0.063s</span><br><span class="line">[66&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 15, train loss: 0.00385, val loss: 0.00479, in 0.067s</span><br><span class="line">[67&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 11, train loss: 0.00377, val loss: 0.00473, in 0.065s</span><br><span class="line">[68&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 18, train loss: 0.00367, val loss: 0.00464, in 0.067s</span><br><span class="line">[69&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 19, train loss: 0.00358, val loss: 0.00458, in 0.065s</span><br><span class="line">[70&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 14, train loss: 0.00352, val loss: 0.00453, in 0.060s</span><br><span class="line">[71&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 13, train loss: 0.00344, val loss: 0.00447, in 0.065s</span><br><span class="line">[72&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 16, train loss: 0.00337, val loss: 0.00443, in 0.067s</span><br><span class="line">[73&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 17, train loss: 0.00332, val loss: 0.00439, in 0.063s</span><br><span class="line">[74&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 17, train loss: 0.00324, val loss: 0.00433, in 0.068s</span><br><span class="line">[75&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 15, train loss: 0.00320, val loss: 0.00429, in 0.065s</span><br><span class="line">[76&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 16, train loss: 0.00315, val loss: 0.00423, in 0.065s</span><br><span class="line">[77&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 15, train loss: 0.00310, val loss: 0.00420, in 0.065s</span><br><span class="line">[78&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 12, train loss: 0.00304, val loss: 0.00412, in 0.067s</span><br><span class="line">[79&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 20, train loss: 0.00300, val loss: 0.00409, in 0.065s</span><br><span class="line">[80&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 21, train loss: 0.00296, val loss: 0.00405, in 0.064s</span><br><span class="line">[81&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 14, train loss: 0.00291, val loss: 0.00402, in 0.069s</span><br><span class="line">[82&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 10, train loss: 0.00287, val loss: 0.00397, in 0.066s</span><br><span class="line">[83&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 13, train loss: 0.00282, val loss: 0.00395, in 0.065s</span><br><span class="line">[84&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 15, train loss: 0.00279, val loss: 0.00394, in 0.060s</span><br><span class="line">[85&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 16, train loss: 0.00276, val loss: 0.00392, in 0.065s</span><br><span class="line">[86&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 14, train loss: 0.00272, val loss: 0.00390, in 0.064s</span><br><span class="line">[87&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 18, train loss: 0.00269, val loss: 0.00388, in 0.063s</span><br><span class="line">[88&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 13, train loss: 0.00265, val loss: 0.00387, in 0.061s</span><br><span class="line">[89&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 11, train loss: 0.00261, val loss: 0.00384, in 0.066s</span><br><span class="line">[90&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 18, train loss: 0.00259, val loss: 0.00383, in 0.067s</span><br><span class="line">[91&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 14, train loss: 0.00254, val loss: 0.00383, in 0.073s</span><br><span class="line">[92&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 16, train loss: 0.00252, val loss: 0.00381, in 0.063s</span><br><span class="line">[93&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 12, train loss: 0.00249, val loss: 0.00379, in 0.066s</span><br><span class="line">[94&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 17, train loss: 0.00245, val loss: 0.00378, in 0.065s</span><br><span class="line">[95&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 11, train loss: 0.00242, val loss: 0.00376, in 0.065s</span><br><span class="line">[96&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 14, train loss: 0.00239, val loss: 0.00375, in 0.064s</span><br><span class="line">[97&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 15, train loss: 0.00236, val loss: 0.00372, in 0.068s</span><br><span class="line">[98&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 17, train loss: 0.00234, val loss: 0.00371, in 0.060s</span><br><span class="line">[99&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 21, train loss: 0.00232, val loss: 0.00370, in 0.068s</span><br><span class="line">[100&#x2F;100] 1 tree, 31 leaves, max depth &#x3D; 11, train loss: 0.00230, val loss: 0.00368, in 0.066s</span><br><span class="line">Fit 100 trees in 8.440 s, (3100 total leaves)</span><br><span class="line">Time spent computing histograms: 2.781s</span><br><span class="line">Time spent finding best splits:  0.320s</span><br><span class="line">Time spent applying splits:      0.423s</span><br><span class="line">Time spent predicting:           0.086s</span><br><span class="line">训练完成	训练用时8.475976943969727 Seconds	模型保存在: *****\142-20220605-173439</span><br><span class="line">有监督算法开始进行训练集ACC计算</span><br><span class="line">计算完成	训练集准确率: 0.99939108823808</span><br></pre></td></tr></table></figure>
<h3 id="不带过程算法训练日志打印">不带过程算法训练日志打印</h3>
<p>这部分算法本身不自带训练日志输出，如果要改源码的话就需要深刻理解每种算法机制，而且<strong>sklearn</strong>这种成熟的库底层可能是封装好的文件，根本不是py文件，修改源码的难度可能会有些大。
如果只是单纯的为了看到我们的算法确实在运行其实没有必要非要打印和算法机制相关的内容，打印一些算法运行时间，使用训练集这些数据其实也就够了。所以这里我选择使用python多线程在算法训练的时候打印一些简单的信息让使用者能看到我们的算法在运行就行了。</p>
<h4 id="多线程打印训练信息">多线程打印训练信息</h4>
<p>实际上就是简单使用了python的多线程，没有什么复杂的同步，资源，锁之类的问题，对于我们这个简单的场景来说唯一要思考的就是如何停止线程，也没什么说的，直接看代码吧。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要在后台运行的任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_train_content</span><span class="params">(algorithm, start, stop_flag)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">'%s算法正在训练,训练时长:%.2f秒'</span> % (algorithm, time.time() - start))</span><br><span class="line">        time.sleep(random.uniform(<span class="number">0</span>, <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">if</span> stop_flag():</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">(algorithm, clf, x, y, train_log_path)</span>:</span></span><br><span class="line">    cmd = sys.stdout</span><br><span class="line">    sys.stdout = Logger(train_log_path, sys.stdout)</span><br><span class="line">    <span class="comment"># sys.stdout = open(train_log_path, mode='a', encoding='utf-8')</span></span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> algorithm <span class="keyword">in</span> [<span class="string">'CART'</span>, <span class="string">'KNN'</span>, <span class="string">'HBOS'</span>, <span class="string">'OCSVM'</span>, <span class="string">'KDE'</span>, <span class="string">'LOF'</span>]:</span><br><span class="line">        stop_flag = <span class="literal">False</span></span><br><span class="line">        t = Thread(target=print_train_content, args=(algorithm, start, <span class="keyword">lambda</span>: stop_flag))</span><br><span class="line">        t.daemon = <span class="number">1</span></span><br><span class="line">        t.start()</span><br><span class="line">        clf.fit(x, y)</span><br><span class="line">        stop_flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        clf.fit(x, y)</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="comment"># sys.stdout.close()</span></span><br><span class="line">    sys.stdout = cmd</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start, end</span><br></pre></td></tr></table></figure>
<p>上面代码里的线程只是简单使用了打印训练时长，线程打印的内容可以自己随便定制，只要往里面传参数就行了。</p>
<p>我们停止线程的方式主要是通过<strong>stop_flag</strong>这个标志位来实现的，标志位可以通过全局变量的形式声明，也可以像我这样使用lambda声明为一个函数，这样就显得稍微美观一点点。</p>
<h4 id="效果展示-1">效果展示</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">算法OCSVM正在进行训练</span><br><span class="line">OCSVM算法正在训练,训练时长:0.00秒</span><br><span class="line">OCSVM算法正在训练,训练时长:2.34秒</span><br><span class="line">OCSVM算法正在训练,训练时长:4.77秒</span><br><span class="line">OCSVM算法正在训练,训练时长:5.32秒</span><br><span class="line">OCSVM算法正在训练,训练时长:5.35秒</span><br><span class="line">OCSVM算法正在训练,训练时长:6.18秒</span><br><span class="line">OCSVM算法正在训练,训练时长:7.84秒</span><br><span class="line">OCSVM算法正在训练,训练时长:8.27秒</span><br><span class="line">OCSVM算法正在训练,训练时长:9.33秒</span><br><span class="line">OCSVM算法正在训练,训练时长:9.60秒</span><br><span class="line">OCSVM算法正在训练,训练时长:12.00秒</span><br><span class="line">OCSVM算法正在训练,训练时长:14.31秒</span><br><span class="line">OCSVM算法正在训练,训练时长:15.62秒</span><br><span class="line">OCSVM算法正在训练,训练时长:16.47秒</span><br><span class="line">OCSVM算法正在训练,训练时长:16.85秒</span><br><span class="line">OCSVM算法正在训练,训练时长:17.16秒</span><br><span class="line">OCSVM算法正在训练,训练时长:19.70秒</span><br><span class="line">OCSVM算法正在训练,训练时长:20.43秒</span><br><span class="line">OCSVM算法正在训练,训练时长:20.66秒</span><br><span class="line">OCSVM算法正在训练,训练时长:21.01秒</span><br><span class="line">OCSVM算法正在训练,训练时长:22.92秒</span><br><span class="line">OCSVM算法正在训练,训练时长:24.12秒</span><br><span class="line">OCSVM算法正在训练,训练时长:24.96秒</span><br><span class="line">OCSVM算法正在训练,训练时长:25.63秒</span><br><span class="line">OCSVM算法正在训练,训练时长:26.88秒</span><br><span class="line">OCSVM算法正在训练,训练时长:27.00秒</span><br><span class="line">OCSVM算法正在训练,训练时长:28.12秒</span><br><span class="line">OCSVM算法正在训练,训练时长:28.43秒</span><br><span class="line">OCSVM算法正在训练,训练时长:30.28秒</span><br><span class="line">OCSVM算法正在训练,训练时长:32.33秒</span><br><span class="line">OCSVM算法正在训练,训练时长:34.06秒</span><br><span class="line">OCSVM算法正在训练,训练时长:36.52秒</span><br><span class="line">OCSVM算法正在训练,训练时长:38.98秒</span><br><span class="line">OCSVM算法正在训练,训练时长:39.21秒</span><br><span class="line">OCSVM算法正在训练,训练时长:39.71秒</span><br><span class="line">OCSVM算法正在训练,训练时长:42.49秒</span><br><span class="line">OCSVM算法正在训练,训练时长:43.58秒</span><br><span class="line">OCSVM算法正在训练,训练时长:44.71秒</span><br><span class="line">OCSVM算法正在训练,训练时长:44.83秒</span><br><span class="line">OCSVM算法正在训练,训练时长:46.16秒</span><br><span class="line">OCSVM算法正在训练,训练时长:47.25秒</span><br><span class="line">OCSVM算法正在训练,训练时长:47.54秒</span><br><span class="line">OCSVM算法正在训练,训练时长:47.58秒</span><br><span class="line">OCSVM算法正在训练,训练时长:47.75秒</span><br><span class="line">OCSVM算法正在训练,训练时长:49.05秒</span><br><span class="line">OCSVM算法正在训练,训练时长:49.34秒</span><br><span class="line">OCSVM算法正在训练,训练时长:50.88秒</span><br><span class="line">OCSVM算法正在训练,训练时长:53.53秒</span><br><span class="line">OCSVM算法正在训练,训练时长:54.78秒</span><br><span class="line">OCSVM算法正在训练,训练时长:57.68秒</span><br><span class="line">OCSVM算法正在训练,训练时长:58.34秒</span><br><span class="line">训练完成	训练用时59.8736629486084 Seconds	模型保存在: ***\167-20220622-165753</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习笔记(零)---英语</title>
    <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E9%9B%B6)---%E8%8B%B1%E8%AF%AD/</url>
    <content><![CDATA[<p>记录一下常用英语词汇</p>
<a id="more"></a>
<p>监督学习 supervised learning</p>
<p>无监督学习 unsupervised learning</p>
<p>统一计算设备架构 CUAD（Compute Unified Device Architecture）</p>
<p>微分 Differentiate</p>
<p>卷积神经网络 convolutional neural network</p>
<p>循环神经网络 Circulating neural network</p>
<p>链式法则 chain rule</p>
<p>正向传播 forward propagation</p>
<p>反向传播 backward propagation</p>
<p>广播 broadcasting</p>
<p>变平 flatten</p>
<p>标量 scalar</p>
<p>偏移量，偏差 bias</p>
<p>方差 variance</p>
<p>拟合 fit</p>
<p>正则化 regularization</p>
<p>归一化 Normalization</p>
<p>范数 norm</p>
<p>验证集 validation/development</p>
<p>弗罗贝尼乌斯范数 Frobenius norm</p>
<p>正交化 orthogonalization</p>
<p>滤波器 filter</p>
<p>核 kernal</p>
<p>填充 padding</p>
<p>批处理 batch</p>
<p>优化 optimization</p>
<p>算法 algorithm</p>
<p>动量 momentum</p>
<p>衰减 decay</p>
<p>离散 discrete</p>
<p>鞍点 saddle point</p>
<p>鱼子酱 caviar</p>
<p>隐藏 hidden</p>
<p>层 layer</p>
<p>线性 linear</p>
<p>非线性 nonlinear</p>
<p>边界 boundaries</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习笔记(二)---框架</title>
    <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)---%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>昨天大致了解了一下什么是深度学习，深度学习，人工智能，机器学习之间有什么关系，深度学习框架的总览。今天来找找各个框架之间的对比和目前比较常用的tensorflow和pytorch一些资料。我觉得框架属实是个好东西，让我可以不用写CUDA，反正Django的ORM是属实舒服，轻松摆脱巨长的MySql，但是会有一些自己特殊的地方，比如插入一个带外键的数据时要先获取其主键Model，还是要多了解多记录。</p>
<a id="more"></a>
<h2 id="参考">参考</h2>
<p>https://www.zhihu.com/question/330766768/answer/1398232292</p>
<p>https://www.zhihu.com/question/66200879</p>
<h2 id="总览">总览</h2>
<p>上来先发一张图</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013092727.jpg"
alt="v2-d2af0dc0108888b3eea1140d20656883_720w" />
<figcaption
aria-hidden="true">v2-d2af0dc0108888b3eea1140d20656883_720w</figcaption>
</figure>
<h2 id="caffe">Caffe</h2>
<p><strong>概述：</strong>Caffe 是伯克利的贾扬清主导开发，以 C++/CUDA
代码为主，最早的深度学习框架之一，比TensorFlow、Mxnet、Pytorch
等都更早，需要进行编译安装。支持命令行、Python 和 Matlab
接口，单机多卡、多机多卡等都可以很方便的使用。目前 master
分支已经停止更新，intel 分支等还在维护，caffe 框架已经非常稳定。</p>
<p><strong>通用流程：</strong></p>
<p>准备数据——定义网络——配置训练参数——训练/测试</p>
<p>以上的流程相互之间是解耦合的，所以 caffe 的使用非常简单。</p>
<p><strong>优点：</strong></p>
<ul>
<li>以 C++/CUDA/python 代码为主，速度快，性能高。</li>
<li>工厂设计模式，代码结构清晰，可读性和拓展性强。</li>
<li>支持命令行、Python 和 Matlab 接口，使用方便。</li>
<li>CPU 和 GPU 之间切换方便，多 GPU 训练方便。</li>
<li>工具丰富，社区活跃。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>源代码修改门槛较高，需要实现前向反向传播，以及 CUDA 代码。</li>
<li>不支持自动求导。</li>
<li>不支持模型级并行，只支持数据级并行</li>
<li>不适合于非图像任务。</li>
</ul>
<h2 id="tensorflow">Tensorflow</h2>
<p><strong>概述：</strong>TensorFlow 是 Google brain
推出的开源机器学习库，可用作各类深度学习相关的任务。TensorFlow = Tensor
+ Flow，Tensor 就是张量，代表 N 维数组，这与 Caffe 中的 blob
是类似的；Flow 即流，代表基于数据流图的计算。</p>
<p><strong>特点：</strong>TensorFlow
最大的特点是计算图，即先定义好图，然后进行运算，而且代码都包含两部分：</p>
<p>创建计算图，表示计算的数据流。可以将它看做是Caffe 中的 prototxt
的定义过程。</p>
<p>运行会话，执行图中的运算，可以看作是 Caffe 中的训练过程。会话比 Caffe
灵活很多，由于是 Python 接口，取中间结果分析，Debug 等方便很多。</p>
<h2 id="pytorch">Pytorch</h2>
<p><strong>概述：</strong> Pytorch = Python + Torch。Torch
是纽约大学的一个机器学习开源框架，但是由于使用的是一种绝大部分人绝对没有听过的
Lua 语言，导致很多人都被吓退。后来随着 Python 的生态越来越完善，Facebook
人工智能研究院推出了 Pytorch 并开源。Pytorch 不是简单的封装 Torch
并提供Python 接口，而是对 Tensor 以上的所有代码进行了重构，同 TensorFlow
一样，增加了自动求导。后来 Caffe2 全部并入
Pytorch，如今已经成为了非常流行的框架。</p>
<p><strong>特点：</strong></p>
<ul>
<li>动态图计算。TensorFlow 从静态图发展到了动态图机制 Eager Execution
，pytorch 则一开始就是动态图机制。动态图机制的好处就是随时随地修改，随处
debug ，没有类似编译的过程。</li>
<li>简单。相比 TensorFlow1.0 中 Tensor、Variable、Session
等概念充斥，数据读取接口频繁更新，tf.nn、tf.layers、tf.contrib
各自重复，Pytorch 则是从 Tensor 到 Variable 再到nn.Module
，最新的Pytorch 已经将 Tensor 和 Variable
合并，这分别就是从数据张量到网络的抽象层次的递进。</li>
</ul>
<h2 id="mxnet">Mxnet</h2>
<p><strong>概述：</strong> Mxnet
是由李沐等人领导开发的非常灵活，扩展性很强的框架，被 Amazon
定为官方框架。</p>
<p><strong>特点：</strong> Mxnet
同时拥有命令式编程和符号式编程的特点。在命令式编程上 MXNet
提供张量运算，进行模型的迭代训练和更新中的控制逻辑；在声明式编程中 MXNet
支持符号表达式，用来描述神经网络，并利用系统提供的自动求导来训练模型。Mxnet
性能非常高，推荐资源不够的同学使用。</p>
<h2 id="keras">Keras</h2>
<p><strong>概述：</strong> Keras
是一个对小白用户非常友好而简单的深度学习框架，严格来说并不是一个开源框架，而是一个高度模块化的神经网络库。Keras
在高层可以调用 TensorFlow，CNTK，Theano ，还有更多的库也在被陆续支持中。
Keras 的特点是能够快速实现模型的搭建，是高效地进行科学研究的关键。</p>
<p><strong>特点：</strong></p>
<ul>
<li>高度模块化，搭建网络非常简洁。</li>
<li>API 很简单，具有统一的风格。</li>
<li>容易扩展，只需使用 python 添加新类和函数。</li>
</ul>
<h2 id="paddlepaddle">Paddlepaddle</h2>
<p><strong>概述：</strong> 正所谓 Google 有 Tensorflow，Facebook 有
Pytorch，Amazon 有 Mxnet，作为国内机器学习的先驱，百度也有
PaddlePaddle，其中 Paddle 即 Parallel Distributed Deep Learning
(并行分布式深度学习)。</p>
<p><strong>特点：</strong>paddle 的性能也很不错，整体使用起来与
tensorflow
非常类似，拥有中文帮助文档，在百度内部也被用于推荐等任务。另外，配套了一个可视化框架
visualdl，与 tensorboard 也有异曲同工之妙。</p>
<h2 id="cntk">CNTK</h2>
<p><strong>概述：</strong>CNTK
是微软开源的深度学习工具包，它通过有向图将神经网络描述为一系列计算步骤。在有向图中，叶节点表示输入值或网络参数，而其他节点表示其输入上的矩阵运算。CNTK
允许用户非常轻松地实现和组合流行的模型，包括前馈
DNN，卷积网络（CNN）和循环网络（RNN /
LSTM）。与目前大部分框架一样，实现了自动求导，利用随机梯度下降方法进行优化。</p>
<p><strong>特点：</strong></p>
<ul>
<li>CNTK 性能较高，按照其官方的说法，比其他的开源框架性能都更高。</li>
<li>适合做语音，CNTK
本就是微软语音团队开源的，自然是更合适做语音任务，使用 RNN
等模型，以及在时空尺度分别进行卷积非常容易。</li>
</ul>
<h2 id="matconvnet">Matconvnet</h2>
<p><strong>概述：</strong>不同于各类深度学习框架广泛使用的语言
Python，MatConvnet 是用 matlab 作为接口语言的开源深度学习库，底层语言是
cuda。</p>
<p><strong>特点：</strong>因为是在 matlab 下面，所以 debug
的过程非常的方便，而且本身就有很多的研究者一直都使用 matlab 语言。</p>
<h2 id="deeplearning4j">Deeplearning4j</h2>
<p><strong>概述：</strong>不同于深度学习广泛应用的语言 Python，DL4J 是为
java 和 jvm 编写的开源深度学习库，支持各种深度学习模型。</p>
<p><strong>特点：</strong>DL4J 最重要的特点是支持分布式，可以在 Spark 和
Hadoop 上运行，支持分布式 CPU 和 GPU 运行。DL4J
是为商业环境，而非研究所设计的，因此更加贴近某些生产环境。</p>
<h2 id="chainer">Chainer</h2>
<p><strong>概述：</strong>chainer 也是一个基于 python
的深度学习框架，能够轻松直观地编写复杂的神经网络架构，在日本企业中应用广泛。</p>
<p><strong>特点：</strong> chainer 采用 “Define-by-Run”
方案，即通过实际的前向计算动态定义网络。更确切地说，chainer
存储计算历史而不是编程逻辑，pytorch 的动态图机制思想主要就来源于
chaine。</p>
<h2 id="lasagnetheano">Lasagne/Theano</h2>
<p><strong>概述：</strong> Lasagen 其实就是封装了的
theano，后者是一个很老牌的框架，在 2008 年的时候就由 Yoshua Bengio
领导的蒙特利尔 LISA 组开源了。</p>
<p><strong>特点：</strong> theano
的使用成本高，需要从底层开始写代码构建模型，Lasagen 对其进行了封装，使得
theano 使用起来更简单。</p>
<h2 id="darknet">Darknet</h2>
<p><strong>概述：</strong> Darknet 本身是 Joseph Redmon 为了 Yolo
系列开发的框架。</p>
<p><strong>特点：</strong> Darknet 几乎没有依赖库，是从 C 和 CUDA
开始撰写的深度学习开源框架，支持 CPU 和 GPU。Darknet跟 caffe
颇有几分相似之处，却更加轻量级，非常值得学习使用。</p>
<h2 id="模型的求导">模型的求导</h2>
<p>在上面的学习中经常可以看到很多框架具有自动求导(Automatic
Differentiation,AD)的功能，那么什么是自动求导功能呢，于是我又找了找资料记录如下：</p>
<p>最近在上关于 自动求导 (Automatic Differentiation, AD) 的课程 (<a
href="https://link.zhihu.com/?target=https%3A//harvard-iacs.github.io/2019-CS207/">CS207</a>)，正好来回答一下。
其实不只是 TensorFlow，Pytorch 这些为深度学习设计的库用到
AD，很多物理，化学等基础科学计算软件也在大量的使用
AD。而且，其实TensorFlow、Pytorch 也并非只能用于deep
learning，本质上他们是一种</p>
<blockquote>
<p>Tensor computation built on a tape-based autograd system
--引自Pytorch</p>
<p>张量计算建立在一个基于卷积的自动梯度系统之上(渣渣的自翻)</p>
</blockquote>
<p>自动求导分成两种模式，一种是 <code>Forward Mode</code>，另外一种是
<code>Reverse Mode</code>。一般的机器学习库用的后一种，原因后面说。</p>
<h3 id="forward-mode">Forward Mode</h3>
<p>基于的就是就最基本的 <code>链式法则 chain rule</code>,</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013102123.svg"
alt="equation" />
<figcaption aria-hidden="true">equation</figcaption>
</figure>
<p>这个 <code>Forward Mode</code> 就是用
<code>chain rule</code>，像剥洋葱一样一层一层算出来，以</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013102157.svg"
alt="equation (1)" />
<figcaption aria-hidden="true">equation (1)</figcaption>
</figure>
<p>为例。我们可以把他的计算图画出来。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013102221.jpg"
alt="v2-e9c6ceeb331fc63e511e749c685af544_720w" />
<figcaption
aria-hidden="true">v2-e9c6ceeb331fc63e511e749c685af544_720w</figcaption>
</figure>
<p>假如我要计算<span
class="math inline">\(f&#39;(\frac{\pi}{16})\)</span>，可以根据上面的图得到一个表格</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013102339.jpg"
alt="v2-084054f3b8b43c30ca32a7e33b0ae1b1_720w" />
<figcaption
aria-hidden="true">v2-084054f3b8b43c30ca32a7e33b0ae1b1_720w</figcaption>
</figure>
<p>那么上面这个表里，每一步我们既要算 forward 的值 <span
class="math inline">\(f(a)\)</span> ，也要算 backward 的值<span
class="math inline">\(f&#39;(a)\)</span>。</p>
<p><strong>有没有办法同时把这两个值算出来呢？</strong></p>
<p>首先引入一个新的概念，二元数。二元数其实跟复数差不多，也是一种实数的推广。我们回忆一下，一个复数可以写成这样的形式：</p>
<p>二元数其实跟复数差不多，也是一种实数的推广。我们回忆一下，一个复数可以写成这样的形式：</p>
<p><span class="math inline">\(z = a + ib\)</span> ; <span
class="math inline">\(i^2 = -1\)</span></p>
<p>对于复数的理解，一个比较直观的例子就是。本来实数都是在一个实数轴（x轴）的。复部
<span class="math inline">\(ib\)</span> 相当于多了一个 y 轴出来。</p>
<p>那么二元数是这个亚子：</p>
<p><span class="math inline">\(z = a + \epsilon b\)</span> ; <span
class="math inline">\(\epsilon^2 = 0\)</span></p>
<p>这个二元数很神奇的一个性质是，你带着他做运算，得出来的二元部 <span
class="math inline">\(\epsilon b\)</span>
前面的系数，就是导数。举个栗子， 我们要求</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013145302.svg"
alt="equation (4)" />
<figcaption aria-hidden="true">equation (4)</figcaption>
</figure>
<p>我们可以令 <span class="math inline">\(x = a + \epsilon
b\)</span>，所以</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013145314.svg"
alt="equation (5)" />
<figcaption aria-hidden="true">equation (5)</figcaption>
</figure>
<p>我们把上面的三角函数展开，</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013145332.svg"
alt="equation (6)" />
<figcaption aria-hidden="true">equation (6)</figcaption>
</figure>
<p>得到</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013145408.svg"
alt="equation (7)" />
<figcaption aria-hidden="true">equation (7)</figcaption>
</figure>
<p>可以看到，二元部 <span class="math inline">\(\cos(a)\)</span>
恰好就是原函数 <span class="math inline">\(\sin(a)\)</span> 的导数。</p>
<h3 id="reverse-mode">Reverse Mode</h3>
<p>这个模式就比较简单和直接了。就是说，上面那个表里面，我每次只计算每个“小运算”的梯度（也是是那个图里面的每个节点），最后我再根据
<code>chain rule</code> 把“小运算”们的梯度串起来。其实
<code>forward mode</code> 和 <code>reverse mode</code>
并没有本质的区别，只是说，<code>reverse mode</code>在计算梯度先不考虑
<code>chain rule</code>，最后再用 <code>chain rule</code>
把梯度组起来。而前者则是直接就应用 <code>chain rule</code>
来算梯度。</p>
<p>下面总结一下 <code>reverse mode</code> 的流程：</p>
<ul>
<li>创建计算图</li>
<li>计算前向传播的值及每个操作的梯度
<ul>
<li>这里没有 <code>chain rule</code> 的事</li>
<li>比如这个操作是乘法 <span class="math inline">\(x_3 =
x_1*x_2\)</span>，那么我们只需要把 <span
class="math inline">\(\frac{\partial x_3}{\partial x_2}\)</span> 以及
<span class="math inline">\(\frac{\partial x_3}{\partial x_1}\)</span>
算出来就好了</li>
</ul></li>
<li>反向计算梯度从最后一个节点（操作）开始：<span
class="math inline">\(\overline{x_N} = \frac{\partial f}{\partial x_N} =
1\)</span> , <span class="math inline">\(f = x_N\)</span></li>
<li>根据 <code>chain rule</code> 逐层推进 <span
class="math inline">\(\overline{x_{N-1}} = \frac{\partial f}{\partial
x_N}\frac{\partial x_N}{\partial x_{N-1}}\)</span></li>
<li>假如有多条求导路径，我们要把他们加起来，例如 <span
class="math inline">\(\overline{x_3} = \frac{\partial f}{\partial x_3} =
\frac{\partial f}{\partial x_4}\frac{\partial x_4}{\partial x_3} +
\frac{\partial f}{\partial x_5}\frac{\partial x_5}{\partial
x_3}\)</span></li>
</ul>
<p>举个栗子，我们要计算函数</p>
<figure>
<img
src="https://www.zhihu.com/equation?tex=+f%5Cleft%28x%2Cy%5Cright%29+%3D+xy+%2B+%5Cexp%5Cleft%28xy%5Cright%29+"
alt="[公式]" />
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<p>在点 <span class="math inline">\(a = (1,2)\)</span> 的导数</p>
<p>首先还是先把计算图画出来</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013112920.jpg"
alt="v2-96cc3ca7e23d04e7cadc721b547c94bf_720w" />
<figcaption
aria-hidden="true">v2-96cc3ca7e23d04e7cadc721b547c94bf_720w</figcaption>
</figure>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013112944.jpg"
alt="v2-9da449b7dea30cc4cfdb94d8c6bc7e85_720w" />
<figcaption
aria-hidden="true">v2-9da449b7dea30cc4cfdb94d8c6bc7e85_720w</figcaption>
</figure>
<p>我们逐层的抽丝剥茧，</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013113005.svg"
alt="equation (3)" />
<figcaption aria-hidden="true">equation (3)</figcaption>
</figure>
<h3 id="总结">总结</h3>
<ol type="1">
<li>可以很清楚的看到，在训练人工神经网络时常用的
<code>backpropagation</code> 也是属于 <code>reverse mode</code>
的。</li>
<li>假如我们要计算的梯度的函数是 <span class="math inline">\(f : R^m
\rightarrow R^n\)</span></li>
</ol>
<ul>
<li>如果 n 是相对比较大的话，用 <code>forward</code> 比较省计算</li>
<li>如果 m 是相对比较大的话，用 <code>reverse</code> 比较省计算</li>
</ul>
<h2 id="tensorflow与pytorch之争">TensorFlow与PyTorch之争</h2>
<h3 id="我们可以用-tensorflow-和-pytorch-构建什么">我们可以用 TensorFlow
和 PyTorch 构建什么？</h3>
<p>神经网络起初是被用于解决手写数字识别或用相机识别汽车注册车牌等简单的分类问题。但随着近来框架的发展以及英伟达高计算性能图形处理单元（GPU）的进步，我们可以在
TB
级的数据上训练神经网络并求解远远更加复杂的问题。一个值得提及的成就是在
TensorFlow 和 PyTorch 中实现的卷积神经网络在 ImageNet
上都达到了当前最佳的表现。训练后的模型可以用在不同的应用中，比如目标检测、图像语义分割等等。</p>
<p>尽管神经网络架构可以基于任何框架实现，但结果却并不一样。训练过程有大量参数都与框架息息相关。举个例子，如果你在
PyTorch 上训练一个数据集，那么你可以使用 GPU
来增强其训练过程，因为它们运行在 CUDA（一种 C++ 后端）上。TensorFlow
也能使用 GPU，但它使用的是自己内置的 GPU
加速。因此，根据你所选框架的不同，训练模型的时间也总是各不相同。</p>
<h3 id="pytorch-和-tensorflow-对比">PyTorch 和 TensorFlow 对比</h3>
<p>PyTorch 和 TensorFlow
的关键差异是它们执行代码的方式。这两个框架都基于基础数据类型张量（tensor）而工作。你可以将张量看作是下图所示的多维数组。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013154423.jpg"
alt="v2-eb587bbfe2fc8c7ea156f40148f9466d_720w" />
<figcaption
aria-hidden="true">v2-eb587bbfe2fc8c7ea156f40148f9466d_720w</figcaption>
</figure>
<p><strong>机制：动态图定义与静态图定义</strong></p>
<p>TensorFlow 框架由两个核心构建模块组成：</p>
<ul>
<li>一个用于定义计算图以及在各种不同硬件上执行这些图的运行时间的软件库。</li>
<li>一个具有许多优点的计算图（后面很快就会介绍这些优点）。</li>
</ul>
<p>计算图是一种将计算描述成有向图的抽象方式。图是一种由节点（顶点）和边构成的数据结构，是由有向的边成对连接的顶点的集合。</p>
<p>当你在 TensorFlow
中运行代码时，计算图是以静态方式定义的。与外部世界的所有通信都是通过
tf.Sessionobject 和 tf.Placeholder
执行，它们是在运行时会被外部数据替换的张量。例如，看看以下代码段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">15</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line">prod = a * b</span><br><span class="line">sum = a + b</span><br><span class="line">result = prod / sum</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p>下图是 TensorFlow
中运行代码之前以静态方式生成计算图的方式。计算图的核心优势是能实现并行化或依赖驱动式调度（dependency
driving scheduling），这能让训练速度更快，更有效率。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201014090128.jpg"
alt="v2-55783f66a4883d2a06ff911c3f5ff647_720w" />
<figcaption
aria-hidden="true">v2-55783f66a4883d2a06ff911c3f5ff647_720w</figcaption>
</figure>
<p>类似于 TensorFlow，PyTorch 也有两个核心模块：</p>
<ul>
<li>计算图的按需和动态构建</li>
<li>Autograd：执行动态图的自动微分</li>
</ul>
<p>可以在下图中看到，图会随着执行过程而改变和执行节点，没有特殊的会话接口或占位符。整体而言，这个框架与
Python 语言的整合更紧密，大多数时候感觉更本地化。因此，PyTorch 是更
Python 化的框架，而 TensorFlow 则感觉完全是一种新语言。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013155541.jpg"
alt="v2-01031e3c22483574cc325c29a6f30a22_720w" />
<figcaption
aria-hidden="true">v2-01031e3c22483574cc325c29a6f30a22_720w</figcaption>
</figure>
<p>根据你所用的框架，在软件领域有很大的不同。TensorFlow 提供了使用
TensorFlow Fold 库实现动态图的方式，而 PyTorch
的动态图是内置的。<strong>分布式训练</strong>PyTorch 和 TensorFlow
的一个主要差异特点是数据并行化。PyTorch 优化性能的方式是利用 Python
对异步执行的本地支持。而用 TensorFlow
时，你必须手动编写代码，并微调要在特定设备上运行的每个操作，以实现分布式训练。但是，你可以将
PyTorch 中的所有功能都复现到 TensorFlow
中，但这需要做很多工作。下面的代码片段展示了用 PyTorch
为模型实现分布式训练的简单示例：</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013160042.jpg"
alt="v2-e1b0acf03e0f77506053395808253a17_720w" />
<figcaption
aria-hidden="true">v2-e1b0acf03e0f77506053395808253a17_720w</figcaption>
</figure>
<p><strong>可视化</strong></p>
<p>在训练过程的可视化方面，TensorFlow
更有优势。可视化能帮助开发者跟踪训练过程以及实现更方便的调试。TensorFlow
的可视化库名为 TensorBoard。PyTorch 开发者则使用 Visdom，但是 Visdom
提供的功能很简单且有限，所以 TensorBoard
在训练过程可视化方面更好。TensorBoard 的特性：</p>
<ul>
<li>跟踪和可视化损失和准确度等指标</li>
<li>可视化计算图（操作和层）</li>
<li>查看权重、偏差或其它张量随时间变化的直方图</li>
<li>展示图像、文本和音频数据</li>
<li>分析 TensorFlow 程序</li>
</ul>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013160133.jpg"
alt="v2-453ad86b4424b3cb8a8677bdb367aa32_720w" />
<figcaption
aria-hidden="true">v2-453ad86b4424b3cb8a8677bdb367aa32_720w</figcaption>
</figure>
<p>Visdom 的特性</p>
<ul>
<li>处理回调</li>
<li>绘制图表和细节</li>
<li>管理环境</li>
</ul>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013160145.jpg"
alt="v2-6b37a9f7b32fa35d84514613a78f6169_720w" />
<figcaption
aria-hidden="true">v2-6b37a9f7b32fa35d84514613a78f6169_720w</figcaption>
</figure>
<p><strong>生产部署</strong></p>
<p>在将训练好的模型部署到生产方面，TensorFlow
显然是赢家。我们可以直接使用 TensorFlow serving 在 TensorFlow
中部署模型，这是一种使用了 REST Client API 的框架。使用 PyTorch
时，在最新的 1.0
稳定版中，生产部署要容易一些，但它没有提供任何用于在网络上直接部署模型的框架。你必须使用
Flask 或 Django 作为后端服务器。所以，如果要考虑性能，TensorFlow serving
可能是更好的选择。</p>
<p><strong>用 PyTorch 和 TensorFlow 定义一个简单的神经网络</strong></p>
<p>我们比较一下如何在 PyTorch 和 TensorFlow 中声明神经网络。在 PyTorch
中，神经网络是一个类，我们可以使用 torch.nn
软件包导入构建架构所必需的层。所有的层都首先在 <strong>init</strong>()
方法中声明，然后在 forward() 方法中定义输入 x
在网络所有层中的遍历方式。最后，我们声明一个变量模型并将其分配给定义的架构（model
= NeuralNet()）。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013162209.webp"
alt="v2-ed5b9a19003e316bf892e8322f8d372b_720w" />
<figcaption
aria-hidden="true">v2-ed5b9a19003e316bf892e8322f8d372b_720w</figcaption>
</figure>
<p>近期 Keras 被合并到了 TensorFlow 库中，这是一个使用 TensorFlow
作为后端的神经网络框架。从那时起，在 TensorFlow 中声明层的句法就与 Keras
的句法类似了。首先，我们声明变量并将其分配给我们将要声明的架构类型，这里的例子是一个
Sequential() 架构。接下来，我们使用 model.add()
方法以序列方式直接添加层。层的类型可以从 tf.layers
导入，如下代码片段所示：</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201013162223.webp"
alt="v2-ed5b9a19003e316bf892e8322f8d372b_720w (1)" />
<figcaption aria-hidden="true">v2-ed5b9a19003e316bf892e8322f8d372b_720w
(1)</figcaption>
</figure>
<h3 id="tensorflow-和-pytorch-的优缺点">TensorFlow 和 PyTorch
的优缺点</h3>
<p>TensorFlow和PyTorch各有其优缺点。</p>
<p><strong>TensorFlow 的优点：</strong></p>
<ul>
<li>简单的内置高级 API</li>
<li>使用 TensorBoard 可视化训练</li>
<li>通过 TensorFlow serving 容易实现生产部署</li>
<li>很容易的移动平台支持</li>
<li>开源</li>
<li>良好的文档和社区支持</li>
</ul>
<p><strong>TensorFlow 的缺点：</strong></p>
<ul>
<li>静态图</li>
<li>调试方法</li>
<li>难以快速修改</li>
</ul>
<p><strong>PyTorch 的优点</strong></p>
<ul>
<li>类 Python 的代码</li>
<li>动态图</li>
<li>轻松快速的编辑</li>
<li>良好的文档和社区支持</li>
<li>开源</li>
<li>很多项目都使用 PyTorch</li>
</ul>
<p><strong>PyTorch 的缺点：</strong></p>
<ul>
<li>可视化需要第三方</li>
<li>生产部署需要 API 服务器</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>框架</tag>
        <tag>Tensorflow</tag>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习笔记(四)---优化方法理解</title>
    <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)---%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>记录网络模型的各种优化</p>
<a id="more"></a>
<h2 id="超参数">超参数</h2>
<p>比如算法中的<strong>learning rate</strong> $ a $
（学习率）、<strong>iterations</strong> (梯度下降法循环的数量) 、$ L $
（隐藏层数目）、$ n^{[l]} $ （隐藏层单元数目）、<strong>choice of
activation
function</strong>（激活函数的选择）都需要你来设置，这些数字实际上控制了最后的参数$
W $ 和 $ b $
的值，所以它们被称作超参数。后面还有很多超参数我还有没学到，总的来讲就是能影响参数的更高级参数。</p>
<p>超参数的取值并没有明确的规定，这目前还是一个经验性的过程，新手上路最多的还是要不断的尝试，通过不断地修改超参数对比结果来不断修正最后找到一个相对合适的。</p>
<h2 id="偏差和方差">偏差和方差</h2>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201021152647.png"
alt="111" />
<figcaption aria-hidden="true">111</figcaption>
</figure>
<p>假设这就是数据集，如果给这个数据集拟合一条直线，可能得到一个逻辑回归拟合，但它并不能很好地拟合该数据，这是高偏差（<strong>high
bias</strong>）的情况，我们称为“欠拟合”（<strong>underfitting</strong>）。</p>
<p>相反的如果我们拟合一个非常复杂的分类器，比如深度神经网络或含有隐藏单元的神经网络，可能就非常适用于这个数据集，但是这看起来也不是一种很好的拟合方式分类器方差较高（<strong>high
variance</strong>），数据过度拟合（<strong>overfitting</strong>）。</p>
<h2 id="正则化">正则化</h2>
<p>深度学习可能存在过拟合问题——高方差，有两个解决方法，一个是正则化，另一个是准备更多的数据，这是非常可靠的方法，但你可能无法时时刻刻准备足够多的训练数据或者获取更多数据的成本很高，但正则化通常有助于避免过拟合或减少你的网络误差。</p>
<h3 id="l2范数">L2范数</h3>
<p><span class="math inline">\(\frac{\lambda}{2m}\)</span>乘以<span
class="math inline">\(w\)</span>范数的平方，其中<span
class="math inline">\(\left\| w \right\|_2^2\)</span>是<span
class="math inline">\(w\)</span>的欧几里德范数的平方，等于<span
class="math inline">\(w_{j}\)</span>（<span
class="math inline">\(j\)</span> 值从1到<span
class="math inline">\(n_{x}\)</span>）平方的和，也可表示为<span
class="math inline">\(w^{T}w\)</span>，也就是向量参数<span
class="math inline">\(w\)</span>
的欧几里德范数（2范数）的平方，此方法称为<span
class="math inline">\(L2\)</span>正则化，因为这里用了欧几里德范数，被称为向量参数<span
class="math inline">\(w\)</span>的<span
class="math inline">\(L2\)</span>范数。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201021162913.png"
alt="fa185e95684bbe6c0e9100164aff2ee5" />
<figcaption
aria-hidden="true">fa185e95684bbe6c0e9100164aff2ee5</figcaption>
</figure>
<p>因为<span
class="math inline">\(w\)</span>通常是一个高维参数矢量，已经可以表达高偏差问题，<span
class="math inline">\(w\)</span>可能包含有很多参数，我们不可能拟合所有参数，而<span
class="math inline">\(b\)</span>只是单个数字，所以<span
class="math inline">\(w\)</span>几乎涵盖所有参数，而不是<span
class="math inline">\(b\)</span>，如果加了参数<span
class="math inline">\(b\)</span>，其实也没太大影响，因为<span
class="math inline">\(b\)</span>只是众多参数中的一个，所以通常省略不计。</p>
<h3 id="l1范数">L1范数</h3>
<p>正则化，加的不是<span
class="math inline">\(L2\)</span>范数，而是正则项<span
class="math inline">\(\frac{\lambda}{m}\)</span>乘以<span
class="math inline">\(\sum_{j= 1}^{n_{x}}{|w|}\)</span>，<span
class="math inline">\(\sum_{j =1}^{n_{x}}{|w|}\)</span>也被称为参数<span
class="math inline">\(w\)</span>向量的<span
class="math inline">\(L1\)</span>范数，无论分母是<span
class="math inline">\(m\)</span>还是<span
class="math inline">\(2m\)</span>，它都是一个比例常量。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201022093917.png"
alt="5190dbc5a98db7a248499f54a04257cc" />
<figcaption
aria-hidden="true">5190dbc5a98db7a248499f54a04257cc</figcaption>
</figure>
<p>如果用的是<span class="math inline">\(L1\)</span>正则化，<span
class="math inline">\(w\)</span>最终会是稀疏的，也就是说<span
class="math inline">\(w\)</span>向量中有很多0，有人说这样有利于压缩模型，因为集合中参数均为0，存储模型所占用的内存更少。实际上，虽然<span
class="math inline">\(L1\)</span>正则化使模型变得稀疏，却没有降低太多存储内存，所以我认为这并不是<span
class="math inline">\(L1\)</span>正则化的目的，至少不是为了压缩模型，人们在训练网络时，越来越倾向于使用<span
class="math inline">\(L2\)</span>正则化。</p>
<h3 id="弗罗贝尼乌斯范数矩阵l2范数">弗罗贝尼乌斯范数（矩阵L2范数）</h3>
<p>正则项为<span class="math inline">\(\frac{\lambda
}{2m}{\sum\nolimits_{1}^{L}|| W^{[l]}}||^2\)</span>，我们称<span
class="math inline">\(||W^{\left[l\right]}||^2\)</span>为范数平方，这个矩阵范数<span
class="math inline">\(||W^{\left[l\right]}||^2\)</span>（即平方范数），被定义为矩阵中所有元素的平方求和。该矩阵范数被称作“弗罗贝尼乌斯范数”，用下标<span
class="math inline">\(F\)</span>标注”，鉴于线性代数中一些神秘晦涩的原因，我们不称之为“矩阵<span
class="math inline">\(L2\)</span>范数”，而称它为“弗罗贝尼乌斯范数”，矩阵<span
class="math inline">\(L2\)</span>范数听起来更自然，但鉴于一些大家无须知道的特殊原因，按照惯例，我们称之为“弗罗贝尼乌斯范数”，它表示一个矩阵中所有元素的平方和。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201022095410.png"
alt="a8336b2cfeed4128a23f20fab843d226" />
<figcaption
aria-hidden="true">a8336b2cfeed4128a23f20fab843d226</figcaption>
</figure>
<p>该如何使用该范数实现梯度下降呢？</p>
<p>这就是之前我们额外增加的正则化项，既然已经增加了这个正则项，现在我们要做的就是给<span
class="math inline">\(dW\)</span>加上这一项<span
class="math inline">\(\frac
{\lambda}{m}W^{[l]}\)</span>，然后计算这个更新项，使用新定义的<span
class="math inline">\(dW^{[l]}\)</span>，它的定义含有相关参数代价函数导数和，以及最后添加的额外正则项，这也是<span
class="math inline">\(L2\)</span>正则化有时被称为“权重衰减”的原因。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201022095606.png"
alt="dafb163da5b9c3ece677a7ebce05b680" />
<figcaption
aria-hidden="true">dafb163da5b9c3ece677a7ebce05b680</figcaption>
</figure>
<p>我们用$ dW<sup>{[l]}<span
class="math inline">\(的定义替换此处的\)</span>dW</sup>{[l]}<span
class="math inline">\(，可以看到，\)</span>W<sup>{[l]}<span
class="math inline">\(的定义被更新为\)</span>W</sup>{[l]}<span
class="math inline">\(减去学习率\)</span>$ 乘以<strong>backprop</strong>
再加上<span
class="math inline">\(\frac{\lambda}{m}W^{[l]}\)</span>。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201022095643.png"
alt="cba0f1c7a480139acb04e762e4fe57f8" />
<figcaption
aria-hidden="true">cba0f1c7a480139acb04e762e4fe57f8</figcaption>
</figure>
<p>该正则项说明，不论<span
class="math inline">\(W^{[l]}\)</span>是什么，我们都试图让它变得更小，实际上，相当于我们给矩阵W乘以<span
class="math inline">\((1 -
\alpha\frac{\lambda}{m})\)</span>倍的权重，矩阵<span
class="math inline">\(W\)</span>减去<span
class="math inline">\(\alpha\frac{\lambda}{m}\)</span>倍的它，也就是用这个系数<span
class="math inline">\((1-\alpha\frac{\lambda}{m})\)</span>乘以矩阵<span
class="math inline">\(W\)</span>，该系数小于1，因此<span
class="math inline">\(L2\)</span>范数正则化也被称为“权重衰减”，因为它就像一般的梯度下降，<span
class="math inline">\(W\)</span>被更新为少了<span
class="math inline">\(\alpha\)</span>乘以<strong>backprop</strong>输出的最初梯度值，同时<span
class="math inline">\(W\)</span>也乘以了这个系数，这个系数小于1，因此<span
class="math inline">\(L2\)</span>正则化也被称为“权重衰减”。</p>
<h3 id="dropout-正则化dropout-regularization">dropout 正则化（Dropout
Regularization）</h3>
<p>还有一个非常实用的正则化方法——“<strong>Dropout</strong>（随机失活）”，我们来看看它的工作原理。</p>
<p>dropout就是为每一层设置一个消除节点的概率，设置完节点概率，我们会消除一些节点，然后删除掉从该节点进出的连线，最后得到一个节点更少，规模更小的网络，然后用<strong>backprop</strong>方法进行训练。</p>
<p>直观上理解：不愿意把所有赌注都放在一个节点上，不愿意给任何一个输入加上太多权重，因为它可能会被删除，因此该单元将通过这种方式积极地传播开，并为单元的四个输入增加一点权重，通过传播所有权重，<strong>dropout</strong>将产生收缩权重的平方范数的效果，和之前讲的<span
class="math inline">\(L2\)</span>正则化类似。</p>
<p><strong>dropout</strong>一大缺点就是代价函数<span
class="math inline">\(J\)</span>不再被明确定义，每次迭代，都会随机移除一些节点，如果再三检查梯度下降的性能，实际上是很难进行复查的。</p>
<h3 id="early-stopping">early stopping</h3>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201022101655.png"
alt="f5fd5df8235145c54aece1a5bf7b31f6" />
<figcaption
aria-hidden="true">f5fd5df8235145c54aece1a5bf7b31f6</figcaption>
</figure>
<p>就是让迭代提前停止，找到一个w大小适中的点</p>
<h2 id="为什么正则化能防止过拟合">为什么正则化能防止过拟合</h2>
<p>根据上面的正则化方法的描述我们可以看出正则化主要就是在控制参数W的大小，要让参数W不要太大，太复杂。直观理解就是把多隐藏单元的权重设为0，于是基本上消除了这些隐藏单元的许多影响。如果是这种情况，这个被大大简化了的神经网络会变成一个很小的网络，小到如同一个逻辑回归单元，它会使这个网络从过度拟合的状态更接近高偏差状态。</p>
<p>但是<span
class="math inline">\(\lambda\)</span>会存在一个中间值，于是会有一个接近“<strong>Just
Right</strong>”的中间状态。</p>
<p>直观理解就是<span
class="math inline">\(\lambda\)</span>增加到足够大，<span
class="math inline">\(W\)</span>会接近于0，实际上是不会发生这种情况的，我们尝试消除或至少减少许多隐藏单元的影响，最终这个网络会变得更简单，这个神经网络越来越接近逻辑回归，我们直觉上认为大量隐藏单元被完全消除了，其实不然，实际上是该神经网络的所有隐藏单元依然存在，但是它们的影响变得更小了。神经网络变得更简单了，貌似这样更不容易发生过拟合。</p>
<p>其实这就是一个直觉经验，但是确实可以看到方差减小的结果。</p>
<h2 id="归一化输入normalizing-inputs">归一化输入（Normalizing
inputs）</h2>
<ul>
<li>零均值</li>
<li>归一化方差</li>
</ul>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201022101830.png"
alt="L2_week1_19" />
<figcaption aria-hidden="true">L2_week1_19</figcaption>
</figure>
<h2 id="梯度消失爆炸">梯度消失/爆炸</h2>
<p>深度神经所面临的一个问题就是梯度消失或梯度爆炸，也就是你训练神经网络的时候，导数或坡度有时会变得非常大，或者非常小，甚至于根据深度以指数方式变小，这加大了训练的难度。</p>
<h3 id="解决方法">解决方法</h3>
<p>这并不是完全的解决方法，但是可以减少影响。</p>
<p><span class="math inline">\(z = w_{1}x_{1} + w_{2}x_{2} + \ldots
+w_{n}x_{n}\)</span>，<span
class="math inline">\(b=0\)</span>，暂时忽略<span
class="math inline">\(b\)</span>，为了预防<span
class="math inline">\(z\)</span>值过大或过小，你可以看到<span
class="math inline">\(n\)</span>越大，你希望<span
class="math inline">\(w_{i}\)</span>越小，因为<span
class="math inline">\(z\)</span>是<span
class="math inline">\(w_{i}x_{i}\)</span>的和，如果你把很多此类项相加，希望每项值更小，最合理的方法就是设置<span
class="math inline">\(Var(w_{i})=\frac{1}{n}\)</span> 。即<span
class="math inline">\(w^{[l]} = np.random.randn(
\text{shape})*\text{np.}\text{sqrt}(\frac{1}{n^{[l-1]}})\)</span> ,
<span class="math inline">\(n^{[l - 1]}\)</span>就是我喂给第<span
class="math inline">\(l\)</span>层神经单元的数量（即第<span
class="math inline">\(l-1\)</span>层神经元数量）</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201022103557.png"
alt="e4114d7dc1c6242bd96cdadb457b8959" />
<figcaption
aria-hidden="true">e4114d7dc1c6242bd96cdadb457b8959</figcaption>
</figure>
<p>如果你是用的是<strong>Relu</strong>激活函数，而不是<span
class="math inline">\(\frac{1}{n}\)</span>，方差设置为<span
class="math inline">\(\frac{2}{n}\)</span>，效果会更好。</p>
<h2 id="mini-batch梯度下降">mini-batch梯度下降</h2>
<p>现在是大数据时代，训练集的样本数可能成百万上千万，如果每次正向传播一遍之后再反向进行梯度下降，那么一次传播的处理时间太慢了。</p>
<p>可以把训练集分割为小一点的子集训练，这些子集被取名为<strong>mini-batch</strong>，假设每一个子集中只有1000个样本，那么把其中的<span
class="math inline">\(x^{(1)}\)</span>到<span
class="math inline">\(x^{(1000)}\)</span>取出来，将其称为第一个子训练集，也叫做<strong>mini-batch</strong>，然后你再取出接下来的1000个样本，从<span
class="math inline">\(x^{(1001)}\)</span>到<span
class="math inline">\(x^{(2000)}\)</span>，然后再取1000个样本，以此类推。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023162136.png"
alt="112c45cf393d896833ffce29e14fe8bc" />
<figcaption
aria-hidden="true">112c45cf393d896833ffce29e14fe8bc</figcaption>
</figure>
<p>对<span
class="math inline">\(Y\)</span>也要进行相同处理，你也要相应地拆分<span
class="math inline">\(Y\)</span>的训练集，所以这是<span
class="math inline">\(Y^{\{1\}}\)</span>，然后从<span
class="math inline">\(y^{(1001)}\)</span>到<span
class="math inline">\(y^{(2000)}\)</span>，这个叫<span
class="math inline">\(Y^{\{2\}}\)</span>，一直到<span
class="math inline">\(Y^{\{ 5000\}}\)</span>。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023162155.png"
alt="609ea5be2140af929985951f2aab542c" />
<figcaption
aria-hidden="true">609ea5be2140af929985951f2aab542c</figcaption>
</figure>
<p>使用<strong>mini-batch</strong>梯度下降法，如果你作出成本函数在整个过程中的图，则并不是每次迭代都是下降的，特别是在每次迭代中，你要处理的是
$ X^{大括号t大括号}$ （后五个也有大括号，但是显示不出来）和<span
class="math inline">\(Y^{t}\)</span>，如果要作出成本函数<span
class="math inline">\(J^{t}\)</span>的图，而<span
class="math inline">\(J^{t}\)</span>只和<span
class="math inline">\(X^{t}\)</span>，<span
class="math inline">\(Y^{t}\)</span>有关，也就是每次迭代下你都在训练不同的样本集或者说训练不同的<strong>mini-batch</strong></p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023163405.png"
alt="b5c07d7dec7e54bed73cdcd43e79452d" />
<figcaption
aria-hidden="true">b5c07d7dec7e54bed73cdcd43e79452d</figcaption>
</figure>
<h2
id="指数加权平均数exponentially-weighted-averages">指数加权平均数（Exponentially
weighted averages）</h2>
<h3 id="什么是指数加权平均数">什么是指数加权平均数</h3>
<p>在我的理解里面这是一种参考当前时刻之前一部分时间段的内的数据的一中平均算法，这个时间段的长度由
<span class="math inline">\(\beta\)</span> 确定，时间长度大约为<span
class="math inline">\(\frac{1}{(1-\beta)}\)</span> 。</p>
<p>计算指数加权平均数的关键方程。</p>
<p><span class="math inline">\(v_t=\beta v_{t-1}+(1-\beta
)\theta_t\)</span></p>
<p><span
class="math inline">\(\beta=0.9\)</span>的时候，得到的结果是红线，如果它更接近于1，比如0.98，结果就是绿线，如果<span
class="math inline">\(\beta\)</span>小一点，如果是0.5，结果就是黄线。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023163627.png"
alt="6f5438fde578ef4285059d85976d52ed" />
<figcaption
aria-hidden="true">6f5438fde578ef4285059d85976d52ed</figcaption>
</figure>
<p>同样的公式，<span class="math inline">\({v}_{t}=\beta
{v}_{t-1}+(1-\beta ){\theta }_{t}\)</span></p>
<p>使<span
class="math inline">\(\beta=0.9\)</span>，写下相应的几个公式，所以在执行的时候，<span
class="math inline">\(t\)</span>从0到1到2到3，<span
class="math inline">\(t\)</span>的值在不断增加，为了更好地分析，我写的时候使得<span
class="math inline">\(t\)</span>的值不断减小，然后继续往下写。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023163648.png"
alt="9ab7565d5a3e13a9a525ec6d2f119a79" />
<figcaption
aria-hidden="true">9ab7565d5a3e13a9a525ec6d2f119a79</figcaption>
</figure>
<p>如果你把这些式子合并，</p>
<p><span class="math inline">\(v_{100} = 0.1\theta_{100} + 0.1 \times
0.9 \theta_{99} + 0.1 \times {(0.9)}^{2}\theta_{98} + 0.1 \times
{(0.9)}^{3}\theta_{97} + 0.1 \times {(0.9)}^{4}\theta_{96} +
\ldots\)</span></p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023163820.png"
alt="a3f97d59db202127014297ceccf1aacb" />
<figcaption
aria-hidden="true">a3f97d59db202127014297ceccf1aacb</figcaption>
</figure>
<p>计算<span
class="math inline">\(v_{100}\)</span>是通过，把两个函数对应的元素，然后求和，用这个数值100号数据值乘以0.1，99号数据值乘以0.1乘以<span
class="math inline">\({(0.9)}^{2}\)</span>，这是第二项，以此类推，所以选取的是每日温度，将其与指数衰减函数相乘，然后求和，就得到了<span
class="math inline">\(v_{100}\)</span>。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023163909.png"
alt="880dbafaccbd93a4ab0a92a9b8607956" />
<figcaption
aria-hidden="true">880dbafaccbd93a4ab0a92a9b8607956</figcaption>
</figure>
<p>指数加权平均数公式的好处之一在于，它占用极少内存，电脑内存中只占用一行数字而已，然后把最新数据代入公式，不断覆盖就可以了，正因为这个原因，其效率，它基本上只占用一行代码，计算指数加权平均数也只占用单行数字的存储和内存，当然它并不是最好的，也不是最精准的计算平均数的方法。如果你要计算移动窗，你直接算出过去10天的总和，过去50天的总和，除以10和50就好，如此往往会得到更好的估测。但缺点是，如果保存所有最近的温度数据，和过去10天的总和，必须占用更多的内存，执行更加复杂，计算成本也更加高昂。</p>
<h3
id="指数加权平均的偏差修正bias-correction-in-exponentially-weighted-averages">指数加权平均的偏差修正（Bias
correction in exponentially weighted averages）</h3>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023164324.png"
alt="26a3c3022a7f7ae7ba0cd27fc74cbcf6" />
<figcaption
aria-hidden="true">26a3c3022a7f7ae7ba0cd27fc74cbcf6</figcaption>
</figure>
<p>在实际使用中因为我们初始化<span class="math inline">\(v_{0} =
0\)</span>，所以在开始的时候可能会出现紫线的情况，与绿的的预估情况出现偏差，在前期不能很好的预测出当日温度。</p>
<p>有个办法可以修改这一估测，让估测变得更好，更准确，特别是在估测初期，也就是不用<span
class="math inline">\(v_{t}\)</span>，而是用<span
class="math inline">\(\frac{v_{t}}{1-
\beta^{t}}\)</span>，t就是现在的天数。举个具体例子，当<span
class="math inline">\(t=2\)</span>时，<span class="math inline">\(1 -
\beta^{t} = 1 -  {0.98}^{2} =
0.0396\)</span>，因此对第二天温度的估测变成了<span
class="math inline">\(\frac{v_{2}}{0.0396} =\frac{0.0196\theta_{1}
+  0.02\theta_{2}}{0.0396}\)</span>，也就是<span
class="math inline">\(\theta_{1}\)</span>和<span
class="math inline">\(\theta_{2}\)</span>的加权平均数，并去除了偏差。你会发现随着<span
class="math inline">\(t\)</span>增加，<span
class="math inline">\(\beta^{t}\)</span>接近于0，所以当<span
class="math inline">\(t\)</span>很大的时候，偏差修正几乎没有作用，因此当<span
class="math inline">\(t\)</span>较大的时候，紫线基本和绿线重合了。不过在开始学习阶段，你才开始预测热身练习，偏差修正可以帮助你更好预测温度，偏差修正可以帮助你使结果从紫线变成绿线。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023164640.png"
alt="f602c9d517a7f6c01fe18171dade17e6" />
<figcaption
aria-hidden="true">f602c9d517a7f6c01fe18171dade17e6</figcaption>
</figure>
<h2
id="动量梯度下降法gradient-descent-with-momentum">动量梯度下降法（Gradient
descent with Momentum）</h2>
<p>动量梯度下降法，运行速度几乎总是快于标准的梯度下降算法，简而言之，基本的想法就是计算梯度的指数加权平均数，并利用该梯度更新你的权重</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023165032.png"
alt="cc2d415b8ccda9fdaba12c575d4d3c4b" />
<figcaption
aria-hidden="true">cc2d415b8ccda9fdaba12c575d4d3c4b</figcaption>
</figure>
<p>在上图梯度中，你会发现这些纵轴上的摆动平均值接近于零，所以在纵轴方向，你希望放慢一点，平均过程中，正负数相互抵消，所以平均值接近于零。但在横轴方向，所有的微分都指向横轴方向，因此横轴方向的平均值仍然较大，因此用算法几次迭代后，你发现动量梯度下降法，最终纵轴方向的摆动变小了，横轴方向运动更快，因此你的算法走了一条更加直接的路径，在抵达最小值的路上减少了摆动。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023164850.png"
alt="89d51f9b5882cf226111b2c0eda2f3e3" />
<figcaption
aria-hidden="true">89d51f9b5882cf226111b2c0eda2f3e3</figcaption>
</figure>
<h2 id="rmsprop">RMSprop</h2>
<p>你们知道了动量（<strong>Momentum</strong>）可以加快梯度下降，还有一个叫做<strong>RMSprop</strong>的算法，全称是<strong>root
mean square prop</strong>算法，它也可以加速梯度下降。</p>
<p>回忆一下我们之前的例子，如果你执行梯度下降，虽然横轴方向正在推进，但纵轴方向会有大幅度摆动，为了分析这个例子，假设纵轴代表参数<span
class="math inline">\(b\)</span>，横轴代表参数<span
class="math inline">\(W\)</span>，可能有<span
class="math inline">\(W_{1}\)</span>，<span
class="math inline">\(W_{2}\)</span>或者其它重要的参数，为了便于理解，被称为<span
class="math inline">\(b\)</span>和<span
class="math inline">\(W\)</span>。</p>
<p>所以，你想减缓<span
class="math inline">\(b\)</span>方向的学习，即纵轴方向，同时加快，至少不是减缓横轴方向的学习，<strong>RMSprop</strong>算法可以实现这一点。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023171734.png"
alt="553ee26f6efd82d9996dec5f77e3f12e" />
<figcaption
aria-hidden="true">553ee26f6efd82d9996dec5f77e3f12e</figcaption>
</figure>
<p>记得在横轴方向或者在例子中的<span
class="math inline">\(W\)</span>方向，我们希望学习速度快，而在垂直方向，也就是例子中的<span
class="math inline">\(b\)</span>方向，我们希望减缓纵轴上的摆动，所以有了<span
class="math inline">\(S_{dW}\)</span>和<span
class="math inline">\(S_{db}\)</span>。你看这些微分，垂直方向的要比水平方向的大得多，所以斜率在<span
class="math inline">\(b\)</span>方向特别大，所以这些微分中，<span
class="math inline">\(db\)</span>较大，<span
class="math inline">\(dW\)</span>较小，因为函数的倾斜程度，在纵轴上，也就是b方向上要大于在横轴上，也就是<span
class="math inline">\(W\)</span>方向上。<span
class="math inline">\(db\)</span>的平方较大，所以<span
class="math inline">\(S_{db}\)</span>也会较大，而相比之下，<span
class="math inline">\(dW\)</span>会小一些，亦或<span
class="math inline">\(dW\)</span>平方会小一些，因此<span
class="math inline">\(S_{dW}\)</span>会小一些，结果就是纵轴上的更新要被一个较大的数相除，就能消除摆动，而水平方向的更新则被较小的数相除。</p>
<p>如果<span
class="math inline">\(S_{dW}\)</span>的平方根趋近于0怎么办？得到的答案就非常大，为了确保数值稳定，在实际操练的时候，你要在分母上加上一个很小很小的<span
class="math inline">\(\varepsilon\)</span>，<span
class="math inline">\(\varepsilon\)</span>是多少没关系，<span
class="math inline">\(10^{-8}\)</span>是个不错的选择，这只是保证数值能稳定一些。</p>
<h2 id="adam-优化算法adam-optimization-algorithm">Adam 优化算法(Adam
optimization algorithm)</h2>
<p><strong>Adam</strong>优化算法基本上就是将<strong>Momentum</strong>和<strong>RMSprop</strong>结合在一起</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023172610.png"
alt="9ca9bfc160d53b23ea0d1164e6accffe" />
<figcaption
aria-hidden="true">9ca9bfc160d53b23ea0d1164e6accffe</figcaption>
</figure>
<p><strong>Adam</strong>算法结合了<strong>Momentum</strong>和<strong>RMSprop</strong>梯度下降法，并且是一种极其常用的学习算法，被证明能有效适用于不同神经网络，适用于广泛的结构。</p>
<p>本算法中有很多超参数，超参数学习率<span
class="math inline">\(a\)</span>很重要，也经常需要调试，你可以尝试一系列值，然后看哪个有效。<span
class="math inline">\(\beta_{1}\)</span>常用的缺省值为0.9，这是dW的移动平均数，也就是<span
class="math inline">\(dW\)</span>的加权平均数，这是<strong>Momentum</strong>涉及的项。至于超参数<span
class="math inline">\(\beta_{2}\)</span>，<strong>Adam</strong>论文作者，也就是<strong>Adam</strong>算法的发明者，推荐使用0.999，这是在计算<span
class="math inline">\({(dW)}^{2}\)</span>以及<span
class="math inline">\({(db)}^{2}\)</span>的移动加权平均值，关于<span
class="math inline">\(\varepsilon\)</span>的选择其实没那么重要，<strong>Adam</strong>论文的作者建议<span
class="math inline">\(\varepsilon\)</span>为<span
class="math inline">\(10^{-8}\)</span>，但你并不需要设置它，因为它并不会影响算法表现。但是在使用<strong>Adam</strong>的时候，人们往往使用缺省值即可，<span
class="math inline">\(\beta_{1}\)</span>，<span
class="math inline">\(\beta_{2}\)</span>和<span
class="math inline">\(\varepsilon\)</span>都是如此。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023172644.png"
alt="e9858303cd62eacc21759b16a121ff58" />
<figcaption
aria-hidden="true">e9858303cd62eacc21759b16a121ff58</figcaption>
</figure>
<h2 id="学习率衰减learning-rate-decay">学习率衰减(Learning rate
decay)</h2>
<p>慢慢减少<span
class="math inline">\(a\)</span>的本质在于，在学习初期，你能承受较大的步伐，但当开始收敛的时候，小一些的学习率能让你步伐小一些。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023185637.png"
alt="7c4141aeec2ef4afc6aa534a486a34c8" />
<figcaption
aria-hidden="true">7c4141aeec2ef4afc6aa534a486a34c8</figcaption>
</figure>
<p>你应该拆分成不同的<strong>mini-batch</strong>，第一次遍历训练集叫做第一代。第二次就是第二代，依此类推，你可以将<span
class="math inline">\(a\)</span>学习率设为<span class="math inline">\(a=
\frac{1}{1 + decayrate *
\text{epoch}\text{-num}}a_{0}\)</span>（<strong>decay-rate</strong>称为衰减率，<strong>epoch-num</strong>为代数，<span
class="math inline">\(\alpha_{0}\)</span>为初始学习率），注意这个衰减率是另一个你需要调整的超参数。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023185644.png"
alt="7e0edfb697e8262dc39a040a987c62bd" />
<figcaption
aria-hidden="true">7e0edfb697e8262dc39a040a987c62bd</figcaption>
</figure>
<p>除了这个学习率衰减的公式，人们还会用其它的公式。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023185740.png"
alt="e1b6dc57b8b73ecf5ff400852c4f7086" />
<figcaption
aria-hidden="true">e1b6dc57b8b73ecf5ff400852c4f7086</figcaption>
</figure>
<h2 id="调试超参数">调试超参数</h2>
<p>最为广泛的学习应用是<span
class="math inline">\(a\)</span>，学习速率是需要调试的最重要的超参数。</p>
<p>除了<span
class="math inline">\(a\)</span>，还有一些参数需要调试，例如<strong>Momentum</strong>参数<span
class="math inline">\(\beta\)</span>，0.9就是个很好的默认值。我还会调试<strong>mini-batch</strong>的大小，以确保最优算法运行有效。我还会经常调试隐藏单元数目。</p>
<p>当应用<strong>Adam</strong>算法时，事实上，我从不调试<span
class="math inline">\(\beta_{1}\)</span>，<span
class="math inline">\({\beta}_{2}\)</span>和<span
class="math inline">\(\varepsilon\)</span>，我总是选定其分别为0.9，0.999和<span
class="math inline">\(10^{-8}\)</span>。</p>
<p>当你给超参数取值时，另一个惯例是采用由粗糙到精细的策略。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023190403.png"
alt="c3b248ac8ca2cf646d5b705270e01e78" />
<figcaption
aria-hidden="true">c3b248ac8ca2cf646d5b705270e01e78</figcaption>
</figure>
<p>比如在二维的那个例子中，你进行了取值，也许你会发现效果最好的某个点，也许这个点周围的其他一些点效果也很好，那在接下来要做的是放大这块小区域（小蓝色方框内），然后在其中更密集得取值或随机取值，聚集更多的资源，在这个蓝色的方格中搜索，如果你怀疑这些超参数在这个区域的最优结果，那在整个的方格中进行粗略搜索后，你会知道接下来应该聚焦到更小的方格中。在更小的方格中，你可以更密集得取点。所以这种从粗到细的搜索也经常使用。</p>
<h2
id="为超参数选择合适的范围using-an-appropriate-scale-to-pick-hyperparameters">为超参数选择合适的范围（Using
an appropriate scale to pick hyperparameters）</h2>
<p>在超参数范围中，随机取值可以提升你的搜索效率。但随机取值并不是在有效范围内的随机均匀取值，而是选择合适的标尺，用于探究这些超参数，这很重要。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023191011.png"
alt="651422f74439fd7e648e364d26d21485" />
<figcaption
aria-hidden="true">651422f74439fd7e648e364d26d21485</figcaption>
</figure>
<p>看看这个例子，假设你在搜索超参数<span
class="math inline">\(a\)</span>（学习速率），假设你怀疑其值最小是0.0001或最大是1。如果你画一条从0.0001到1的数轴，沿其随机均匀取值，那90%的数值将会落在0.1到1之间，结果就是，在0.1到1之间，应用了90%的资源，而在0.0001到0.1之间，只有10%的搜索资源，这看上去不太对。</p>
<p>反而，用对数标尺搜索超参数的方式会更合理，因此这里不使用线性轴，分别依次取0.0001，0.001，0.01，0.1，1，在对数轴上均匀随机取点，这样，在0.0001到0.001之间，就会有更多的搜索资源可用，还有在0.001到0.01之间等等。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023191028.png"
alt="08307acea7c8db95c1479c611189dbfa" />
<figcaption
aria-hidden="true">08307acea7c8db95c1479c611189dbfa</figcaption>
</figure>
<p>所以在<strong>Python</strong>中，你可以这样做，使<code>r=-4*np.random.rand()</code>，然后<span
class="math inline">\(a\)</span>随机取值，$ a =10^{r}<span
class="math inline">\(，所以，第一行可以得出\)</span>r <span
class="math inline">\(，那么\)</span>a $，所以最左边的数字是<span
class="math inline">\(10^{-4}\)</span>，最右边是<span
class="math inline">\(10^{0}\)</span>。</p>
<h2
id="归一化网络的激活函数normalizing-activations-in-a-network">归一化网络的激活函数（Normalizing
activations in a network）</h2>
<p>对每一层的Z进行归一化</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023191837.png"
alt="e10ea98faa1ce9fe86ec8bf9f4fef71e" />
<figcaption
aria-hidden="true">e10ea98faa1ce9fe86ec8bf9f4fef71e</figcaption>
</figure>
<p>现在我们已把这些<span
class="math inline">\(z\)</span>值标准化，化为含平均值0和标准单位方差，所以<span
class="math inline">\(z\)</span>的每一个分量都含有平均值0和方差1，但我们不想让隐藏单元总是含有平均值0和方差1，也许隐藏单元有了不同的分布会有意义，所以我们所要做的就是计算，我们称之为<span
class="math inline">\({\tilde{z}}^{(i)}\)</span>，<span
class="math inline">\({\tilde{z}}^{(i)}= \gamma z_{\text{norm}}^{(i)}
+\beta\)</span>，这里<span class="math inline">\(\gamma\)</span>和<span
class="math inline">\(\beta\)</span>是你模型的学习参数，所以我们使用梯度下降或一些其它类似梯度下降的算法，比如<strong>Momentum</strong>或者<strong>Nesterov</strong>，<strong>Adam</strong>，你会更新<span
class="math inline">\(\gamma\)</span>和<span
class="math inline">\(\beta\)</span>，正如更新神经网络的权重一样。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023191908.png"
alt="3d494a1d3fb25f7fd67f1bdbf8d8e464" />
<figcaption
aria-hidden="true">3d494a1d3fb25f7fd67f1bdbf8d8e464</figcaption>
</figure>
<p>请注意<span class="math inline">\(\gamma\)</span>和<span
class="math inline">\(\beta\)</span>的作用是，你可以随意设置<span
class="math inline">\({\tilde{z}}^{(i)}\)</span>的平均值，事实上，如果<span
class="math inline">\(\gamma= \sqrt{\sigma^{2}
+\varepsilon}\)</span>，如果<span
class="math inline">\(\gamma\)</span>等于这个分母项（<span
class="math inline">\(z_{\text{norm}}^{(i)} = \frac{z^{(i)}
-\mu}{\sqrt{\sigma^{2} +\varepsilon}}\)</span>中的分母），<span
class="math inline">\(\beta\)</span>等于<span
class="math inline">\(\mu\)</span>，这里的这个值是<span
class="math inline">\(z_{\text{norm}}^{(i)}= \frac{z^{(i)} -
\mu}{\sqrt{\sigma^{2} + \varepsilon}}\)</span>中的<span
class="math inline">\(\mu\)</span>，那么<span
class="math inline">\(\gamma z_{\text{norm}}^{(i)}
+\beta\)</span>的作用在于，它会精确转化这个方程，如果这些成立（<span
class="math inline">\(\gamma =\sqrt{\sigma^{2} + \varepsilon},\beta
=\mu\)</span>），那么<span class="math inline">\({\tilde{z}}^{(i)} =
z^{(i)}\)</span>。</p>
<p>通过对<span class="math inline">\(\gamma\)</span>和<span
class="math inline">\(\beta\)</span>合理设定，规范化过程，即这四个等式，从根本来说，只是计算恒等函数，通过赋予<span
class="math inline">\(\gamma\)</span>和<span
class="math inline">\(\beta\)</span>其它值，可以使你构造含其它平均值和方差的隐藏单元值。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023191937.png"
alt="6216dd90d3483f05f08bd8dc86fc7df6" />
<figcaption
aria-hidden="true">6216dd90d3483f05f08bd8dc86fc7df6</figcaption>
</figure>
<h2 id="softmax-回归softmax-regression">Softmax 回归（Softmax
regression）</h2>
<p><strong>Softmax</strong>回归主要用来做多分类任务</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023192500.png"
alt="e65ba7b81d0b02d021c33bf0094f4059" />
<figcaption
aria-hidden="true">e65ba7b81d0b02d021c33bf0094f4059</figcaption>
</figure>
<p>让你的网络做到这一点的标准模型要用到<strong>Softmax</strong>层，以及输出层来生成输出，让我把式子写下来，然后回过头来，就会对<strong>Softmax</strong>的作用有一点感觉了。</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023192523.png"
alt="97ab8f2af0788776bdd486c5f4f40354" />
<figcaption
aria-hidden="true">97ab8f2af0788776bdd486c5f4f40354</figcaption>
</figure>
<p>损失函数：</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023192609.png"
alt="ed6ccb8dc9e65953f383a3bb774e8f53" />
<figcaption
aria-hidden="true">ed6ccb8dc9e65953f383a3bb774e8f53</figcaption>
</figure>
<p>梯度下降：</p>
<figure>
<img
src="http://zchsakura-blog.oss-cn-beijing.aliyuncs.com/20201023192636.png"
alt="c357c15e4133152bd8bb262789e71765" />
<figcaption
aria-hidden="true">c357c15e4133152bd8bb262789e71765</figcaption>
</figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>正则化</tag>
        <tag>归一化</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫常用操作笔记</title>
    <url>/%E7%88%AC%E8%99%AB%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>记录一些常用的代码，免得老去翻代码</p>
<a id="more"></a>
<h3 id="配置">0.配置</h3>
<p><strong>创建项目</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy startproject adb</span><br></pre></td></tr></table></figure>
<p><strong>创建爬虫</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd adb</span><br><span class="line">scrapy genspider 爬虫名字 ***.com</span><br></pre></td></tr></table></figure>
<p><strong>解释器地址</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\Anaconda3\Lib\site-packages\scrapy\cmdline.py</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crawl 爬虫名字</span><br></pre></td></tr></table></figure>
<h3 id="翻页">1.翻页</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 翻页</span></span><br><span class="line">next_page = response.xpath(<span class="string">'//div[@class="page"]/a[contains(text(),"下一页")]/@href'</span>).extract_first()</span><br><span class="line"><span class="keyword">if</span> next_page:</span><br><span class="line">	next_url = <span class="string">'https://www.2345daohang.com'</span> + next_page</span><br><span class="line">	<span class="keyword">yield</span> scrapy.Request(next_url, callback=self.bookList, meta=&#123;<span class="string">'category'</span>: response.meta[<span class="string">'category'</span>]&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="content处理">2.content处理</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">content = element.xpath(<span class="string">'string(.)'</span>).replace(<span class="string">'\xa0'</span>, <span class="string">''</span>).replace(<span class="string">'a("conten");'</span>, <span class="string">''</span>).split(<span class="string">'\n'</span>)</span><br><span class="line">item[<span class="string">'content'</span>] = [i <span class="keyword">for</span> i <span class="keyword">in</span> content <span class="keyword">if</span> i != <span class="string">''</span>]</span><br></pre></td></tr></table></figure>
<h3 id="批量入库">3.批量入库</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*-coding:utf-8-*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">filename = <span class="string">"******\\yangsheng_info.csv"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'r'</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    data = list(reader)</span><br><span class="line">    data.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(<span class="string">'182.92.226.**'</span>, <span class="string">'root'</span>, <span class="string">'密码'</span>, <span class="string">'theOld'</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">sql = <span class="string">"INSERT INTO main_data_tougaolanmu(theme,name,content) VALUES(%s,%s,%s)"</span></span><br><span class="line">cursor.executemany(sql, data)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"数据库导入操作"</span>)</span><br><span class="line"></span><br><span class="line">db.commit()</span><br><span class="line">db.close</span><br></pre></td></tr></table></figure>
<h3 id="逐条入库">4.逐条入库</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*-coding:utf-8-*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">filename = <span class="string">"***************\\minsu_info.csv"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'r'</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    data = list(reader)</span><br><span class="line">    data.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(<span class="string">'182.92.226.**'</span>, <span class="string">'root'</span>, <span class="string">'密码'</span>, <span class="string">'theOld'</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> dd <span class="keyword">in</span> data:</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    sql1 = <span class="string">"SELECT id from user_userInfo WHERE nickname = %s"</span></span><br><span class="line">    <span class="keyword">if</span> dd[<span class="number">1</span>] == <span class="string">'佚名'</span>:</span><br><span class="line">        dd[<span class="number">1</span>] = <span class="string">'官方2号'</span></span><br><span class="line">    cursor.execute(sql1, dd[<span class="number">1</span>])  <span class="comment"># 执行SQL语句</span></span><br><span class="line">    results = cursor.fetchall()  <span class="comment"># 获取所有记录列表</span></span><br><span class="line">    <span class="keyword">if</span> results:</span><br><span class="line">        sql2 = <span class="string">"INSERT INTO main_data_tougaolanmu(secondTypeId,name,userId,content,modifiedTime) VALUES(38,%s,%s,%s,NOW())"</span></span><br><span class="line">        dad = dd</span><br><span class="line">        dad[<span class="number">1</span>] = results[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 执行SQL语句</span></span><br><span class="line">            cursor.execute(sql2, dad)</span><br><span class="line">            <span class="comment"># 提交修改</span></span><br><span class="line">            db.commit()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="comment"># 发生错误时回滚</span></span><br><span class="line">            print(<span class="string">'出错1'</span>)</span><br><span class="line">            db.rollback()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sql3 = <span class="string">"INSERT INTO user_userInfo(nickname) VALUES(%s)"</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 执行SQL语句</span></span><br><span class="line">            cursor.execute(sql3, dd[<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 提交修改</span></span><br><span class="line">            db.commit()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="comment"># 发生错误时回滚</span></span><br><span class="line">            print(<span class="string">'出错2'</span>)</span><br><span class="line">            db.rollback()</span><br><span class="line">        cursor.execute(sql1, dd[<span class="number">1</span>])  <span class="comment"># 执行SQL语句</span></span><br><span class="line">        result = cursor.fetchall()  <span class="comment"># 获取所有记录列表</span></span><br><span class="line">        sql4 = <span class="string">"INSERT INTO main_data_tougaolanmu(secondTypeId,name,userId,content,modifiedTime) VALUES(38,%s,%s,%s,NOW())"</span></span><br><span class="line">        dad = dd</span><br><span class="line">        dad[<span class="number">1</span>] = result[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 执行SQL语句</span></span><br><span class="line">            cursor.execute(sql4, dad)</span><br><span class="line">            <span class="comment"># 提交修改</span></span><br><span class="line">            db.commit()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">'出错3'</span>)</span><br><span class="line">            <span class="comment"># 发生错误时回滚</span></span><br><span class="line">            db.rollback()</span><br><span class="line">    print(i, results)</span><br><span class="line"></span><br><span class="line">db.close</span><br></pre></td></tr></table></figure>
<h3 id="获取html">5.获取HTML</h3>
<p>scrapy的原生的<code>response</code>可以直接调用<code>.text()</code>函数，但是当<code>response</code>调用过<code>xpath</code>之后虽然使用<code>dir()</code>显示还是有<code>text</code>属性但是并不能调用，此时可以使用<code>getall()</code>获取对应的html，之后再用正则表达式，<code>split()</code>之类的进行数据的处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">content = response.xpath(<span class="string">'//div[@class="ct tt zooms"]'</span>)[<span class="number">0</span>].getall()[<span class="number">0</span>]</span><br><span class="line">item[<span class="string">'content'</span>] = re.sub(<span class="string">r'href="([^"])*[^=k]"'</span>, <span class="string">""</span>, content)</span><br></pre></td></tr></table></figure>
<h3 id="创建csv">6.创建CSV</h3>
<figure class="highlight python"><figcaption><span>csv_init.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'../../book_info.csv'</span>, <span class="string">'a'</span>, encoding=<span class="string">"utf-8"</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> file_obj:</span><br><span class="line">    writer = csv.writer(file_obj)</span><br><span class="line">    row = [<span class="string">"category"</span>, <span class="string">"name"</span>, <span class="string">"cover"</span>, <span class="string">"author"</span>, <span class="string">"intro"</span>]</span><br><span class="line">    writer.writerow(row)</span><br></pre></td></tr></table></figure>
<h3 id="管道">7.管道</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'11_1900.csv'</span>, <span class="string">'a'</span>, encoding=<span class="string">"utf-8"</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> file_obj:</span><br><span class="line">    writer = csv.writer(file_obj)</span><br><span class="line">    row = [item[<span class="string">"name"</span>], item[<span class="string">"othername"</span>], item[<span class="string">'author'</span>], item[<span class="string">'country'</span>], item[<span class="string">'time'</span>], item[<span class="string">'intro'</span>]]</span><br><span class="line">    writer.writerow(row)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>python</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>研究生组会</title>
    <url>/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%BB%84%E4%BC%9A/</url>
    <content><![CDATA[<p>记录组会内容</p>
<a id="more"></a>
<h1 id="section">2020.10.21</h1>
<h2 id="augfpn">augFPN</h2>
<p>FPN中特征金字塔</p>
<p>问题：</p>
<ul>
<li>层间语义差异</li>
<li>最高层特征信息随时</li>
<li>roi的启发式分配策略</li>
</ul>
<p>提出augFPN</p>
<ul>
<li>特征融合前使用相通的监督信号，缩小于一差距
<ul>
<li>共享权重</li>
<li>只在训练时用</li>
</ul></li>
<li>残差特征增强
<ul>
<li>使用空间信息</li>
</ul></li>
<li>软roi选择</li>
</ul>
<h2 id="非局部u-net">非局部U-Net</h2>
<p>医学图像分割</p>
<p>U型网络</p>
<p>U -net局限：</p>
<ul>
<li>局部运算，小内核</li>
<li>更多的上、下采样丢失更多空间信息</li>
</ul>
<p>创新：</p>
<ul>
<li>低级特征和高级特征使用求和而不是连接</li>
</ul>
]]></content>
      <categories>
        <category>组会</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>组会</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云安全组开放端口不生效</title>
    <url>/%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E5%85%A8%E7%BB%84%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%E4%B8%8D%E7%94%9F%E6%95%88/</url>
    <content><![CDATA[<p>有一天开始练习Django，然后发现怎么都在7997端口上跑不起来，一开始我还以为是新版本和老版本方式不一样，因为我7997已经在阿里云控制台放行了，但是在之前开放的8000端口却能够正常运行，这时我感觉应该是端口的问题，后来发现是不知道为什么阿里云里面已经开放了但是ufw却没有允许7997端口，原因我不知道是为什么，只找到了解决方法。这里记录一些ufw用法。</p>
<p>参考：https://blog.csdn.net/bigdata_mining/article/details/80699180</p>
<a id="more"></a>
<p>LInux原始的防火墙工具iptables由于过于繁琐，所以ubuntu系统默认提供了一个基于iptable之上的防火墙工具ufw。而UFW支持图形界面操作，只需在命令行运行ufw命令即能看到一系列的操作。接下来，就由专业运营香港服务器、美国服务器、韩国服务器等国外服务器的天下数据为大家介绍ubuntu系统防火墙的开启、关闭等常规操作命令。</p>
<p>ubuntu 系统默认已安装ufw.</p>
<p><strong>1.安装</strong></p>
<p>sudo apt-get install ufw</p>
<p><strong>2.启用</strong></p>
<p>sudo ufw enable</p>
<p>sudo ufw default deny</p>
<p>运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。关闭所有外部对本机的访问，但本机访问外部正常。</p>
<p><strong>3.开启/禁用端口</strong></p>
<p>sudo ufw allow|deny ［service］</p>
<p>打开或关闭某个端口，例如： sudo ufw allow
smtp　允许所有的外部IP访问本机的25/tcp （smtp）端口</p>
<p>sudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp
（ssh）端口</p>
<p>sudo ufw allow 53 允许外部访问53端口（tcp/udp）</p>
<p>sudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口</p>
<p>sudo ufw allow proto udp 192.168.0.1 port 53 to 192.168.0.2 port
53</p>
<p>sudo ufw deny smtp 禁止外部访问smtp服务</p>
<p>sudo ufw delete allow smtp 删除上面建立的某条规则</p>
<p><strong>4.查看防火墙状态</strong></p>
<p>sudo ufw status</p>
<p><strong>开启/关闭防火墙 （默认设置是’disable’）</strong></p>
<p>sudo ufw enable|disable</p>
<p>**转换日志状态*</p>
<p>sudo ufw logging on|off</p>
<p>设置默认策略 （比如 “mostly open” vs “mostly closed”）</p>
<p>sudo ufw default allow|deny</p>
<p>许可或者屏蔽端口 （可以在“status”
中查看到服务列表）。可以用“协议：端口”的方式指定一个存在于/etc/services中的服务名称，也可以通过包的meta-data。
‘allow’ 参数将把条目加入 /etc/ufw/maps ，而 ‘deny’
则相反。基本语法如下：</p>
<p>sudo ufw allow|deny ［service］</p>
<p>显示防火墙和端口的侦听状态，参见
/var/lib/ufw/maps。括号中的数字将不会被显示出来。</p>
<p>sudo ufw status</p>
<p><strong>UFW 使用范例：</strong></p>
<p>允许 53 端口</p>
<p>$ sudo ufw allow 53</p>
<p>禁用 53 端口</p>
<p>$ sudo ufw delete allow 53</p>
<p>允许 80 端口</p>
<p>$ sudo ufw allow 80/tcp</p>
<p>禁用 80 端口</p>
<p>$ sudo ufw delete allow 80/tcp</p>
<p>允许 smtp 端口</p>
<p>$ sudo ufw allow smtp</p>
<p>删除 smtp 端口的许可</p>
<p>$ sudo ufw delete allow smtp</p>
<p>允许某特定 IP</p>
<p>$ sudo ufw allow from 192.168.254.254</p>
<p>删除上面的规则</p>
<p>$ sudo ufw delete allow from 192.168.254.254</p>
<p>Linux
2.4内核以后提供了一个非常优秀的防火墙工具：netfilter/iptables，他免费且功能强大，可以对流入、流出的信息进行细化控制，它可以
实现防火墙、NAT（网络地址翻译）和数据包的分割等功能。netfilter工作在内核内部，而iptables则是让用户定义规则集的表结构。</p>
<p>但是iptables的规则稍微有些“复杂”，因此ubuntu提供了ufw这个设定工具，以简化iptables的某些设定，其后台仍然是
iptables。ufw 即uncomplicated
firewall的简称，一些复杂的设定还是要去iptables。</p>
<p><strong>ufw相关的文件和文件夹有：</strong></p>
<p>/etc /ufw/：里面是一些ufw的环境设定文件，如
before.rules、after.rules、sysctl.conf、ufw.conf，及 for ip6 的
before6.rule 及 after6.rules。这些文件一般按照默认的设置进行就ok。</p>
<p>若开启ufw之后，/etc/ufw/sysctl.conf会覆盖默认的/etc/sysctl.conf文件，若你原来的/etc/sysctl.conf做了修
改，启动ufw后，若/etc/ufw/sysctl.conf中有新赋值，则会覆盖/etc/sysctl.conf的，否则还以/etc
/sysctl.conf为准。当然你可以通过修改/etc/default/ufw中的“IPT_SYSCTL=”条目来设置使用哪个
sysctrl.conf.</p>
<p>/var/lib/ufw/user.rules
这个文件中是我们设置的一些防火墙规则，打开大概就能看明白，有时我们可以直接修改这个文件，不用使用命令来设定。修改后记得ufw
reload重启ufw使得新规则生效。</p>
<p><strong>下面是ufw命令行的一些示例：</strong></p>
<p>ufw enable/disable：打开/关闭ufw</p>
<p>ufw status：查看已经定义的ufw规则</p>
<p>ufw default allow/deny：外来访问默认允许/拒绝</p>
<p>ufw allow/deny 20：允许/拒绝
访问20端口，20后可跟/tcp或/udp，表示tcp或udp封包。</p>
<p>ufw allow/deny
servicename:ufw从/etc/services中找到对应service的端口，进行过滤。</p>
<p>ufw allow proto tcp from 10.0.1.0/10 to 本机ip port
25：允许自10.0.1.0/10的tcp封包访问本机的25端口。</p>
<p>ufw delete allow/deny
20：删除以前定义的“允许/拒绝访问20端口”的规则</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>服务器配置</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>达梦数据库插入或更新</title>
    <url>/%E8%BE%BE%E6%A2%A6%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E6%88%96%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>记录下在国产达梦数据库中使用merge into来进行数据的更新或新增</p>
<a id="more"></a>
<blockquote>
<p>使用达梦是因为有国产化需求，因为我这里还不是那种性能敏感的开发，所以对我来说除了在安装上稍微麻烦一点外，使用起来和mysql没有太大的区别，这里使用达梦自己的dmPython库来进行数据库操作</p>
</blockquote>
<h3 id="replace-into">replace into</h3>
<blockquote>
<p>这部分主要参考以下该篇<a
href="https://blog.csdn.net/liu379702831/article/details/105819304/">博客</a></p>
</blockquote>
<p>首先说一下比较常见的replace into操作，在mysql中经常会用到replace
into操作。</p>
<p>replace into 首先尝试插入数据到表中：</p>
<ol type="1">
<li>如果发现表中已经有此行数据（根据主键或者唯一索引判断）则先删除此行数据，然后插入新的数据。</li>
<li>否则，直接插入新数据</li>
</ol>
<p>用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">replace into tbl_name(col_name, …) values(…)</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>插入数据的表必须有主键或者是唯一索引！否则的话，replace into
会直接插入数据，这将导致表中出现重复的数据。</li>
<li>如果数据库里边有这条记录，则直接修改这条记录；如果没有则，则直接插入，在有外键的情况下，对主表进行这样操作时，因为如果主表存在一条记录，被从表所用时，直接使用replace
into是会报错的，这和replace
into的内部原理是相关（先删除然后再插入）。</li>
<li>表中有一个自增的主键,会带来的问题：
<ul>
<li>replace操作在自增主键的情况下，遇到唯一键冲突时执行的是delete+insert，但是在记录binlog时，却记录成了update操作，update操作不会涉及到auto_increment的修改。备库应用了binlog之后，备库的表的auto_increment属性不变。如果主备库发生主从切换，备库变为原来的主库，写新的主库则有风险发生主键冲突。</li>
<li>频繁的REPLACE INTO
会造成新纪录的主键的值迅速增大。总有一天。达到最大值后就会因为数据太大溢出了。就没法再插入新纪录了。数据表满了，不是因为空间不够了，而是因为主键的值没法再增加了。</li>
</ul></li>
</ul>
<h3 id="merge-into">merge into</h3>
<blockquote>
<p>达梦数据库不是每个版本都支持replace into命令的，而且replace
into命令功能比较固定，而且在存在自增主键时还会有一些限制，所以这里我们采用merge
into命令来完成达梦数据库的插入或更新</p>
</blockquote>
<p>merge
into是Oracle的指令，达梦对Oracle的兼容性还比较好，而且开发文档里说明了支持merge
into指令。</p>
<p>用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 新增或更新基线</span><br><span class="line">db &#x3D; dmPython.connect(user&#x3D;dm_user, password&#x3D;dm_pwds, server&#x3D;dm_host, port&#x3D;dm_port,</span><br><span class="line">                      cursorclass&#x3D;dmPython.DictCursor)</span><br><span class="line">cursor &#x3D; db.cursor()</span><br><span class="line"></span><br><span class="line">sql &#x3D; &quot;merge into %s.%s &quot; \</span><br><span class="line">      &quot;using (select ? sIP,? updatetime from dual) t &quot; \</span><br><span class="line">      &quot;on(%s.%s.sIP &#x3D; t.sIP) &quot; \</span><br><span class="line">      &quot;when matched then &quot; \</span><br><span class="line">      &quot;update set updatetime&#x3D;t.updatetime &quot; \</span><br><span class="line">      &quot;when not matched then &quot; \</span><br><span class="line">      &quot;insert (sIP, updatetime) values (t.sIP,t.updatetime)&quot; \</span><br><span class="line">      % (dm_db, baseline_table, dm_db, baseline_table)</span><br><span class="line">try:</span><br><span class="line">    cursor.executemany(sql, baseline_list_tuple)</span><br><span class="line">    db.commit()</span><br><span class="line">    print(&quot;更新成功&quot;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br><span class="line">    db.rollback()</span><br><span class="line">finally:</span><br><span class="line">    cursor.close()</span><br><span class="line">    db.close()</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>我看到的资料上面说on后面要跟主键信息，但是我这里使用的不是主键，但是能正常使用</li>
<li>merge
into是通过执⾏using后括号内的sql语句结果逐条与on括号内条件进⾏匹配，若匹配则执⾏更新，若不匹配则执⾏插⼊</li>
<li>when matched then语句需在when not matched then
之前，否则达梦数据库会报错</li>
<li>关于dual表，我个⼈理解为类似于“缓存器”的表，你可以向它⾥⾯插⼊多条数据，删除多条数据，但你查询时，表中均只显⽰⼀个字段，⼀⾏数据。</li>
<li>在使用merge
into语句的时候我遇到了一个关于字符型数据的问题，在达梦数据库管理软件中只能使用<strong>单引号</strong>来框住字符串，用<strong>双引号</strong>则会报错，这其实不是merge
into语句的问题，而是达梦sql语句的问题，很久没用其他数据库了，不知道这是数据库的通用规则，还是达梦的特殊规则。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>达梦</category>
      </categories>
      <tags>
        <tag>达梦</tag>
      </tags>
  </entry>
</search>
